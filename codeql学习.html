<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <title>codeql学习</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <header>
        <nav class="site-nav">
            <a href="/index.html" class="nav-link">/home</a>
            <span class="nav-separator">|</span>
            <a href="/about.html" class="nav-link">/about</a>
        </nav>
        <div class="terminal-prompt">
            <span style="color:#666">[</span><span style="color:#fabd2f">ayoung</span><span style="color:#666">@</span><span style="color:#59adeb">lab</span> <span style="color:#83a598"><a href="/index.html" class="path-link">posts</a></span><span style="color:#666">]$</span> 
            <span class="cmd">cat ./codeql学习.md</span><span class="cursor">█</span>
        </div>
        <h1 class="post-title">codeql学习</h1><div style="color: #666; font-size: 0.8rem; margin-bottom: 20px;">[Last modified: 2024-10-27]</div>
    </header>
    <div class="layout-grid">
                <main><h1 id="gai-shu">概述</h1><p>用户可以使用 ql 语言编写自定义规则识别软件中的漏洞，也可以使用ql自带的规则进行扫描</p>
<h1 id="huan-jing-da-jian">环境搭建</h1><p>codeql的工作方式是首先使用codeql来编译源码，从源码中搜集需要的信息，然后将搜集到的信息保存为代码数据库文件，用户通过编写codeql规则从数据库中搜索出匹配的代码，工作示意图如下：</p>
<p><img src="/images/20210307124958-91ad19fe-7f00-1.png" alt="" />20210307124958-91ad19fe-7f00-1</p>
<p>在github release下载二进制安装包
vscode下载插件</p>
<p>再clone一下这个：codeql starter，打开工作区</p>
<p>首先使用codeql编译代码并创建数据库</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ayoung@LAPTOP-1J0VDV39:~/codeql/vscode-codeql-starter/codeql-custom-queries-cpp$ codeql database create --language=cpp -c &quot;gcc hello.c -o hello&quot; ./hello_codedb
</span><span style="color:#c0c5ce;">Initializing database at /home/ayoung/codeql/vscode-codeql-starter/codeql-custom-queries-cpp/hello_codedb.
</span><span style="color:#c0c5ce;">Running build command: [gcc, hello.c, -o, hello]
</span><span style="color:#c0c5ce;">Finalizing database at /home/ayoung/codeql/vscode-codeql-starter/codeql-custom-queries-cpp/hello_codedb.
</span><span style="color:#c0c5ce;">Successfully created database at /home/ayoung/codeql/vscode-codeql-starter/codeql-custom-queries-cpp/hello_codedb.
</span></pre>
<p>然后就可以在vscode用插件加载数据库。在linux上创建数据库，在windows平台加载数据库并进行查询，故还需要将数据库打包（如果都在linux上进行则不需要此步骤）</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ayoung@LAPTOP-1J0VDV39:~/codeql/vscode-codeql-starter/codeql-custom-queries-cpp$ codeql database bundle -o hello_codedb.zip hello_codedb
</span><span style="color:#c0c5ce;">Creating bundle metadata for /home/ayoung/codeql/vscode-codeql-starter/codeql-custom-queries-cpp/hello_codedb...
</span><span style="color:#c0c5ce;">Creating zip file at /home/ayoung/codeql/vscode-codeql-starter/codeql-custom-queries-cpp/hello_codedb.zip.
</span></pre>
<p>最后点击codeql插件，上方databases点击from folder即可打开数据库</p>
<p>另外如果不想用starter，想单独配置工作区，则工作区右键add folder to workspace添加ql库，同时workspace里要有一个<code>qlpack.yml</code>，内容为</p>
<pre style="background-color:#2b303b;">
<span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">name/example
</span><span style="color:#bf616a;">version</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">0.0.0
</span><span style="color:#bf616a;">libraryPathDependencies</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">codeql/cpp-all
</span></pre>
<h1 id="demo">demo</h1><p>下面示例代码用的https://github.com/hac425xxx/sca-workshop/tree/master/ql-example</p>
<p><code>import</code> 语句可以导入需要的库，库里面会封装一些函数、类供我们使用
<code>from</code> 语句用于定义查询中需要使用的变量
<code>where</code> 语句用于设置变量需要满足的条件
<code>select</code> 语句则用于将结果显示，可以选择结果中需要输出的东西</p>
<h2 id="systemming-ling-zhu-ru">system命令注入</h2><p>查询函数名</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from FunctionCall fc
</span><span style="color:#c0c5ce;">select fc.getTarget().getQualifiedName(), fc
</span></pre>
<p><img src="/images/image-20231030200454359.png" alt="" />image-20231030200454359</p>
<p>查询内部调用了<code>system</code>的函数</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from FunctionCall fc
</span><span style="color:#c0c5ce;">where fc.getTarget().getName().matches(&quot;system&quot;)
</span><span style="color:#c0c5ce;">select fc.getEnclosingFunction(), fc
</span></pre>
<p><img src="/images/image-20231030200512007.png" alt="" />image-20231030200512007</p>
<p>查询内部调用了<code>system</code>的且<code>system</code>参数不为常量</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from FunctionCall fc
</span><span style="color:#c0c5ce;">where fc.getTarget().getName().matches(&quot;system&quot;) and not fc.getArgument(0).isConstant()
</span><span style="color:#c0c5ce;">select fc.getEnclosingFunction(), fc, fc.getArgument(0)
</span></pre>
<p><img src="/images/image-20231030200535186.png" alt="" />image-20231030200535186</p>
<p>fc查找调用<code>system</code>的函数，clean_fc查找调用了<code>clean_data</code>的函数，然后排除这两个函数处于同一个函数下的函数</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from FunctionCall fc, FunctionCall clean_fc
</span><span style="color:#c0c5ce;">where
</span><span style="color:#c0c5ce;">  fc.getTarget().getName().matches(&quot;system&quot;) and
</span><span style="color:#c0c5ce;">  not fc.getArgument(0).isConstant() and
</span><span style="color:#c0c5ce;">  clean_fc.getTarget().getName().matches(&quot;clean_data&quot;) and
</span><span style="color:#c0c5ce;">  not clean_fc.getEnclosingFunction() = fc.getEnclosingFunction()
</span><span style="color:#c0c5ce;">select fc.getEnclosingFunction(), fc, fc.getArgument(0)
</span></pre>
<p><img src="/images/image-20231030201741093.png" alt="" />image-20231030201741093</p>
<p>解决误报，启用污点跟踪
污点跟踪由 TaintTracking 模块提供，codeql 支持 local 和 global 两种污点追踪模块，区别在于 local 的污点追踪只能追踪函数内的代码，函数外部的不追踪，global 则会在整个源码工程中对数据进行追踪</p>
<p>查询解释如下：
首先定义了两个函数调用 system_call 和 user_input ，分别表示调用 system 和 get_user_input_str 的函数调用表达式
然后定义 source 和 sink 作为污点跟踪的 source 和 sink 点
然后利用 sink.asExpr() = system_call.getArgument(0) 设置 sink 点为 system 函数调用的第一个参数
然后利用 source.asExpr() 设置 sink 点为 get_user_input_str 函数调用的第一个参数
最后使用 TaintTracking::localTaint 查找从 source 到 sink 的查询
（也就是说去找 获取用户输入，并把输入传给system 这么个模式）</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from FunctionCall system_call, FunctionCall user_input, DataFlow::Node source, DataFlow::Node sink
</span><span style="color:#c0c5ce;">where
</span><span style="color:#c0c5ce;">  system_call.getTarget().getName().matches(&quot;system&quot;) and
</span><span style="color:#c0c5ce;">  user_input.getTarget().getName().matches(&quot;get_user_input_str&quot;) and
</span><span style="color:#c0c5ce;">  sink.asExpr() = system_call.getArgument(0) and
</span><span style="color:#c0c5ce;">  source.asExpr() = user_input and
</span><span style="color:#c0c5ce;">  TaintTracking::localTaint(source, sink)
</span><span style="color:#c0c5ce;">select user_input, user_input.getEnclosingFunction()
</span></pre>
<p><img src="/images/image-20231030203028577.png" alt="" />image-20231030203028577</p>
<p>用<code>localTaint</code>可能有漏报，可能是<code>our_wrapper_system()</code>
也有误报因为中间可能被clean了</p>
<p>先处理没有考虑<code>our_wrapper_system</code>的情况，一种方法是把 <code>our_wrapper_system</code> 也考虑进 <code>sink</code> 点</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">predicate setSystemSink(FunctionCall fc, Expr e) {
</span><span style="color:#c0c5ce;">  fc.getTarget().getName().matches(&quot;system&quot;) and
</span><span style="color:#c0c5ce;">  fc.getArgument(0) = e
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">predicate setWrapperSystemSink(FunctionCall fc, Expr e) {
</span><span style="color:#c0c5ce;">  fc.getTarget().getName().matches(&quot;our_wrapper_system&quot;) and
</span><span style="color:#c0c5ce;">  fc.getArgument(0) = e
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from FunctionCall fc, FunctionCall user_input, DataFlow::Node source, DataFlow::Node sink
</span><span style="color:#c0c5ce;">where
</span><span style="color:#c0c5ce;">  (
</span><span style="color:#c0c5ce;">    setWrapperSystemSink(fc, sink.asExpr()) or
</span><span style="color:#c0c5ce;">    setSystemSink(fc, sink.asExpr())
</span><span style="color:#c0c5ce;">  ) and
</span><span style="color:#c0c5ce;">  user_input.getTarget().getName().matches(&quot;get_user_input_str&quot;) and
</span><span style="color:#c0c5ce;">  sink.asExpr() = fc.getArgument(0) and
</span><span style="color:#c0c5ce;">  source.asExpr() = user_input and
</span><span style="color:#c0c5ce;">  TaintTracking::localTaint(source, sink)
</span><span style="color:#c0c5ce;">select user_input, user_input.getEnclosingFunction()
</span></pre>
<p><img src="/images/image-20231101114622620.png" alt="" />image-20231101114622620</p>
<p>或者用global taint
要使用 global taint 需要定义一个类继承自 TaintTracking::Configuration ，然后重写 isSource 和 isSink
isSource 用于定义 source 点，指定 get_user_input_str 的函数调用为 source 点
isSink 定义 sink 点，指定 system 的一个参数为 sink 点
然后在 where 语句里面使用 cfg.hasFlowPath(source, sink) 查询到从 source 到 sink 的代码</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class SystemCfg extends TaintTracking::Configuration {
</span><span style="color:#c0c5ce;">  SystemCfg() { this = &quot;SystemCfg&quot; }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    source.asExpr().(FunctionCall).getTarget().getName() = &quot;get_user_input_str&quot;
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(FunctionCall call |
</span><span style="color:#c0c5ce;">      sink.asExpr() = call.getArgument(0) and
</span><span style="color:#c0c5ce;">      call.getTarget().getName() = &quot;system&quot;
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from DataFlow::PathNode sink, DataFlow::PathNode source, SystemCfg cfg
</span><span style="color:#c0c5ce;">where cfg.hasFlowPath(source, sink)
</span><span style="color:#c0c5ce;">select source, sink
</span></pre>
<p><img src="/images/image-20231101114955835.png" alt="" />image-20231101114955835</p>
<p>然后发现<code>call_system_safe_example</code>函数还是被测出来了，可以通过<code>isSanitizer</code>函数剔除污点数据流入<code>clean_data</code></p>
<p>用到global value numbering</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">import semmle.code.cpp.valuenumbering.GlobalValueNumbering
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class SystemCfg extends TaintTracking::Configuration {
</span><span style="color:#c0c5ce;">  SystemCfg() { this = &quot;SystemCfg&quot; }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    source.asExpr().(FunctionCall).getTarget().getName() = &quot;get_user_input_str&quot;
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(FunctionCall call |
</span><span style="color:#c0c5ce;">      sink.asExpr() = call.getArgument(0) and
</span><span style="color:#c0c5ce;">      call.getTarget().getName() = &quot;system&quot;
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSanitizer(DataFlow::Node nd) {
</span><span style="color:#c0c5ce;">    exists(FunctionCall fc |
</span><span style="color:#c0c5ce;">      fc.getTarget().getName() = &quot;clean_data&quot; and
</span><span style="color:#c0c5ce;">      globalValueNumber(fc.getArgument(0)) = globalValueNumber(nd.asExpr())
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from DataFlow::PathNode sink, DataFlow::PathNode source, SystemCfg cfg
</span><span style="color:#c0c5ce;">where cfg.hasFlowPath(source, sink)
</span><span style="color:#c0c5ce;">select source, sink
</span></pre>
<h2 id="shu-zu-yue-jie">数组越界</h2><p>漏洞代码</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> global_array[</span><span style="color:#d08770;">40</span><span style="color:#c0c5ce;">] = {</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">array_oob</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> user = </span><span style="color:#8fa1b3;">read_byte</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    global_array[user] = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>漏洞模型：污点跟踪查询，source点是read_byte()的调用，sink点是污点数据被用作数组索引</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class ArrayOOBCfg extends TaintTracking::Configuration {
</span><span style="color:#c0c5ce;">  ArrayOOBCfg() { this = &quot;ArrayOOBCfg&quot; }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    source.asExpr().(FunctionCall).getTarget().getName() = &quot;read_byte&quot;
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(ArrayExpr ae | sink.asExpr() = ae.getArrayOffset())
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from DataFlow::PathNode sink, DataFlow::PathNode source, ArrayOOBCfg cfg
</span><span style="color:#c0c5ce;">where cfg.hasFlowPath(source, sink)
</span><span style="color:#c0c5ce;">select source.getNode().asExpr().(FunctionCall).getEnclosingFunction(), source, sink
</span></pre>
<p><code>source.asExpr().(FunctionCall).getTarget().getName() = "read_byte"</code>，让source为read_byte的FunctionCall语句，其中<code>.(FunctionCall)</code>类似强制转换</p>
<p>sink点查询：ql中很多语法结构都有对应的类来表示，比如这里涉及的数组访问可以通过ArrayExpr对象获取，<code>getArrayOffset()</code>获取偏移，<code>getArrayBase()</code>获取数组基地址</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from ArrayExpr ae
</span><span style="color:#c0c5ce;">select ae, ae.getArrayOffset(), ae.getArrayBase()
</span></pre>
<p>发现查到一个误报</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">no_array_oob</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> user = </span><span style="color:#8fa1b3;">read_byte</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(user &gt;= sizeof(global_array))
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    global_array[user] = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>进行过滤，这里就简单的认为用户输入进入 if 语句的条件判断中就认为用户输入被正确的校验了。<code>codeql</code> 使用 <code>IfStmt</code> 来表示一个 if 语句，然后使用 <code>getControllingExpr</code> 可以获取到 <code>if</code> 语句的控制语句部分，然后我们使用 <code>getAChild*</code> 递归的遍历控制语句的所有子节点，只要有 <code>nd</code> 为控制语句中的一部分就返回<code>true</code>。</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">override predicate isSanitizer(DataFlow::Node nd) {
</span><span style="color:#c0c5ce;">    exists(IfStmt ifs |
</span><span style="color:#c0c5ce;">      globalValueNumber(ifs.getControllingExpr().getAChild*()) = globalValueNumber(nd.asExpr())
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span></pre>
<h2 id="yin-yong-ji-shu-xiang-guan">引用计数相关</h2><p>漏洞代码</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">ref_leak</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">ref</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ref_get</span><span style="color:#c0c5ce;">(ref);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(a == </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">error 2</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ref_put</span><span style="color:#c0c5ce;">(ref);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>漏洞是当 a=2 时会直接返回，没有调用 ref_put 对引用计数减一，漏洞模型：在某些存在 return的条件分支中没有调用 ref_put 释放引用计数。</p>
<p>查询代码如下</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class RefGetFunctionCall extends FunctionCall {
</span><span style="color:#c0c5ce;">  RefGetFunctionCall() { this.getTarget().getName() = &quot;ref_get&quot; }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class RefPutFunctionCall extends FunctionCall {
</span><span style="color:#c0c5ce;">  RefPutFunctionCall() { this.getTarget().getName() = &quot;ref_put&quot; }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class EvilIfStmt extends IfStmt {
</span><span style="color:#c0c5ce;">  EvilIfStmt() {
</span><span style="color:#c0c5ce;">    exists(ReturnStmt rs |
</span><span style="color:#c0c5ce;">      this.getAChild*() = rs and
</span><span style="color:#c0c5ce;">      not exists(RefPutFunctionCall rpfc | rpfc.getEnclosingBlock() = rs.getEnclosingBlock())
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from RefGetFunctionCall rgfc, EvilIfStmt eifs
</span><span style="color:#c0c5ce;">where eifs.getEnclosingFunction() = rgfc.getEnclosingFunction()
</span><span style="color:#c0c5ce;">select eifs.getEnclosingFunction(), eifs
</span></pre>
<p>代码使用类来定义某个特定的函数调用，比如 RefPutFunctionCall 用于表示调用 ref_put 函数的函数调用语句
用EvilIfStmt表示存在returnd但没有调用ref_put的代码</p>
<p>首先用<code>this.getAChild*() = rs</code>约束<code>this</code>为一个包含return语句的if结构
然后加上一个<code>exists</code>确保和rs同一个块的语句里没有return语句</p>
<p>漏洞代码二</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">ref_dec_error</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">ref</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ref_get</span><span style="color:#c0c5ce;">(ref);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(a == </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">ref_dec_error 2</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">ref_put</span><span style="color:#c0c5ce;">(ref);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">ref_put</span><span style="color:#c0c5ce;">(ref);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>a==2</code>调用ref_put了，但没有return
漏洞模型：某些条件分支中调用ref_put释放引用计数，但没有return返回。可能导致ref_put多次</p>
<p>查询代码如下</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class RefGetFunctionCall extends FunctionCall {
</span><span style="color:#c0c5ce;">  RefGetFunctionCall() { this.getTarget().getName() = &quot;ref_get&quot; }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class RefPutFunctionCall extends FunctionCall {
</span><span style="color:#c0c5ce;">  RefPutFunctionCall() { this.getTarget().getName() = &quot;ref_put&quot; }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class EvilIfStmt extends IfStmt {
</span><span style="color:#c0c5ce;">  EvilIfStmt() {
</span><span style="color:#c0c5ce;">    exists(RefPutFunctionCall rpfc |
</span><span style="color:#c0c5ce;">      this.getAChild*() = rpfc and
</span><span style="color:#c0c5ce;">      not exists(ReturnStmt rs | rpfc.getEnclosingBlock() = rs.getEnclosingBlock())
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from RefGetFunctionCall rgfc, EvilIfStmt eifs
</span><span style="color:#c0c5ce;">where eifs.getEnclosingFunction() = rgfc.getEnclosingFunction()
</span><span style="color:#c0c5ce;">select eifs.getEnclosingFunction(), eifs
</span></pre>
<p>只有类<code>EvilIfStmt</code>发生了变动，其中首先约束语句包含refput，然后要求不存在return</p>
<h2 id="wai-bu-han-shu-jian-mo">外部函数建模</h2><p>静态污点分析的常见问题当数据流入外部函数（比如没有源码的库函数）中时污点分析引擎就可能会丢失污点传播信息</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">custom_memcpy</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">dst</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">src</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">sz</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">call_our_wrapper_system_custom_memcpy_example</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*user = </span><span style="color:#8fa1b3;">get_user_input_str</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*tmp = </span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#96b5b4;">strlen</span><span style="color:#c0c5ce;">(user) + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">custom_memcpy</span><span style="color:#c0c5ce;">(tmp, user, </span><span style="color:#96b5b4;">strlen</span><span style="color:#c0c5ce;">(user));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">our_wrapper_system</span><span style="color:#c0c5ce;">(tmp);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>直接使用ql查询会发现查询不到这个代码，因为<code>custom_memcpy</code>是一个外部函数，code的污点跟踪引擎无法知道污点传播规则</p>
<p>解决方法：</p>
<ol>
<li>重写<code>isAdditionalTainStep</code>函数</li>
</ol>
<p>使用 TaintTracking::Configuration 时可以通过重写 isAdditionalTaintStep 函数来自定义污点传播规则</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">override predicate isAdditionalTaintStep(DataFlow::Node pred, DataFlow::Node succ) {
</span><span style="color:#c0c5ce;">    exists(FunctionCall fc |
</span><span style="color:#c0c5ce;">      pred.asExpr() = fc.getArgument(1) and fc.getTarget().getName() = &quot;custom_memcpy&quot;
</span><span style="color:#c0c5ce;">      and succ.asDefiningArgument() = fc.getArgument(0)
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span></pre>
<p><code>isAdditionalTaintStep</code>：返回true表示污点从pred流入succ
指定custom的第1个参数src流入第0个参数dst</p>
<p>asExpr()，匹配函数参数
asDefiningArgument()，当调用返回后引用参数的值时使用
（？）</p>
<ol start="2">
<li>给ql源码增加模型</li>
</ol>
<p>在ql的源码里面内置很多标准库函数的模型，比如strcpy，memcpy 等，代码路径为<code>cpp\ql\src\semmle\code\cpp\models\implementations\Memcpy.qll</code>
<img src="/images/22222222.png" alt="" /></p>
<p>可以在此处新建一个<code>.qll</code>文件</p>
<p>然后在<code>Models.qll</code>里面<code>private import</code>导入一下即可</p>
<h1 id="tutorial">tutorial</h1><h2 id="wei-ci">谓词</h2><p>predicate，可以无返回值也可以有返回值
无返回值声明</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">predicate isSmall(int i) {
</span><span style="color:#c0c5ce;">  i in [1 .. 9]
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>有返回值声明，需要声明返回值数据类型</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">int getSuccessor(int i) {
</span><span style="color:#c0c5ce;">  // 若传入的i位于1-9内，则返回i+1
</span><span style="color:#c0c5ce;">  // 注意这个语法不能用C++语法来理解
</span><span style="color:#c0c5ce;">  result = i + 1 and i in [1 .. 9]
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>可能返回多个结果或不返回结果</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">string getANeighbor(string country) {
</span><span style="color:#c0c5ce;">    country = &quot;France&quot; and result = &quot;Belgium&quot;
</span><span style="color:#c0c5ce;">    or
</span><span style="color:#c0c5ce;">    country = &quot;France&quot; and result = &quot;Germany&quot;
</span><span style="color:#c0c5ce;">    or
</span><span style="color:#c0c5ce;">    country = &quot;Germany&quot; and result = &quot;Austria&quot;
</span><span style="color:#c0c5ce;">    or
</span><span style="color:#c0c5ce;">    country = &quot;Germany&quot; and result = &quot;Belgium&quot;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">select getANeighbor(&quot;France&quot;)
</span><span style="color:#c0c5ce;">// 返回两个条目，&quot;Belgium&quot;与&quot;Germany&quot;
</span></pre>
<p>不允许描述的数据集合个数不是有限数量大小</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">// 该谓词将使得编译报错
</span><span style="color:#c0c5ce;">int multiplyBy4(int i) {
</span><span style="color:#c0c5ce;">  // i是一个数据集合，此时该集合可能是**无限大小**
</span><span style="color:#c0c5ce;">  // result集合被设置为i*4，意味着result集合的大小有可能也是**无限大小**
</span><span style="color:#c0c5ce;">  result = i * 4
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>如果仍需定义这类函数，则必须限制集合数据大小，同时添加一个bindingset标注。该标注将会声明谓词plusOne所包含的数据集合是有限的，前提是绑定到有限数量的数据集合。</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">bindingset[x] bindingset[y]
</span><span style="color:#c0c5ce;">predicate plusOne(int x, int y) {
</span><span style="color:#c0c5ce;">  x + 1 = y
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from int x, int y
</span><span style="color:#c0c5ce;">where y = 42 and plusOne(x, y)
</span><span style="color:#c0c5ce;">select x, y
</span></pre>
<h2 id="di-gui">递归</h2><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Person ancestorOf(Person p) {
</span><span style="color:#c0c5ce;">  result = parentOf(p) or
</span><span style="color:#c0c5ce;">  result = parentOf(ancestorOf(p))
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>parentOf+(p) applies the parentOf() predicate to p one or more times. This is equivalent to ancestorOf(p).
parentOf*(p) applies the parentOf() predicate to p zero or more times, so it returns an ancestor of p or p itself.</p>
<p><code>parentOf+(p)</code>将函数用在p上一次或多次，等于<code>ancestorOf(p)</code>（传递闭包）
<code>parentOf*(p)</code>将函数用在p上0或多次，返回p的祖先或p自己（自反传递闭包）</p>
<h2 id="lei">类</h2><p>类名开头需要是大写</p>
<p>一个用codeql解决的路径规划问题，将货物从左岸搬到右岸，通过递归直接得到可能的路径（不重复且符合约束条件，例如山羊和狼不同时在一起）</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import tutorial
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">/** A possible cargo item. */
</span><span style="color:#c0c5ce;">class Cargo extends string {
</span><span style="color:#c0c5ce;">  Cargo() {
</span><span style="color:#c0c5ce;">    this = &quot;Nothing&quot; or
</span><span style="color:#c0c5ce;">    this = &quot;Goat&quot; or
</span><span style="color:#c0c5ce;">    this = &quot;Cabbage&quot; or
</span><span style="color:#c0c5ce;">    this = &quot;Wolf&quot;
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">/** One of two shores. */
</span><span style="color:#c0c5ce;">class Shore extends string {
</span><span style="color:#c0c5ce;">  Shore() {
</span><span style="color:#c0c5ce;">    this = &quot;Left&quot; or
</span><span style="color:#c0c5ce;">    this = &quot;Right&quot;
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  /** Returns the other shore. */
</span><span style="color:#c0c5ce;">  Shore other() {
</span><span style="color:#c0c5ce;">    this = &quot;Left&quot; and result = &quot;Right&quot;
</span><span style="color:#c0c5ce;">    or
</span><span style="color:#c0c5ce;">    this = &quot;Right&quot; and result = &quot;Left&quot;
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">string renderState(Shore manShore, Shore goatShore, Shore cabbageShore, Shore wolfShore) {
</span><span style="color:#c0c5ce;">  result = manShore + &quot;,&quot; + goatShore + &quot;,&quot; + cabbageShore + &quot;,&quot; + wolfShore
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">/** A record of where everything is. */
</span><span style="color:#c0c5ce;">class State extends string {
</span><span style="color:#c0c5ce;">  Shore manShore;
</span><span style="color:#c0c5ce;">  Shore goatShore;
</span><span style="color:#c0c5ce;">  Shore cabbageShore;
</span><span style="color:#c0c5ce;">  Shore wolfShore;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  /** Renders the state as a string. */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  State() { this = manShore + &quot;,&quot; + goatShore + &quot;,&quot; + cabbageShore + &quot;,&quot; + wolfShore }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    /** Returns the state that is reached after ferrying a particular cargo item. */
</span><span style="color:#c0c5ce;">  State ferry(Cargo cargo) {
</span><span style="color:#c0c5ce;">    cargo = &quot;Nothing&quot; and
</span><span style="color:#c0c5ce;">    result = renderState(manShore.other(), goatShore, cabbageShore, wolfShore)
</span><span style="color:#c0c5ce;">    or
</span><span style="color:#c0c5ce;">    cargo = &quot;Goat&quot; and
</span><span style="color:#c0c5ce;">    result = renderState(manShore.other(), goatShore.other(), cabbageShore, wolfShore)
</span><span style="color:#c0c5ce;">    or
</span><span style="color:#c0c5ce;">    cargo = &quot;Cabbage&quot; and
</span><span style="color:#c0c5ce;">    result = renderState(manShore.other(), goatShore, cabbageShore.other(), wolfShore)
</span><span style="color:#c0c5ce;">    or
</span><span style="color:#c0c5ce;">    cargo = &quot;Wolf&quot; and
</span><span style="color:#c0c5ce;">    result = renderState(manShore.other(), goatShore, cabbageShore, wolfShore.other())
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  /**
</span><span style="color:#c0c5ce;">   * Holds if the state is safe. This occurs when neither the goat nor the cabbage
</span><span style="color:#c0c5ce;">   * can get eaten.
</span><span style="color:#c0c5ce;">   */
</span><span style="color:#c0c5ce;">  predicate isSafe() {
</span><span style="color:#c0c5ce;">    // The goat can&#39;t eat the cabbage.
</span><span style="color:#c0c5ce;">    (goatShore != cabbageShore or goatShore = manShore) and
</span><span style="color:#c0c5ce;">    // The wolf can&#39;t eat the goat.
</span><span style="color:#c0c5ce;">    (wolfShore != goatShore or wolfShore = manShore)
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  State reachesVia(string path, string visitedStates){
</span><span style="color:#c0c5ce;">    this = result and
</span><span style="color:#c0c5ce;">    visitedStates = this and
</span><span style="color:#c0c5ce;">    path = &quot;&quot;
</span><span style="color:#c0c5ce;">    or 
</span><span style="color:#c0c5ce;">    exists(string pathSofar, string vstateSofar, Cargo cargo |
</span><span style="color:#c0c5ce;">      result = this.reachesVia(pathSofar, vstateSofar).safeFerry(cargo) and
</span><span style="color:#c0c5ce;">      not exists(vstateSofar.indexOf(result)) and
</span><span style="color:#c0c5ce;">      visitedStates = vstateSofar + &quot;/&quot; + result and
</span><span style="color:#c0c5ce;">      path = pathSofar + &quot;\n Ferry &quot; + cargo +&quot; &quot; + result + &quot;\n&quot;
</span><span style="color:#c0c5ce;">      )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  /** Returns the state that is reached after safely ferrying a cargo item. */
</span><span style="color:#c0c5ce;">  State safeFerry(Cargo cargo) { result = this.ferry(cargo) and result.isSafe() }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">/** The initial state, where everything is on the left shore. */
</span><span style="color:#c0c5ce;">class InitialState extends State {
</span><span style="color:#c0c5ce;">  InitialState() { this = &quot;Left&quot; + &quot;,&quot; + &quot;Left&quot; + &quot;,&quot; + &quot;Left&quot; + &quot;,&quot; + &quot;Left&quot; }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">/** The goal state, where everything is on the right shore. */
</span><span style="color:#c0c5ce;">class GoalState extends State {
</span><span style="color:#c0c5ce;">  GoalState() { this = &quot;Right&quot; + &quot;,&quot; + &quot;Right&quot; + &quot;,&quot; + &quot;Right&quot; + &quot;,&quot; + &quot;Right&quot; }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from string path
</span><span style="color:#c0c5ce;">where any(InitialState i).reachesVia(path, _) = any(GoalState g)
</span><span style="color:#c0c5ce;">select path
</span></pre>
<h1 id="github-security-lab-ctf">GitHub Security Lab CTF</h1><h2 id="segv-hunt">SEGV hunt</h2><p>首先下载设计题目时对应的glibc数据库 <a href="https://github.com/github/securitylab/releases/download/segv-codeql-database/bminor_glibc_cpp-srcVersion_333221862ecbebde60dd16e7ca17d26444e62f50-dist_odasa-lgtm-2019-04-08-af06f68-linux64.zip">revision 3332218</a>，然后导入</p>
<h3 id="intro">intro</h3><p><code>alloca</code>用来在栈上申请缓冲区，然而当申请的大小过大时，可能返回一个无效指针，造成当尝试读写时触发<code>SIGSEGV</code> crash</p>
<h3 id="step-0-finding-the-definition-of-alloca">Step 0: finding the definition of alloca</h3><blockquote>
<p>Question 0.0: alloca is a macro. Find the definition of this macro and the name of the function that it expands to.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from MacroInvocation mi
</span><span style="color:#c0c5ce;">where
</span><span style="color:#c0c5ce;">  mi.getMacro().getName() = &quot;alloca&quot;
</span><span style="color:#c0c5ce;">select mi, mi.getEnclosingFunction()
</span></pre>
<h3 id="step-1-finding-the-calls-to-alloca-and-filtering-out-small-allocation-sizes">Step 1: finding the calls to alloca and filtering out small allocation sizes</h3><blockquote>
<p>Question 1.0: Find all the calls to alloca (using the function name that you found in step 0).
Question 1.1: Use the upperBound and lowerBound predicates from the SimpleRangeAnalysis library to filter out results which are safe because the allocation size is small. You can classify the allocation size as small if it is less than 65536. But don't forget that negative sizes are very dangerous.</p>
</blockquote>
<p>upperbound和lowerbound的参数需要是expr</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af
</span><span style="color:#c0c5ce;">where af.notSafealloc()
</span><span style="color:#c0c5ce;">select af, af.getArgument(0)
</span></pre>
<h3 id="step2-filtering-out-calls-that-are-guarded-by-libc-use-alloca">step2 filtering out calls that are guarded by __libc_use_alloca</h3><blockquote>
<p>The correct way to use alloca in glibc is to first check that the allocation is safe by calling __libc_use_alloca. You can see a good example of this at getopt.c:252. That code uses __libc_use_alloca to check if it is safe to use alloca. If not, it uses malloc instead. In this step, you will identify calls to alloca that are safe because they are guarded by a call to __libc_use_alloca.</p>
</blockquote>
<p>正确的方法是先用<code>__libc_use_alloc</code>检查申请是否安全，不安全时使用malloc代替</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">__libc_use_alloca </span><span style="color:#c0c5ce;">(n_options))
</span><span style="color:#c0c5ce;">  ambig_set = </span><span style="color:#8fa1b3;">alloca </span><span style="color:#c0c5ce;">(n_options);
</span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">((ambig_set = </span><span style="color:#96b5b4;">malloc </span><span style="color:#c0c5ce;">(n_options)) == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">/* Fall back to simpler error message.  */
</span><span style="color:#c0c5ce;">  ambig_fallback = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span></pre>
<h4 id="question-2-0">Question 2.0</h4><blockquote>
<p>Question 2.0: Find all calls to __libc_use_alloca.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af, LibcUseAlloca lua
</span><span style="color:#c0c5ce;">select lua
</span></pre>
<h4 id="question-2-1">Question 2.1</h4><blockquote>
<p>Question 2.1: Find all guard conditions where the condition is a call to __libc_use_alloca.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af, LibcUseAlloca lua, GuardCondition gc
</span><span style="color:#c0c5ce;">where 
</span><span style="color:#c0c5ce;">    gc.controls(af.getBasicBlock(), _) and
</span><span style="color:#c0c5ce;">    gc.getAChild*() = lua
</span><span style="color:#c0c5ce;">select gc
</span></pre>
<h4 id="question-2-2">Question 2.2</h4><blockquote>
<p>Sometimes the result of __libc_use_alloca is assigned to a variable, which is then used as the guard condition. For example, this happens at setsourcefilter.c:38-41. Enhance your query, using local dataflow, so that it also finds this guard condition.</p>
</blockquote>
<p>有时候<code>__libc_use_alloca</code>的返回值存到一个变量里，然后再用这个变量作为if条件判断。使用<code>local dataflow</code>增加query</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> use_alloca = </span><span style="color:#8fa1b3;">__libc_use_alloca </span><span style="color:#c0c5ce;">(needed);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> group_filter *gf;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(use_alloca)
</span><span style="color:#c0c5ce;">    gf = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> group_filter *) </span><span style="color:#8fa1b3;">alloca </span><span style="color:#c0c5ce;">(needed);
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">      gf = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> group_filter *) </span><span style="color:#96b5b4;">malloc </span><span style="color:#c0c5ce;">(needed);
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(gf == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.internal.DataFlowUtil
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af, LibcUseAlloca lua, GuardCondition gc,
</span><span style="color:#c0c5ce;">    DataFlow::Node source, DataFlow::Node sink
</span><span style="color:#c0c5ce;">where gc.controls(af.getBasicBlock(), _)
</span><span style="color:#c0c5ce;">    and DataFlow::localFlow(source, sink)
</span><span style="color:#c0c5ce;">    and source.asExpr() = lua
</span><span style="color:#c0c5ce;">    and sink.asExpr() = gc
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">select gc
</span></pre>
<h4 id="question-2-3">Question 2.3</h4><blockquote>
<p>Sometimes the call to __libc_use_alloca is wrapped in a call to __builtin_expect. For example, this happens at setenv.c:185. Enhance your query so that it also finds this guard condition.</p>
</blockquote>
<p>有时候<code>__libc_use_alloca</code>被包裹在<code>__builtin_expect</code>中，继续完善</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> use_alloca = </span><span style="color:#8fa1b3;">__libc_use_alloca </span><span style="color:#c0c5ce;">(varlen);
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">__builtin_expect </span><span style="color:#c0c5ce;">(use_alloca, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">))
</span><span style="color:#c0c5ce;">    new_value = (</span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*) </span><span style="color:#8fa1b3;">alloca </span><span style="color:#c0c5ce;">(varlen);
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">      new_value = </span><span style="color:#96b5b4;">malloc </span><span style="color:#c0c5ce;">(varlen);
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(new_value == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">      UNLOCK;
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>改sink，只要guardcondition判断条件中涉及的都匹配，上个版本是要求完整匹配</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.internal.DataFlowUtil
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af, LibcUseAlloca lua, GuardCondition gc,
</span><span style="color:#c0c5ce;">    DataFlow::Node source, DataFlow::Node sink
</span><span style="color:#c0c5ce;">where gc.controls(af.getBasicBlock(), _)
</span><span style="color:#c0c5ce;">    and DataFlow::localFlow(source, sink)
</span><span style="color:#c0c5ce;">    and source.asExpr() = lua
</span><span style="color:#c0c5ce;">    and sink.asExpr() = gc.getAChild*()
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">select gc
</span></pre>
<h4 id="question-2-4">Question 2.4</h4><blockquote>
<p>Sometimes the result of __libc_use_alloca is negated with the ! operator. For example, this happens at getaddrinfo.c:2291-2293. Enhance your query so that it can also handle negations.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">      malloc_results
</span><span style="color:#c0c5ce;">	= !</span><span style="color:#8fa1b3;">__libc_use_alloca </span><span style="color:#c0c5ce;">(alloc_size);
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(malloc_results)
</span><span style="color:#c0c5ce;">	{
</span><span style="color:#c0c5ce;">	  results = </span><span style="color:#96b5b4;">malloc </span><span style="color:#c0c5ce;">(alloc_size);
</span><span style="color:#c0c5ce;">	  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(results == </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">	    {
</span><span style="color:#c0c5ce;">	      </span><span style="color:#8fa1b3;">__free_in6ai </span><span style="color:#c0c5ce;">(in6ai);
</span><span style="color:#c0c5ce;">	      </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> EAI_MEMORY;
</span><span style="color:#c0c5ce;">	    }
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	...
</span></pre>
<p>source用basicblock的node，进而用contains限制basicblock，以及guardcondition的参数也直接改成b1</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.internal.DataFlowUtil
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af, LibcUseAlloca lua, GuardCondition gc,
</span><span style="color:#c0c5ce;">    DataFlow::Node source, DataFlow::Node sink, BasicBlock b1, BasicBlock b2
</span><span style="color:#c0c5ce;">where gc.controls(b1, _)
</span><span style="color:#c0c5ce;">    and b1.contains(af)
</span><span style="color:#c0c5ce;">    and b2.contains(lua)
</span><span style="color:#c0c5ce;">    and DataFlow::localFlow(source, sink)
</span><span style="color:#c0c5ce;">    and source.asExpr() = b2.getANode()
</span><span style="color:#c0c5ce;">    and sink.asExpr() = gc.getAChild*()
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">select gc, source, sink
</span></pre>
<h4 id="question-2-5">Question 2.5</h4><blockquote>
<p>Find calls to alloca that are safe because they are guarded by a call to __libc_use_alloca.</p>
</blockquote>
<p>上述写成一个谓词</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.internal.DataFlowUtil
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    predicate guardedByLUA() {
</span><span style="color:#c0c5ce;">        exists(
</span><span style="color:#c0c5ce;">            LibcUseAlloca lua, GuardCondition gc, DataFlow::Node source,
</span><span style="color:#c0c5ce;">            DataFlow::Node sink, BasicBlock b1, BasicBlock b2 |
</span><span style="color:#c0c5ce;">            gc.controls(b1, _)
</span><span style="color:#c0c5ce;">            and b1.contains(this)
</span><span style="color:#c0c5ce;">            and b2.contains(lua)
</span><span style="color:#c0c5ce;">            and DataFlow::localFlow(source, sink)
</span><span style="color:#c0c5ce;">            and source.asExpr() = b2.getANode()
</span><span style="color:#c0c5ce;">            and sink.asExpr() = gc.getAChild*()
</span><span style="color:#c0c5ce;">        )
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af
</span><span style="color:#c0c5ce;">where af.guardedByLUA()
</span><span style="color:#c0c5ce;">select af
</span></pre>
<h3 id="step-3-combine-steps-1-and-2-to-filter-out-safe-calls">Step 3: combine steps 1 and 2 to filter out safe calls</h3><h4 id="question-3-0">Question 3.0</h4><blockquote>
<p>Question 3.0: use your answer from step 2 to enhance your query from step 1 by filtering out calls to alloca that are safe because they are guarded by a call to __libc_use_alloca.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.internal.DataFlowUtil
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate notSafealloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    predicate guardedByLUA() {
</span><span style="color:#c0c5ce;">        exists(
</span><span style="color:#c0c5ce;">            LibcUseAlloca lua, GuardCondition gc, DataFlow::Node source,
</span><span style="color:#c0c5ce;">            DataFlow::Node sink, BasicBlock b1, BasicBlock b2 |
</span><span style="color:#c0c5ce;">            gc.controls(b1, _)
</span><span style="color:#c0c5ce;">            and b1.contains(this)
</span><span style="color:#c0c5ce;">            and b2.contains(lua)
</span><span style="color:#c0c5ce;">            and DataFlow::localFlow(source, sink)
</span><span style="color:#c0c5ce;">            and source.asExpr() = b2.getANode()
</span><span style="color:#c0c5ce;">            and sink.asExpr() = gc.getAChild*()
</span><span style="color:#c0c5ce;">        )
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from AllocaFunc af
</span><span style="color:#c0c5ce;">where af.guardedByLUA() and af.notSafealloc()
</span><span style="color:#c0c5ce;">select af
</span></pre>
<h3 id="step-4-taint-tracking">Step 4: taint tracking</h3><blockquote>
<p>Question 4.0: Find calls to fopen. (Be aware that fopen is another macro.)
Question 4.0: Write a taint tracking query. The source should be a call to fopen and the sink should be the size argument of an unsafe call to alloca. To help you get started, here is the boilerplate for the query:</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">/**
</span><span style="color:#c0c5ce;">  * @name 41_fopen_to_alloca_taint
</span><span style="color:#c0c5ce;">  * @description Track taint from fopen to alloca.
</span><span style="color:#c0c5ce;">  * @kind path-problem
</span><span style="color:#c0c5ce;">  * @problem.severity warning
</span><span style="color:#c0c5ce;">  */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.TaintTracking
</span><span style="color:#c0c5ce;">import semmle.code.cpp.models.interfaces.DataFlow
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">import DataFlow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">// Track taint through `__strnlen`.
</span><span style="color:#c0c5ce;">class StrlenFunction extends DataFlowFunction {
</span><span style="color:#c0c5ce;">  StrlenFunction() { this.getName().matches(&quot;%str%len%&quot;) }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate hasDataFlow(FunctionInput i, FunctionOutput o) {
</span><span style="color:#c0c5ce;">    i.isInParameter(0) and o.isOutReturnValue()
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">// Track taint through `__getdelim`.
</span><span style="color:#c0c5ce;">class GetDelimFunction extends DataFlowFunction {
</span><span style="color:#c0c5ce;">  GetDelimFunction() { this.getName().matches(&quot;%get%delim%&quot;) }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate hasDataFlow(FunctionInput i, FunctionOutput o) {
</span><span style="color:#c0c5ce;">    i.isInParameter(3) and o.isOutParameterPointer(0)
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class Config extends TaintTracking::Configuration {
</span><span style="color:#c0c5ce;">  Config() { this = &quot;fopen_to_alloca_taint&quot; }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    // TODO
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  override predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    // TODO
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink
</span><span style="color:#c0c5ce;">where cfg.hasFlowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink, source, sink, &quot;fopen flows to alloca&quot;
</span></pre>
<p>这里官方提到的taint tracking已废弃，使用新<a href="https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/dataflow/new/TaintTracking.qll/module.TaintTracking$TaintTracking.html">taint tracking</a></p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">    /**
</span><span style="color:#c0c5ce;">      * @id ayoung
</span><span style="color:#c0c5ce;">      * @name 41_fopen_to_alloca_taint
</span><span style="color:#c0c5ce;">      * @description Track taint from fopen to alloca.
</span><span style="color:#c0c5ce;">      * @kind path-problem
</span><span style="color:#c0c5ce;">      * @problem.severity warning
</span><span style="color:#c0c5ce;">      */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
</span><span style="color:#c0c5ce;">import semmle.code.cpp.controlflow.Guards
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.internal.DataFlowUtil
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.TaintTracking
</span><span style="color:#c0c5ce;">import semmle.code.cpp.models.interfaces.DataFlow
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import DataFlow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class AllocaFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    AllocaFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__builtin_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate isOOBAlloc() {
</span><span style="color:#c0c5ce;">        lowerBound(this.getArgument(0).getFullyConverted()) &lt; 0 or
</span><span style="color:#c0c5ce;">        upperBound(this.getArgument(0).getFullyConverted()) &gt;= 65536
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    predicate isGuardedByLUA() {
</span><span style="color:#c0c5ce;">        exists(
</span><span style="color:#c0c5ce;">            LibcUseAlloca lua, GuardCondition gc, DataFlow::Node source,
</span><span style="color:#c0c5ce;">            DataFlow::Node sink, BasicBlock b1, BasicBlock b2 |
</span><span style="color:#c0c5ce;">            gc.controls(b1, _)
</span><span style="color:#c0c5ce;">            and b1.contains(this)
</span><span style="color:#c0c5ce;">            and b2.contains(lua)
</span><span style="color:#c0c5ce;">            and DataFlow::localFlow(source, sink)
</span><span style="color:#c0c5ce;">            and source.asExpr() = b2.getANode()
</span><span style="color:#c0c5ce;">            and sink.asExpr() = gc.getAChild*()
</span><span style="color:#c0c5ce;">        )
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    predicate isUnsafeAlloc(){
</span><span style="color:#c0c5ce;">        this.isOOBAlloc() and not this.isGuardedByLUA()
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class LibcUseAlloca extends FunctionCall{
</span><span style="color:#c0c5ce;">    LibcUseAlloca() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;__libc_use_alloca&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class FopenFunc extends FunctionCall{
</span><span style="color:#c0c5ce;">    FopenFunc() {
</span><span style="color:#c0c5ce;">        this.getTarget().hasName(&quot;_IO_new_fopen&quot;)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">// Track taint through `__strnlen`.
</span><span style="color:#c0c5ce;">class StrlenFunction extends DataFlowFunction {
</span><span style="color:#c0c5ce;">    StrlenFunction() { this.getName().matches(&quot;%str%len%&quot;) }
</span><span style="color:#c0c5ce;">  
</span><span style="color:#c0c5ce;">    override predicate hasDataFlow(FunctionInput i, FunctionOutput o) {
</span><span style="color:#c0c5ce;">      i.isParameter(0) and o.isReturnValue()
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">  
</span><span style="color:#c0c5ce;">  // Track taint through `__getdelim`.
</span><span style="color:#c0c5ce;">  class GetDelimFunction extends DataFlowFunction {
</span><span style="color:#c0c5ce;">    GetDelimFunction() { this.getName().matches(&quot;%get%delim%&quot;) }
</span><span style="color:#c0c5ce;">  
</span><span style="color:#c0c5ce;">    override predicate hasDataFlow(FunctionInput i, FunctionOutput o) {
</span><span style="color:#c0c5ce;">      i.isParameter(3) and o.isParameterDeref(0)
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class Config extends TaintTracking::Configuration {
</span><span style="color:#c0c5ce;">    Config() { this = &quot;fopen_to_alloca_taint&quot; }
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    override predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">        exists(FopenFunc ffc | source.asExpr() = ffc )
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    override predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">        exists(AllocaFunc af |
</span><span style="color:#c0c5ce;">            sink.asExpr() = af.getArgument(0).getFullyConverted()
</span><span style="color:#c0c5ce;">            and af.isUnsafeAlloc())
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from DataFlow::PathNode source, DataFlow::PathNode sink, Config cfg
</span><span style="color:#c0c5ce;">where cfg.hasFlowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink, source, sink, &quot;fopen flows to alloca&quot;
</span></pre>
<p><img src="/images/image-20231114174814502.png" alt="" />image-20231114174814502</p>
<p>要点：</p>
<ul>
<li><p>注释<code>@kind path-problem</code> + <code>import DataFlow::PathGraph</code> + <code>select sink, source, sink, "fopen flows to alloca"</code>格式 使查询结果出现<code>alert</code>展示数据流路径
<a href="https://codeql.github.com/docs/writing-codeql-queries/creating-path-queries/">相关官方文档</a></p>
</li>
<li><p>编写一个类扩展抽象类<code>DataFlowFunction</code>，用于在没有源代码时对库函数进行准确的数据流建模。要使用这个QL库，创建一个扩展<code>DataFlowFunction</code>的QL类，并使用一个特征谓词来选择要建模的函数或函数集。在该类中，覆盖<code>DataFlowFunction</code>提供的谓词以匹配该函数中的流。也就是说上面两个<code>DataFlowFunction</code>是为了确保涉及<code>strlen</code>和<code>getdelim</code>的污点数据不被遗漏，<code>hasDataFlow</code>谓词限制输入输出，也就是污点数据流向</p>
</li>
</ul>
<h2 id="u-boot-challenge">U-Boot Challenge</h2><h3 id="step-0-finding-the-definition-of-memcpy-ntohl-ntohll-and-ntohs">Step 0: Finding the definition of memcpy, ntohl, ntohll, and ntohs</h3><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Function f
</span><span style="color:#c0c5ce;">where f.getName() = &quot;strlen&quot;
</span><span style="color:#c0c5ce;">select f
</span></pre>
<blockquote>
<p>Question 0.0: Can you work out what the above query is doing?
Hint: Paste it in the Query Console and run it.</p>
</blockquote>
<blockquote>
<p>Question 0.1: Modify the query to find the definition of memcpy.
Hint: Queries have a from, where, and select clause. Have a look at this introduction to the QL language.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Function f
</span><span style="color:#c0c5ce;">where f.getName() = &quot;memcpy&quot;
</span><span style="color:#c0c5ce;">select f
</span></pre>
<blockquote>
<p>Question 0.2: ntohl, ntohll, and ntohs can either be functions or macros (depending on the platform where the code is compiled).
As these snapshots for U-Boot were built on Linux, we know they are going to be macros. Write a query to find the definition of these macros.
Hint: The CodeQL Query Console has an auto-completion feature. Hit Ctrl-Space after the from clause to get the list of objects you can query. Wait a second after typing myObject. to get the l	ist of methods.
Hint: We can use a regular expression to write a query that searches for all three macros at once.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Macro m
</span><span style="color:#c0c5ce;">where m.getName() in [&quot;ntohl&quot;, &quot;ntohll&quot;, &quot;ntohs&quot;]
</span><span style="color:#c0c5ce;">select m
</span></pre>
<h3 id="step-1-finding-the-calls-to-memcpy-ntohl-ntohll-and-ntohs">Step 1: Finding the calls to memcpy, ntohl, ntohll, and ntohs</h3><h4 id="question-1-0">Question 1.0</h4><blockquote>
<p>Find all the calls to memcpy.
Hint: Use the auto-completion feature on the function call variable to guess how to express the relation between a function call and a function, and how to bind them.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from FunctionCall fc
</span><span style="color:#c0c5ce;">where fc.getTarget().getName() = &quot;memcpy&quot;
</span><span style="color:#c0c5ce;">select fc
</span></pre>
<h4 id="question-1-1">Question 1.1</h4><blockquote>
<p>Find all the calls to ntohl, ntohll, and ntohs.
Hint: calls to ntohl, ntohll, and ntohs are macro invocations, unlike memcpy which is a function call.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from MacroInvocation mi
</span><span style="color:#c0c5ce;">where mi.getMacroName() in [&quot;ntohl&quot;, &quot;ntohll&quot;, &quot;ntohs&quot;]
</span><span style="color:#c0c5ce;">select mi
</span></pre>
<h4 id="question-1-2">Question 1.2</h4><blockquote>
<p>Find the expressions that resulted in these macro invocations.
Hint: We need to get the expression of the macro invocation we found in 1.1</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from MacroInvocation mi
</span><span style="color:#c0c5ce;">where mi.getMacroName() in [&quot;ntohl&quot;, &quot;ntohll&quot;, &quot;ntohs&quot;]
</span><span style="color:#c0c5ce;">select mi.getExpr()
</span></pre>
<h3 id="step-2-data-flow-analysis">Step 2: Data flow analysis</h3><p>查找从网络读入的数据并最终被memcpy调用使用</p>
<h4 id="question-2-0">Question 2.0</h4><blockquote>
<p>Write a QL class that finds all the top-level expressions associated with the macro invocations to the calls to ntohl, ntohll, and ntohs.
Hint: Querying this class should give you the same results as in question 1.2</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class NtFunc extends MacroInvocation{
</span><span style="color:#c0c5ce;">    NtFunc() {
</span><span style="color:#c0c5ce;">        this.getMacroName() in [&quot;ntohl&quot;, &quot;ntohll&quot;, &quot;ntohs&quot;]
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from NtFunc nf
</span><span style="color:#c0c5ce;">select nf.getExpr()
</span></pre>
<h4 id="question-2-1">Question 2.1</h4><blockquote>
<p>Create the configuration class, by defining the source and sink. The source should be calls to ntohl, ntohll, or ntohs. The sink should be the size argument of an unsafe call to memcpy.
Hint: The source should be an instance of the class you wrote in part 2.0.
Hint: The sink should be the size argument of calls to memcpy.</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">/**
</span><span style="color:#c0c5ce;"> * @id ayoung
</span><span style="color:#c0c5ce;"> * @name ntoh_to_memcpy_taint
</span><span style="color:#c0c5ce;"> * @description Track taint from ntoh to memcpy.
</span><span style="color:#c0c5ce;"> * @kind path-problem
</span><span style="color:#c0c5ce;"> * @problem.severity warning
</span><span style="color:#c0c5ce;"> */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import cpp
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.TaintTracking
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">import DataFlow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class NtFuncExpr extends Expr{
</span><span style="color:#c0c5ce;">    NtFuncExpr() {
</span><span style="color:#c0c5ce;">        exists(MacroInvocation mi |
</span><span style="color:#c0c5ce;">            mi.getMacro().getName() in [&quot;ntohl&quot;, &quot;ntohll&quot;, &quot;ntohs&quot;]
</span><span style="color:#c0c5ce;">            and this = mi.getExpr())
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class Config extends TaintTracking::Configuration {
</span><span style="color:#c0c5ce;">    Config() { this = &quot;NetworkToMemFuncLength&quot; }
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    override predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">        // exists(NtFuncExpr nfe | source.asExpr() = nfe )
</span><span style="color:#c0c5ce;">        source.asExpr() instanceof NtFuncExpr
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">    override predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">        exists(FunctionCall fc |
</span><span style="color:#c0c5ce;">            sink.asExpr() = fc.getArgument(2)
</span><span style="color:#c0c5ce;">            and fc.getTarget().hasName(&quot;memcpy&quot;) )
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from DataFlow::PathNode source, DataFlow::PathNode sink, Config cfg 
</span><span style="color:#c0c5ce;">where cfg.hasFlowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink, source, sink, &quot;ntoh flows to memcpy&quot;
</span></pre>
<p>taintTracking用new时显示的结果32条，但是有的数据流很怪。去掉new则显示11条，数据流比较正常</p>
<h1 id="advanced-dataflow-scenarios-for-c-c">Advanced dataflow scenarios for C/C++</h1><p>当对字段的写入对CodeQL不可见时（例如，发生在定义不在数据库中的函数中)，我们需要跟踪qualifier，并告诉数据流库它应该将流从限定符qualifier传输到字段访问field access。这是通过向数据流模块添加<code>isAdditionalFlowStep</code>谓词来完成的</p>
<p>当编写additional flow steps来跟踪指针时，您必须决定数据流步骤是应该从指针流出还是间接indirection流出。类似地，您必须决定附加步骤应该针对指针还是间接indirection指向指针。</p>
<h2 id="regular-dataflow-analysis">Regular dataflow analysis</h2><p>考虑数据从<code>user_input()</code>流出并且想知道数据是否能到达<code>sink</code>的参数</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">sink</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">int</span><span style="color:#c0c5ce;">);
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">user_input</span><span style="color:#c0c5ce;">();
</span></pre>
<p>常规的数据流查询如下</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">/**
</span><span style="color:#c0c5ce;">* @kind path-problem
</span><span style="color:#c0c5ce;">*/
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">import Flow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Config implements DataFlow::ConfigSig {
</span><span style="color:#c0c5ce;">  predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    source.asExpr().(Call).getTarget().hasName(&quot;user_input&quot;)
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;sink&quot;) and
</span><span style="color:#c0c5ce;">      sink.asExpr() = call.getAnArgument()
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Flow = DataFlow::Global&lt;Config&gt;;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Flow::PathNode source, Flow::PathNode sink
</span><span style="color:#c0c5ce;">where Flow::flowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</span></pre>
<p>能够捕捉大部分东西，比如：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> A {
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">const int </span><span style="color:#c0c5ce;">*p;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> x;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> B {
</span><span style="color:#c0c5ce;">  A *a;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> y;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">fill_structure</span><span style="color:#c0c5ce;">(B* </span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const int</span><span style="color:#c0c5ce;">* </span><span style="color:#bf616a;">pu</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">  b-&gt;a-&gt;p = pu;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">process_structure</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> B* </span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">sink</span><span style="color:#c0c5ce;">(*b-&gt;a-&gt;p);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">get_and_process</span><span style="color:#c0c5ce;">() {
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> u = </span><span style="color:#8fa1b3;">user_input</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">  B* b = (B*)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(sizeof(B));
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">fill_structure</span><span style="color:#c0c5ce;">(b, &amp;u);
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">process_structure</span><span style="color:#c0c5ce;">(b);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(b);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>这个数据流很好匹配，因为codeql数据库包含要查看的信息：</p>
<ul>
<li>用户输入从<code>user_input()</code>开始，流入<code>fill_structure</code></li>
<li>数据写入对象b，访问路径为<code>[a, p]</code></li>
<li>对象流出<code>fill_structure</code>，并进入<code>process_structure</code></li>
<li><code>process_structure</code>中读取路径<code>[a, p]</code>，并在<code>sink</code>中接收</li>
</ul>
<h2 id="flow-from-a-qualifier-to-a-field-access">Flow from a qualifier to a field access</h2><p>有时候字段访问对codeql来说是不可见的（比如，因为函数的实现不包含在数据库中），所以数据流无法讲所有存储与读取匹配起来，造成遗漏</p>
<p>例如，考虑另一种设置，其中我们的数据源作为<code>write_user_input_to</code>函数的输出参数开始。我们可以使用下面的<code>isSource</code>在数据流库中对这个设置建模</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">  exists(Call call |
</span><span style="color:#c0c5ce;">    call.getTarget().hasName(&quot;write_user_input_to&quot;) and
</span><span style="color:#c0c5ce;">    source.asDefiningArgument() = call.getArgument(0)
</span><span style="color:#c0c5ce;">  )
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>能够匹配下面例子对write_user_input_to的调用</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">write_user_input_to</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*);
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">use_value</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">int</span><span style="color:#c0c5ce;">);
</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">* </span><span style="color:#8fa1b3;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned </span><span style="color:#bf616a;">long</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> U {
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">const int</span><span style="color:#c0c5ce;">* p;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> x;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">process_user_data</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const int</span><span style="color:#c0c5ce;">* </span><span style="color:#bf616a;">p</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">use_value</span><span style="color:#c0c5ce;">(*p);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">get_and_process_user_input_v2</span><span style="color:#c0c5ce;">() {
</span><span style="color:#c0c5ce;">  U* u = (U*)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(sizeof(U));
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">write_user_input_to</span><span style="color:#c0c5ce;">(u);
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">process_user_data</span><span style="color:#c0c5ce;">(u-&gt;p);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(u);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>使用<code>isSource</code>定义，数据流库沿着以下路径跟踪：
从<code>write_user_input_to(...)</code>的传出参数开始，继续到下一行的<code>u-&gt;p</code></p>
<p>然而codeql在读取<code>u-&gt;p</code>之前没有观察到对<code>p</code>的写入，导致数据流在<code>u</code>中断
可以在字段读取中添加额外的流来纠正</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">/**
</span><span style="color:#c0c5ce;">* @kind path-problem
</span><span style="color:#c0c5ce;">*/
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">import Flow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Config implements DataFlow::ConfigSig {
</span><span style="color:#c0c5ce;">  predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;write_user_input_to&quot;) and
</span><span style="color:#c0c5ce;">      source.asDefiningArgument() = call.getArgument(0)
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;use_value&quot;) and
</span><span style="color:#c0c5ce;">      sink.asExpr() = call.getAnArgument()
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
</span><span style="color:#c0c5ce;">    exists(FieldAccess fa |
</span><span style="color:#c0c5ce;">      n1.asIndirectExpr() = fa.getQualifier() and
</span><span style="color:#c0c5ce;">      n2.asIndirectExpr() = fa
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Flow = DataFlow::Global&lt;Config&gt;;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Flow::PathNode source, Flow::PathNode sink
</span><span style="color:#c0c5ce;">where Flow::flowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</span></pre>
<p>注意<code>isSource</code>和<code>isSink</code>是如何按照预期的：我们寻找从<code>write_user_input_to(...)</code>的传出参数开始的流，并以<code>isSink</code>的参数结束。<code>isAdditionalFlow</code>制定了从一个<code>FieldAccess</code>的限定符qualifier到访问结果的流</p>
<p>实际查询中为确保不增加太多流会有限制（因为从字段限定符field qualifier到字段访问field access通常会产生大量虚假流），例如可以将fd限制为针对特定字段的字段访问（限制name），或是在特定结构类型中定义的字段的字段访问（限制type）</p>
<p>这里有一个重要的选择：n2应该是fa的指针值对应的节点，还是fa的间接值（即fa指向的值）</p>
<h2 id="using-asindirectexpr">Using asIndirectExpr</h2><p>如果我们用<code>n2.asIndirectExpr() = fd</code>，我们指定上面示例的流移动到fa指向的位置，这允许数据通过稍后的解引用dereference流动，而这正式我们在追踪从<code>p</code>到<code>*p</code>的数据流所需要的</p>
<p>再考虑一个略有不同的sink</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">write_user_input_to</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*);
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">use_pointer</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">*);
</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">* </span><span style="color:#8fa1b3;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned </span><span style="color:#bf616a;">long</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> U {
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">const int</span><span style="color:#c0c5ce;">* p;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> x;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">process_user_data</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const int</span><span style="color:#c0c5ce;">* </span><span style="color:#bf616a;">p</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">use_pointer</span><span style="color:#c0c5ce;">(p);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">get_and_process_user_input_v2</span><span style="color:#c0c5ce;">() {
</span><span style="color:#c0c5ce;">  U* u = (U*)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(sizeof(U));
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">write_user_input_to</span><span style="color:#c0c5ce;">(u);
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">process_user_data</span><span style="color:#c0c5ce;">(u-&gt;p);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(u);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>和上一个例子唯一的区别是我们的数据最终进入了<code>use_pointer</code>函数调用，该函数接收一个<code>int*</code>而不是<code>int</code>作为参数</p>
<p>由于我们的<code>isAdditionalFlowStep</code>已经实现了FieldAccess的间接，所以已经跟踪了字段指向的内容，故可以通过<code>sink.asIndirectExpr()</code>找到数据</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">  exists(Call call |
</span><span style="color:#c0c5ce;">    call.getTarget().hasName(&quot;use_pointer&quot;) and
</span><span style="color:#c0c5ce;">    sink.asIndirectExpr() = call.getAnArgument()
</span><span style="color:#c0c5ce;">  )
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="using-asexpr">Using asExpr</h2><p>另外，第二个例子中的流也可以被以下方式跟踪：</p>
<ul>
<li>修改<code>isAdditionalFlowStep</code>，使其针对代表<code>FieldAccess</code>的值而不是其指向的值</li>
<li>修改<code>isSink</code>明确追踪实参传递给<code>use_pointer</code>的值（而不是实参指向的值）</li>
</ul>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">/**
</span><span style="color:#c0c5ce;">* @kind path-problem
</span><span style="color:#c0c5ce;">*/
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">import Flow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Config implements DataFlow::ConfigSig {
</span><span style="color:#c0c5ce;">  predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;write_user_input_to&quot;) and
</span><span style="color:#c0c5ce;">      source.asDefiningArgument() = call.getArgument(0)
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;use_pointer&quot;) and
</span><span style="color:#c0c5ce;">      sink.asExpr() = call.getAnArgument()
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
</span><span style="color:#c0c5ce;">    exists(FieldAccess fa |
</span><span style="color:#c0c5ce;">      n1.asIndirectExpr() = fa.getQualifier() and
</span><span style="color:#c0c5ce;">      n2.asExpr() = fa
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Flow = DataFlow::Global&lt;Config&gt;;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Flow::PathNode source, Flow::PathNode sink
</span><span style="color:#c0c5ce;">where Flow::flowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</span></pre>
<p>当到达<code>u-&gt;p</code>时，增加的step将流从限定符qualifier指向的值传递到FieldAccess的结果，在此之后数据流流到<code>user_pointer</code>中的<code>p</code>，由于指定了<code>isSink</code>为实参的值，故最终找到结果</p>
<h2 id="passing-the-address-of-a-variable-to-use-pointer">Passing the address of a variable to use_pointer</h2><p>考虑另一种情况，<code>U</code>包含一个<code>int</code>数据，我们传递数据的地址给<code>use_pointer</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">void write_user_input_to(void*);
</span><span style="color:#c0c5ce;">void use_pointer(int*);
</span><span style="color:#c0c5ce;">void* malloc(unsigned long);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">struct U {
</span><span style="color:#c0c5ce;">  int data;
</span><span style="color:#c0c5ce;">  int x;
</span><span style="color:#c0c5ce;">}; 
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">void process_user_data(int data) {
</span><span style="color:#c0c5ce;">  // ...
</span><span style="color:#c0c5ce;">  use_pointer(&amp;data);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">void get_and_process_user_input_v2() {
</span><span style="color:#c0c5ce;">  U* u = (U*)malloc(sizeof(U));
</span><span style="color:#c0c5ce;">  write_user_input_to(u);
</span><span style="color:#c0c5ce;">  process_user_data(u-&gt;data);
</span><span style="color:#c0c5ce;">  free(u);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>因为<code>data</code>字段现在是一个<code>int</code>而不是<code>int*</code>，字段不再是indirection，所以没道理再用<code>asIndirectExpr</code>。所以只能污染字段的值
然而因为我们传递了<code>data</code>的地址给<code>use_pointer</code>，污点值是被<code>use_pointer</code>的参数指向的值（因为<code>&amp;data</code>指向的值就是数据）</p>
<p>结合上述两点</p>
<ul>
<li>使用<code>asExpr</code>描述污点数据</li>
<li>选择参数的indirection</li>
</ul>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">/**
</span><span style="color:#c0c5ce;">* @kind path-problem
</span><span style="color:#c0c5ce;">*/
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">import Flow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Config implements DataFlow::ConfigSig {
</span><span style="color:#c0c5ce;">  predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;write_user_input_to&quot;) and
</span><span style="color:#c0c5ce;">      source.asDefiningArgument() = call.getArgument(0)
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;use_pointer&quot;) and
</span><span style="color:#c0c5ce;">      sink.asIndirectExpr() = call.getAnArgument()
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
</span><span style="color:#c0c5ce;">    exists(FieldAccess fa |
</span><span style="color:#c0c5ce;">      n1.asIndirectExpr() = fa.getQualifier() and
</span><span style="color:#c0c5ce;">      n2.asExpr() = fa
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Flow = DataFlow::Global&lt;Config&gt;;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Flow::PathNode source, Flow::PathNode sink
</span><span style="color:#c0c5ce;">where Flow::flowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</span></pre>
<h2 id="specifying-implicit-reads">Specifying implicit reads</h2><p>本节考虑，一个特定的字段被污染了，希望找到可能从该对象读取的任何位置，包括读取一组未知字段的任何位置</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> A {
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">const int </span><span style="color:#c0c5ce;">*p;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> x;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> B {
</span><span style="color:#c0c5ce;">  A *a;
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> z;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">user_input</span><span style="color:#c0c5ce;">();
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">read_data</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*);
</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">malloc</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">size_t</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">get_input_and_read_data</span><span style="color:#c0c5ce;">() {
</span><span style="color:#c0c5ce;">  B b;
</span><span style="color:#c0c5ce;">  b.</span><span style="color:#bf616a;">a </span><span style="color:#c0c5ce;">= (A *)</span><span style="color:#96b5b4;">malloc</span><span style="color:#c0c5ce;">(sizeof(A));
</span><span style="color:#c0c5ce;">  b.</span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">-&gt;x = </span><span style="color:#8fa1b3;">user_input</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">  </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">  </span><span style="color:#8fa1b3;">read_data</span><span style="color:#c0c5ce;">(&amp;b);
</span><span style="color:#c0c5ce;">  </span><span style="color:#96b5b4;">free</span><span style="color:#c0c5ce;">(b.</span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>数据流：
通过访问路径<code>[a, x]</code>将一个用户控制的值写入对象b
<code>b</code>被传给数据库中没有定义的<code>read_data</code></p>
<p>现在需要追踪这个流向<code>read_data</code>的用户输入</p>
<p>数据流库有一个特定的谓词来处理该场景，因此不需要用<code>isAdditionalFlowStep</code>添加流
相反，只需告诉数据流库<code>read_data</code>是一个sink且可以隐式地implicitly从传递给它的对象的字段读取数据。为此实现<code>allowImplicitRead</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">/**
</span><span style="color:#c0c5ce;">* @kind path-problem
</span><span style="color:#c0c5ce;">*/
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">import semmle.code.cpp.dataflow.new.DataFlow
</span><span style="color:#c0c5ce;">import Flow::PathGraph
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Config implements DataFlow::ConfigSig {
</span><span style="color:#c0c5ce;">  predicate isSource(DataFlow::Node source) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;user_input&quot;) and
</span><span style="color:#c0c5ce;">      source.asExpr() = call
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate isSink(DataFlow::Node sink) {
</span><span style="color:#c0c5ce;">    exists(Call call |
</span><span style="color:#c0c5ce;">      call.getTarget().hasName(&quot;read_data&quot;) and
</span><span style="color:#c0c5ce;">      sink.asIndirectExpr() = call.getAnArgument()
</span><span style="color:#c0c5ce;">    )
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">  predicate allowImplicitRead(DataFlow::Node n, DataFlow::ContentSet cs) {
</span><span style="color:#c0c5ce;">    isSink(n) and
</span><span style="color:#c0c5ce;">    cs.getAReadContent().(DataFlow::FieldContent).getField().hasName([&quot;a&quot;, &quot;x&quot;])
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">module Flow = DataFlow::Global&lt;Config&gt;;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">from Flow::PathNode source, Flow::PathNode sink
</span><span style="color:#c0c5ce;">where Flow::flowPath(source, sink)
</span><span style="color:#c0c5ce;">select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</span></pre>
<p><code>allowImplicitRead</code>谓词指定，如果再一个满足<code>isSink</code>节点，可以假设一个名为a或x的字段隐式读取
现在数据流库看到：</p>
<ul>
<li>用户输入从<code>user_input()</code>开始</li>
<li>数据通过访问路径<code>[a, x]</code>流入b</li>
<li>数据流入<code>&amp;b</code>的间接indirection（如对象b）</li>
<li>隐式读取字段x，然后隐式读取sink处的字段a</li>
</ul>
<p>最终就通过一个空的路径到达了满足<code>isSink</code>的节点，成功跟踪了完整的数据流</p>
<h1 id="ming-ling-xing-fang-fa">命令行方法</h1><h2 id="codeql-query-run">codeql query run</h2><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">codeql query run -d hello_codedb hello.ql
</span></pre>
<h2 id="codeql-database-analyze">codeql database analyze</h2><p>没跑起来
出现：A fatal error occurred: Could not process query metadata for /home/ayoung/codeql/vscode-codeql-starter/codeql-custom-queries-cpp/hello.ql. Error was: Expected result pattern(s) are not present for problem query: Expected alternating entity/string and string columns. [INVALID_RESULT_PATTERNS]</p>
<p>最后<code>select source.getNode().asExpr().(FunctionCall).getEnclosingFunction().toString(), "AAAA"</code>时，query run有结果但database analyze跑通结果为空</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">#创建数据库
</span><span style="color:#c0c5ce;">codeql database create databaseName --source-root=D:/xxljob --language=java
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">#更新数据库
</span><span style="color:#c0c5ce;">codeql database upgrade databaseName
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">#执行扫描规则
</span><span style="color:#c0c5ce;">codeql database analyze [databasePath] [rulesPath] --format=csv --output=result.csv
</span><span style="color:#c0c5ce;">#eg:codeql database analyze ./libtiff1_dbjob /root/Codeql/ql/codeql/cpp/ql/src/Security/CWE --format=csv --output=result.csv
</span></pre>
<h2 id="docs">docs</h2><p>https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/</p>
<p>https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-cpp/ ，表格，一一对应数据结构与codeql class关系</p>
<h1 id="misc">misc</h1><p><code>predicate</code>，当前方法没有返回值
<code>exist</code>，子查询，是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回true or false，来决定筛选出哪些数据</p>
<p>source，漏洞污染输入点
sink，漏洞污染执行点</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a76a75871d69198b57600b1dda778910.png" alt="" /></p>
</main>
                <aside class="toc-sidebar">
                    <div class="toc-sticky-container">
                        <div class="toc-header">:: Contents ::</div>
                        <ul class="toc-list"><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#gai-shu">概述</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#huan-jing-da-jian">环境搭建</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#demo">demo</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#systemming-ling-zhu-ru">system命令注入</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shu-zu-yue-jie">数组越界</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#yin-yong-ji-shu-xiang-guan">引用计数相关</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#wai-bu-han-shu-jian-mo">外部函数建模</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#tutorial">tutorial</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#wei-ci">谓词</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#di-gui">递归</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#lei">类</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#github-security-lab-ctf">GitHub Security Lab CTF</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#segv-hunt">SEGV hunt</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#intro">intro</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step-0-finding-the-definition-of-alloca">Step 0: finding the definition of alloca</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step-1-finding-the-calls-to-alloca-and-filtering-out-small-allocation-sizes">Step 1: finding the calls to alloca and filtering out small allocation sizes</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step2-filtering-out-calls-that-are-guarded-by-libc-use-alloca">step2 filtering out calls that are guarded by __libc_use_alloca</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-0">Question 2.0</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-1">Question 2.1</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-2">Question 2.2</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-3">Question 2.3</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-4">Question 2.4</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-5">Question 2.5</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step-3-combine-steps-1-and-2-to-filter-out-safe-calls">Step 3: combine steps 1 and 2 to filter out safe calls</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-3-0">Question 3.0</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step-4-taint-tracking">Step 4: taint tracking</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#u-boot-challenge">U-Boot Challenge</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step-0-finding-the-definition-of-memcpy-ntohl-ntohll-and-ntohs">Step 0: Finding the definition of memcpy, ntohl, ntohll, and ntohs</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step-1-finding-the-calls-to-memcpy-ntohl-ntohll-and-ntohs">Step 1: Finding the calls to memcpy, ntohl, ntohll, and ntohs</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-1-0">Question 1.0</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-1-1">Question 1.1</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-1-2">Question 1.2</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#step-2-data-flow-analysis">Step 2: Data flow analysis</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-0">Question 2.0</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#question-2-1">Question 2.1</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#advanced-dataflow-scenarios-for-c-c">Advanced dataflow scenarios for C/C++</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#regular-dataflow-analysis">Regular dataflow analysis</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#flow-from-a-qualifier-to-a-field-access">Flow from a qualifier to a field access</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#using-asindirectexpr">Using asIndirectExpr</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#using-asexpr">Using asExpr</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#passing-the-address-of-a-variable-to-use-pointer">Passing the address of a variable to use_pointer</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#specifying-implicit-reads">Specifying implicit reads</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#ming-ling-xing-fang-fa">命令行方法</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#codeql-query-run">codeql query run</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#codeql-database-analyze">codeql database analyze</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#docs">docs</a></li><li class="toc-item toc-h1" data-level="1" style="margin-left:12px"><a href="#misc">misc</a></li></ul>
                    </div>
                </aside>
            </div> 
    <footer style="margin-top: 50px; border-top: 1px solid #333; padding-top: 20px; font-size: 0.8rem; color: #555; text-align: center;">
        Built with Rust. <span style="color: #66ed59;">EOF</span>
    </footer>
    <button id="back-to-top" aria-label="Back to Top">^TOP</button>
    <script src="/script.js"></script>
</body>
</html>